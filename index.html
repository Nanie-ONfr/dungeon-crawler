<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #gameContainer {
            background: #16213e;
            border: 3px solid #0f3460;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #e94560;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameArea {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        #canvasContainer {
            flex: 1;
            min-width: 900px;
            max-width: 100%;
        }

        canvas {
            border: 2px solid #0f3460;
            background: #0a0e27;
            display: block;
            width: 100%;
            height: auto;
        }

        #sidebar {
            flex: 0 0 280px;
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            display: none;  /* Hidden - using in-game HUD now */
        }

        .stat-section {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 5px;
            border-left: 3px solid #e94560;
        }

        .stat-section h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-bar {
            width: 100%;
            height: 20px;
            background: #1a1a2e;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b9d);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .xp-bar-fill {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
        }

        #inventory {
            max-height: 150px;
            overflow-y: auto;
        }

        .item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            margin: 3px 0;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .item:hover {
            background: rgba(233, 69, 96, 0.3);
        }

        .item.weapon { border-left: 3px solid #ff6b6b; }
        .item.armor { border-left: 3px solid #4ecdc4; }
        .item.potion { border-left: 3px solid #95e1d3; }

        #log {
            background: #0a0e27;
            padding: 10px;
            border-radius: 5px;
            height: 100px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 10px;
        }

        #gameControls {
            display: grid;
            grid-template-columns: repeat(5, 52px);
            grid-template-rows: repeat(2, 52px);
            gap: 8px;
            margin-top: 12px;
            justify-content: center;
            padding: 10px;
            background: linear-gradient(180deg, #2a1f1a 0%, #1a1510 100%);
            border: 4px solid #3d2f25;
            border-radius: 0;
        }

        #gameControls .button {
            width: 52px;
            height: 52px;
            margin: 0;
            padding: 2px;
            font-size: 20px;
            line-height: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Medieval 8-bit stone button style */
            background:
                linear-gradient(135deg, #6b5a4a 0%, #4a3f35 25%, #5a4f42 50%, #3d342c 75%, #2a241f 100%);
            border: 4px solid;
            border-color: #8a7a6a #2a1f1a #2a1f1a #8a7a6a;
            border-radius: 0;
            box-shadow:
                inset 3px 3px 0 #9a8a7a,
                inset -3px -3px 0 #1a1510,
                inset 6px 6px 0 rgba(255,255,255,0.1),
                5px 5px 0 #0a0805,
                6px 6px 0 #000;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            color: #e8dcc8;
            image-rendering: pixelated;
            cursor: pointer;
            transition: none;
            position: relative;
        }

        /* Stone texture overlay */
        #gameControls .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(0,0,0,0.1) 4px, rgba(0,0,0,0.1) 8px),
                repeating-linear-gradient(90deg, transparent, transparent 4px, rgba(0,0,0,0.05) 4px, rgba(0,0,0,0.05) 8px);
            pointer-events: none;
        }

        #gameControls .button .price {
            font-size: 10px;
            font-weight: bold;
            margin-top: 1px;
            color: #ffd700;
            text-shadow: 1px 1px 0 #000, 2px 2px 0 #4a3000;
        }

        #gameControls .button:hover {
            background:
                linear-gradient(135deg, #7b6a5a 0%, #5a4f45 25%, #6a5f52 50%, #4d443c 75%, #3a342f 100%);
            border-color: #aa9a8a #3a2f2a #3a2f2a #aa9a8a;
            color: #fff;
            box-shadow:
                inset 3px 3px 0 #ba9a8a,
                inset -3px -3px 0 #2a2520,
                inset 6px 6px 0 rgba(255,255,255,0.15),
                5px 5px 0 #0a0805,
                6px 6px 0 #000;
        }

        #gameControls .button:active {
            background:
                linear-gradient(135deg, #4a3f35 0%, #3d342c 50%, #2a241f 100%);
            border-color: #2a1f1a #6a5a4a #6a5a4a #2a1f1a;
            box-shadow:
                inset 3px 3px 0 #1a1510,
                inset -3px -3px 0 #6a5a4a,
                2px 2px 0 #0a0805;
            transform: translate(3px, 3px);
        }

        #gameControls .button:disabled {
            background: #3a3535;
            border-color: #4a4545 #2a2525 #2a2525 #4a4545;
            color: #666;
            box-shadow:
                inset 3px 3px 0 #4a4545,
                inset -3px -3px 0 #1a1515,
                5px 5px 0 #0a0805;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .log-message {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-combat { color: #e94560; }
        .log-loot { color: #4CAF50; }
        .log-info { color: #64b5f6; }
        .log-level { color: #ffd700; font-weight: bold; }

        #controls {
            margin-top: 15px;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 5px;
            font-size: 11px;
        }

        #controls h4 {
            color: #e94560;
            margin-bottom: 5px;
        }

        .button {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin: 5px 0;
            width: 100%;
            font-size: 12px;
            transition: background 0.2s;
        }

        .button:hover {
            background: #ff6b9d;
        }

        .button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px 70px;
            border-radius: 15px;
            border: 4px solid #e94560;
            text-align: center;
            display: none;
            z-index: 9999;
            min-width: 350px;
        }

        #gameContainer:fullscreen #gameOver,
        #gameContainer:-webkit-full-screen #gameOver {
            position: fixed;
            padding: 60px 90px;
            min-width: 450px;
        }

        #gameOver h2 {
            color: #e94560;
            font-size: 42px;
            margin-bottom: 25px;
        }

        #gameContainer:fullscreen #gameOver h2,
        #gameContainer:-webkit-full-screen #gameOver h2 {
            font-size: 52px;
        }

        #gameOver .stats {
            font-size: 18px;
        }

        #gameContainer:fullscreen #gameOver .stats,
        #gameContainer:-webkit-full-screen #gameOver .stats {
            font-size: 22px;
        }

        #highscoreMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 4px solid #fbbf24;
            text-align: center;
            display: none;
            z-index: 9998;
            min-width: 300px;
        }
        #highscoreMenu h2 {
            color: #fbbf24;
            font-size: 32px;
            margin-bottom: 20px;
        }
        #highscoreList {
            text-align: left;
            margin: 15px 0;
            max-height: 250px;
            overflow-y: auto;
        }
        .highscore-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 5px;
            font-size: 14px;
        }
        .highscore-entry.current {
            background: rgba(251, 191, 36, 0.3);
            border: 1px solid #fbbf24;
        }
        .highscore-rank { color: #fbbf24; font-weight: bold; width: 30px; }
        .highscore-name { color: #fff; flex: 1; margin: 0 10px; }
        .highscore-score { color: #4ade80; }
        #highscoreInput {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: #1a1a2e;
            border: 2px solid #fbbf24;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
            text-align: center;
        }

        /* Fullscreen mode styles */
        #gameContainer:fullscreen,
        #gameContainer:-webkit-full-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #0a0e27;
            padding: 10px;
            max-width: none;
        }

        #gameContainer:fullscreen #gameArea,
        #gameContainer:-webkit-full-screen #gameArea {
            flex-direction: column;
            align-items: center;
        }

        #gameContainer:fullscreen #canvasContainer,
        #gameContainer:-webkit-full-screen #canvasContainer {
            min-width: auto;
            max-width: 95vw;
        }

        #gameContainer:fullscreen canvas,
        #gameContainer:-webkit-full-screen canvas {
            max-height: 70vh;
            max-width: 95vw;
            width: auto;
            height: auto;
        }

        #gameContainer:fullscreen h1,
        #gameContainer:-webkit-full-screen h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        #gameContainer:fullscreen #gameControls,
        #gameContainer:-webkit-full-screen #gameControls {
            max-width: 500px;
        }

        #gameContainer:fullscreen #log,
        #gameContainer:-webkit-full-screen #log {
            max-width: 95vw;
            height: 80px;
        }

        #gameOver .stats {
            margin: 20px 0;
            font-size: 16px;
        }

        /* Secret Menu Styles */
        #secretMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 4px solid #fbbf24;
            text-align: center;
            z-index: 9999;
            min-width: 400px;
        }

        #secretMenu h2 {
            color: #fbbf24;
            font-size: 28px;
            margin-bottom: 20px;
        }

        #commandInput {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            border: 2px solid #fbbf24;
            border-radius: 5px;
            color: #fff;
            margin-bottom: 15px;
        }

        #commandInput:focus {
            outline: none;
            border-color: #f59e0b;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        #commandOutput {
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            font-size: 13px;
            margin-bottom: 15px;
        }

        #commandOutput .cmd-success { color: #4ade80; }
        #commandOutput .cmd-error { color: #ef4444; }
        #commandOutput .cmd-info { color: #60a5fa; }
        #commandOutput .cmd-line { margin: 3px 0; }

        #secretMenu .hint {
            color: #666;
            font-size: 12px;
            margin-bottom: 15px;
        }

        /* Spawn Protection Indicator */
        .spawn-protected {
            animation: spawnShield 0.5s ease-in-out infinite alternate;
        }

        @keyframes spawnShield {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>DUNGEON CRAWLER</h1>
        <div id="gameArea">
            <div id="canvasContainer">
                <canvas id="gameCanvas" width="900" height="550"></canvas>
                <div id="gameControls">
                    <button class="button" id="healButton">HP<span class="price">50G</span></button>
                    <button class="button" id="fullHealButton">HP+<span class="price" id="fullHealPrice">--G</span></button>
                    <button class="button" id="attackBoostButton">ATK<span class="price">75G</span></button>
                    <button class="button" id="defenseBoostButton">DEF<span class="price">75G</span></button>
                    <button class="button" id="buyBombButton">BMB<span class="price">40G</span></button>
                    <button class="button" id="fullscreenButton">[FS]</button>
                    <button class="button" id="saveButton">[S]</button>
                    <button class="button" id="loadButton">[L]</button>
                    <button class="button" id="highscoreButton">[HS]</button>
                    <button class="button" id="musicButton">[M]</button>
                    <button class="button" id="sfxButton">[FX]</button>
                </div>
                <div id="log"></div>
            </div>
            <div id="sidebar">
                <div class="stat-section">
                    <h3>CHARAKTER</h3>
                    <div class="stat">
                        <span>Level:</span>
                        <span id="playerLevel">1</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="hpBar">
                            <span id="hpText">100/100</span>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill xp-bar-fill" id="xpBar">
                            <span id="xpText">0/100</span>
                        </div>
                    </div>
                    <div class="stat">
                        <span>ATK:</span>
                        <span id="playerAttack">10</span>
                    </div>
                    <div class="stat">
                        <span>DEF:</span>
                        <span id="playerDefense">5</span>
                    </div>
                    <div class="stat">
                        <span>Gold:</span>
                        <span id="playerGold">0</span>
                    </div>
                </div>

                <div class="stat-section">
                    <h3>INVENTAR</h3>
                    <div id="inventory"></div>
                </div>

                <div class="stat-section">
                    <h3>DUNGEON</h3>
                    <div class="stat">
                        <span>Level:</span>
                        <span id="currentRoom">1</span>
                    </div>
                    <div class="stat">
                        <span>Monster:</span>
                        <span id="monsterCount">0</span>
                    </div>
                </div>

                <div class="stat-section" id="abilitiesSection" style="display: none;">
                    <h3>SKILLS</h3>
                    <div id="abilities"></div>
                </div>

                <div id="controls">
                    <h4>STEUERUNG</h4>
                    <p>WASD / Pfeiltasten: Bewegung</p>
                    <p>Leertaste: Angriff</p>
                    <p>E: Item aufheben</p>
                    <p>Left Shift: Dash</p>
                    <p>1-9: Item benutzen</p>
                </div>

                <div class="stat-section">
                    <h4>SCHWIERIGKEIT</h4>
                    <select id="difficultySelect" style="width: 100%; padding: 5px; background: #1a1a2e; color: #fff; border: 1px solid #4a4a6a; border-radius: 3px;">
                        <option value="easy">[E] Leicht</option>
                        <option value="normal" selected>[N] Normal</option>
                        <option value="hard">[H] Schwer</option>
                    </select>
                    <p id="difficultyInfo" style="font-size: 10px; color: #888; margin-top: 5px;">Monster: Normal</p>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h2>GAME OVER</h2>
            <div class="stats">
                <p>Du hast Level <span id="finalLevel"></span> erreicht</p>
                <p>Räume erkundet: <span id="roomsCleared"></span></p>
                <p>Monster besiegt: <span id="monstersKilled"></span></p>
                <p>Gold gesammelt: <span id="totalGold"></span></p>
                <p style="color: #fbbf24; font-size: 22px; margin-top: 15px;">Score: <span id="finalScore"></span></p>
            </div>
            <div id="saveScoreSection" style="margin: 15px 0;">
                <input type="text" id="playerNameInput" placeholder="Dein Name..." maxlength="15" style="padding: 8px; width: 150px; background: #1a1a2e; border: 2px solid #fbbf24; border-radius: 5px; color: #fff; text-align: center;">
                <button class="button" onclick="saveHighscore()" style="margin-left: 10px;">Speichern</button>
            </div>
            <button class="button" onclick="location.reload()">Neues Spiel</button>
            <button class="button" onclick="openUpgradeMenuFromGameOver()" style="margin-left: 10px; background: linear-gradient(135deg, #a855f7, #7c3aed);">Upgrades</button>
        </div>

        <div id="highscoreMenu">
            <h2>HIGHSCORES</h2>
            <div id="highscoreList"></div>
            <button class="button" onclick="closeHighscoreMenu()">Schließen</button>
        </div>

        <div id="secretMenu" style="display: none;">
            <h2>ENTWICKLER-MENU</h2>
            <div id="secretMenuContent">
                <input type="text" id="commandInput" placeholder="Befehl eingeben..." autocomplete="off">
                <div id="commandOutput"></div>
                <p class="hint">Tippe /help für alle Befehle</p>
            </div>
            <button class="button" onclick="closeSecretMenu()">Schließen (ESC)</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ==================== PIXEL ART ICON SYSTEM ====================
        const Icons = {
            // Draw a pixel art icon at specified position and size
            draw(iconName, x, y, size = 16) {
                const drawFn = this.icons[iconName];
                if (drawFn) {
                    ctx.save();
                    ctx.translate(x - size/2, y - size/2);
                    drawFn(ctx, size);
                    ctx.restore();
                }
            },

            // All icon drawing functions
            icons: {
                // Weapons & Combat
                sword(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(7*u, 1*u, 2*u, 10*u);
                    ctx.fillStyle = '#d4d4d4';
                    ctx.fillRect(8*u, 1*u, 1*u, 10*u);
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(6*u, 11*u, 4*u, 2*u);
                    ctx.fillStyle = '#a0522d';
                    ctx.fillRect(7*u, 13*u, 2*u, 2*u);
                },
                dagger(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(7*u, 3*u, 2*u, 7*u);
                    ctx.fillStyle = '#d4d4d4';
                    ctx.fillRect(8*u, 3*u, 1*u, 6*u);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(6*u, 10*u, 4*u, 1*u);
                    ctx.fillStyle = '#2d2d2d';
                    ctx.fillRect(7*u, 11*u, 2*u, 3*u);
                },
                staff(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(7*u, 4*u, 2*u, 11*u);
                    ctx.fillStyle = '#9333ea';
                    ctx.fillRect(6*u, 1*u, 4*u, 4*u);
                    ctx.fillStyle = '#c084fc';
                    ctx.fillRect(7*u, 2*u, 2*u, 2*u);
                },
                axe(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(7*u, 5*u, 2*u, 10*u);
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(3*u, 1*u, 6*u, 5*u);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(4*u, 2*u, 4*u, 3*u);
                },

                // Classes
                warrior(ctx, s) {
                    const u = s / 16;
                    // Helmet
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(4*u, 2*u, 8*u, 6*u);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(5*u, 3*u, 6*u, 4*u);
                    // Face slit
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(6*u, 4*u, 4*u, 2*u);
                    // Plume
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(7*u, 0*u, 2*u, 3*u);
                },
                mage(ctx, s) {
                    const u = s / 16;
                    // Hat
                    ctx.fillStyle = '#4c1d95';
                    ctx.fillRect(5*u, 6*u, 6*u, 3*u);
                    ctx.fillRect(6*u, 4*u, 4*u, 2*u);
                    ctx.fillRect(7*u, 1*u, 2*u, 3*u);
                    // Star
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 2*u, 2*u, 1*u);
                    // Face
                    ctx.fillStyle = '#fcd9b6';
                    ctx.fillRect(6*u, 9*u, 4*u, 4*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(6*u, 10*u, 1*u, 1*u);
                    ctx.fillRect(9*u, 10*u, 1*u, 1*u);
                },
                rogue(ctx, s) {
                    const u = s / 16;
                    // Hood
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(4*u, 2*u, 8*u, 7*u);
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(5*u, 3*u, 6*u, 5*u);
                    // Face shadow
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(5*u, 5*u, 6*u, 3*u);
                    // Eyes
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(6*u, 6*u, 1*u, 1*u);
                    ctx.fillRect(9*u, 6*u, 1*u, 1*u);
                },

                // Stats & UI
                heart(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(2*u, 4*u, 4*u, 4*u);
                    ctx.fillRect(10*u, 4*u, 4*u, 4*u);
                    ctx.fillRect(4*u, 2*u, 2*u, 2*u);
                    ctx.fillRect(10*u, 2*u, 2*u, 2*u);
                    ctx.fillRect(4*u, 8*u, 8*u, 2*u);
                    ctx.fillRect(6*u, 10*u, 4*u, 2*u);
                    ctx.fillRect(7*u, 12*u, 2*u, 2*u);
                    ctx.fillStyle = '#fca5a5';
                    ctx.fillRect(4*u, 4*u, 2*u, 2*u);
                },
                shield(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(3*u, 2*u, 10*u, 10*u);
                    ctx.fillRect(5*u, 12*u, 6*u, 2*u);
                    ctx.fillRect(7*u, 14*u, 2*u, 1*u);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillRect(4*u, 3*u, 8*u, 8*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 5*u, 2*u, 5*u);
                    ctx.fillRect(5*u, 7*u, 6*u, 2*u);
                },
                mana(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#2563eb';
                    ctx.fillRect(6*u, 2*u, 4*u, 3*u);
                    ctx.fillRect(5*u, 5*u, 6*u, 3*u);
                    ctx.fillRect(4*u, 8*u, 8*u, 3*u);
                    ctx.fillRect(5*u, 11*u, 6*u, 2*u);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillRect(7*u, 3*u, 2*u, 1*u);
                    ctx.fillRect(6*u, 6*u, 4*u, 1*u);
                },
                gold(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#ca8a04';
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(5*u, 5*u, 6*u, 6*u);
                    ctx.fillStyle = '#fcd34d';
                    ctx.fillRect(6*u, 6*u, 2*u, 2*u);
                    ctx.fillStyle = '#ca8a04';
                    ctx.fillRect(7*u, 7*u, 2*u, 3*u);
                },
                soul(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#7c3aed';
                    ctx.fillRect(5*u, 2*u, 6*u, 4*u);
                    ctx.fillRect(4*u, 4*u, 8*u, 6*u);
                    ctx.fillRect(5*u, 10*u, 3*u, 3*u);
                    ctx.fillRect(8*u, 10*u, 3*u, 3*u);
                    ctx.fillStyle = '#a78bfa';
                    ctx.fillRect(6*u, 3*u, 4*u, 2*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 5*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 5*u, 2*u, 2*u);
                    ctx.fillStyle = '#c4b5fd';
                    ctx.fillRect(5*u, 5*u, 1*u, 1*u);
                    ctx.fillRect(9*u, 5*u, 1*u, 1*u);
                },
                target(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(6*u, 2*u, 4*u, 12*u);
                    ctx.fillRect(2*u, 6*u, 12*u, 4*u);
                    ctx.fillStyle = '#fef2f2';
                    ctx.fillRect(7*u, 3*u, 2*u, 10*u);
                    ctx.fillRect(3*u, 7*u, 10*u, 2*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(7*u, 7*u, 2*u, 2*u);
                },

                // Monsters
                skull(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#e5e5e5';
                    ctx.fillRect(4*u, 2*u, 8*u, 8*u);
                    ctx.fillRect(5*u, 10*u, 6*u, 3*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 4*u, 2*u, 3*u);
                    ctx.fillRect(9*u, 4*u, 2*u, 3*u);
                    ctx.fillRect(7*u, 7*u, 2*u, 2*u);
                    ctx.fillRect(5*u, 11*u, 1*u, 2*u);
                    ctx.fillRect(7*u, 11*u, 2*u, 2*u);
                    ctx.fillRect(10*u, 11*u, 1*u, 2*u);
                },
                demon(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#991b1b';
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillRect(2*u, 1*u, 3*u, 4*u);
                    ctx.fillRect(11*u, 1*u, 3*u, 4*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(5*u, 6*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 6*u, 2*u, 2*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(6*u, 10*u, 4*u, 1*u);
                },
                goblin(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(4*u, 3*u, 8*u, 8*u);
                    ctx.fillRect(2*u, 4*u, 3*u, 4*u);
                    ctx.fillRect(11*u, 4*u, 3*u, 4*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 5*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 5*u, 2*u, 2*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(6*u, 8*u, 4*u, 2*u);
                },
                orc(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#4a7c59';
                    ctx.fillRect(3*u, 3*u, 10*u, 10*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(4*u, 5*u, 3*u, 2*u);
                    ctx.fillRect(9*u, 5*u, 3*u, 2*u);
                    ctx.fillStyle = '#e5e5e5';
                    ctx.fillRect(5*u, 10*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 10*u, 2*u, 2*u);
                },
                wizard(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#1e3a5f';
                    ctx.fillRect(4*u, 6*u, 8*u, 7*u);
                    ctx.fillRect(5*u, 3*u, 6*u, 3*u);
                    ctx.fillRect(7*u, 1*u, 2*u, 3*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 0*u, 2*u, 2*u);
                    ctx.fillStyle = '#fcd9b6';
                    ctx.fillRect(5*u, 7*u, 6*u, 4*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(6*u, 8*u, 1*u, 1*u);
                    ctx.fillRect(9*u, 8*u, 1*u, 1*u);
                },
                boss(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#7c2d12';
                    ctx.fillRect(3*u, 4*u, 10*u, 10*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(3*u, 1*u, 4*u, 4*u);
                    ctx.fillRect(9*u, 1*u, 4*u, 4*u);
                    ctx.fillStyle = '#fcd34d';
                    ctx.fillRect(4*u, 2*u, 2*u, 2*u);
                    ctx.fillRect(10*u, 2*u, 2*u, 2*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(5*u, 7*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 7*u, 2*u, 2*u);
                },

                // Items & Effects
                potion(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(6*u, 2*u, 4*u, 2*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(5*u, 4*u, 6*u, 8*u);
                    ctx.fillRect(6*u, 12*u, 4*u, 2*u);
                    ctx.fillStyle = '#fca5a5';
                    ctx.fillRect(6*u, 5*u, 2*u, 3*u);
                },
                star(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 1*u, 2*u, 4*u);
                    ctx.fillRect(3*u, 5*u, 10*u, 2*u);
                    ctx.fillRect(5*u, 7*u, 2*u, 3*u);
                    ctx.fillRect(9*u, 7*u, 2*u, 3*u);
                    ctx.fillRect(4*u, 10*u, 2*u, 3*u);
                    ctx.fillRect(10*u, 10*u, 2*u, 3*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(7*u, 5*u, 2*u, 2*u);
                },
                lightning(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(8*u, 1*u, 4*u, 2*u);
                    ctx.fillRect(6*u, 3*u, 4*u, 2*u);
                    ctx.fillRect(4*u, 5*u, 6*u, 2*u);
                    ctx.fillRect(6*u, 7*u, 4*u, 2*u);
                    ctx.fillRect(4*u, 9*u, 4*u, 2*u);
                    ctx.fillRect(2*u, 11*u, 4*u, 2*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(6*u, 5*u, 2*u, 2*u);
                },
                fire(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(6*u, 2*u, 4*u, 4*u);
                    ctx.fillRect(4*u, 5*u, 8*u, 4*u);
                    ctx.fillRect(5*u, 9*u, 6*u, 3*u);
                    ctx.fillRect(6*u, 12*u, 4*u, 2*u);
                    ctx.fillStyle = '#f97316';
                    ctx.fillRect(6*u, 4*u, 4*u, 4*u);
                    ctx.fillRect(6*u, 8*u, 4*u, 3*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 6*u, 2*u, 4*u);
                },
                chest(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(2*u, 5*u, 12*u, 9*u);
                    ctx.fillStyle = '#b45309';
                    ctx.fillRect(3*u, 6*u, 10*u, 7*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 8*u, 2*u, 3*u);
                    ctx.fillRect(6*u, 9*u, 4*u, 1*u);
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(2*u, 5*u, 12*u, 1*u);
                },
                key(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(4*u, 3*u, 4*u, 4*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 4*u, 2*u, 2*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 5*u, 6*u, 2*u);
                    ctx.fillRect(10*u, 7*u, 2*u, 2*u);
                    ctx.fillRect(12*u, 7*u, 2*u, 2*u);
                },
                door(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(3*u, 2*u, 10*u, 13*u);
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(4*u, 3*u, 8*u, 11*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(10*u, 8*u, 2*u, 2*u);
                },
                scroll(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(4*u, 3*u, 8*u, 10*u);
                    ctx.fillStyle = '#d4a574';
                    ctx.fillRect(3*u, 3*u, 2*u, 10*u);
                    ctx.fillRect(11*u, 3*u, 2*u, 10*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 5*u, 6*u, 1*u);
                    ctx.fillRect(5*u, 7*u, 6*u, 1*u);
                    ctx.fillRect(5*u, 9*u, 4*u, 1*u);
                },
                trophy(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(4*u, 2*u, 8*u, 6*u);
                    ctx.fillRect(2*u, 3*u, 3*u, 4*u);
                    ctx.fillRect(11*u, 3*u, 3*u, 4*u);
                    ctx.fillRect(6*u, 8*u, 4*u, 2*u);
                    ctx.fillRect(5*u, 10*u, 6*u, 1*u);
                    ctx.fillRect(4*u, 11*u, 8*u, 2*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(6*u, 4*u, 4*u, 2*u);
                },
                medal(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(5*u, 1*u, 6*u, 3*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(6*u, 6*u, 4*u, 4*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 7*u, 2*u, 2*u);
                },
                map(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#d4a574';
                    ctx.fillRect(2*u, 3*u, 12*u, 10*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(3*u, 4*u, 10*u, 8*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(9*u, 6*u, 2*u, 2*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(4*u, 5*u, 1*u, 4*u);
                    ctx.fillRect(4*u, 9*u, 3*u, 1*u);
                    ctx.fillRect(6*u, 6*u, 1*u, 3*u);
                },
                bomb(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(4*u, 6*u, 8*u, 8*u);
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(5*u, 7*u, 6*u, 6*u);
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(7*u, 3*u, 2*u, 4*u);
                    ctx.fillStyle = '#f97316';
                    ctx.fillRect(6*u, 1*u, 4*u, 3*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 1*u, 2*u, 2*u);
                },
                bag(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(4*u, 4*u, 8*u, 10*u);
                    ctx.fillStyle = '#b45309';
                    ctx.fillRect(5*u, 5*u, 6*u, 8*u);
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(5*u, 2*u, 2*u, 3*u);
                    ctx.fillRect(9*u, 2*u, 2*u, 3*u);
                    ctx.fillRect(6*u, 1*u, 4*u, 2*u);
                },
                clock(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(3*u, 3*u, 10*u, 10*u);
                    ctx.fillStyle = '#e5e5e5';
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(7*u, 5*u, 2*u, 4*u);
                    ctx.fillRect(8*u, 7*u, 3*u, 2*u);
                },
                magnifier(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(3*u, 3*u, 8*u, 8*u);
                    ctx.fillStyle = '#bfdbfe';
                    ctx.fillRect(4*u, 4*u, 6*u, 6*u);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillRect(5*u, 5*u, 2*u, 2*u);
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(9*u, 9*u, 5*u, 2*u);
                    ctx.fillRect(10*u, 11*u, 2*u, 3*u);
                },
                controller(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(2*u, 5*u, 12*u, 7*u);
                    ctx.fillRect(4*u, 4*u, 3*u, 2*u);
                    ctx.fillRect(9*u, 4*u, 3*u, 2*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(4*u, 7*u, 3*u, 3*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(10*u, 7*u, 2*u, 2*u);
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(12*u, 8*u, 2*u, 2*u);
                },
                coffin(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(5*u, 1*u, 6*u, 2*u);
                    ctx.fillRect(4*u, 3*u, 8*u, 10*u);
                    ctx.fillRect(5*u, 13*u, 6*u, 2*u);
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(5*u, 4*u, 6*u, 8*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 6*u, 2*u, 4*u);
                    ctx.fillRect(6*u, 7*u, 4*u, 2*u);
                },
                peace(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(4*u, 2*u, 8*u, 12*u);
                    ctx.fillRect(2*u, 4*u, 12*u, 8*u);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(5*u, 3*u, 6*u, 10*u);
                    ctx.fillRect(3*u, 5*u, 10*u, 6*u);
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(7*u, 4*u, 2*u, 8*u);
                    ctx.fillRect(5*u, 8*u, 2*u, 4*u);
                    ctx.fillRect(9*u, 8*u, 2*u, 4*u);
                },
                sparkle(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7*u, 2*u, 2*u, 3*u);
                    ctx.fillRect(7*u, 11*u, 2*u, 3*u);
                    ctx.fillRect(2*u, 7*u, 3*u, 2*u);
                    ctx.fillRect(11*u, 7*u, 3*u, 2*u);
                    ctx.fillRect(4*u, 4*u, 2*u, 2*u);
                    ctx.fillRect(10*u, 4*u, 2*u, 2*u);
                    ctx.fillRect(4*u, 10*u, 2*u, 2*u);
                    ctx.fillRect(10*u, 10*u, 2*u, 2*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(7*u, 7*u, 2*u, 2*u);
                },
                gem(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#2563eb';
                    ctx.fillRect(5*u, 3*u, 6*u, 3*u);
                    ctx.fillRect(4*u, 6*u, 8*u, 4*u);
                    ctx.fillRect(5*u, 10*u, 6*u, 2*u);
                    ctx.fillRect(6*u, 12*u, 4*u, 1*u);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillRect(6*u, 4*u, 2*u, 2*u);
                    ctx.fillRect(5*u, 7*u, 3*u, 2*u);
                },
                coin(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#ca8a04';
                    ctx.fillRect(5*u, 3*u, 6*u, 10*u);
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(5*u, 4*u, 6*u, 8*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(6*u, 5*u, 1*u, 2*u);
                },
                revive(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(7*u, 1*u, 2*u, 3*u);
                    ctx.fillRect(5*u, 4*u, 6*u, 2*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(4*u, 6*u, 8*u, 8*u);
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(5*u, 7*u, 6*u, 6*u);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(7*u, 8*u, 2*u, 4*u);
                    ctx.fillRect(6*u, 9*u, 4*u, 2*u);
                },
                upgrade(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(7*u, 2*u, 2*u, 10*u);
                    ctx.fillRect(4*u, 5*u, 8*u, 2*u);
                    ctx.fillRect(5*u, 3*u, 6*u, 2*u);
                    ctx.fillRect(6*u, 1*u, 4*u, 3*u);
                },
                angry(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(4*u, 4*u, 8*u, 8*u);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(5*u, 5*u, 2*u, 2*u);
                    ctx.fillRect(9*u, 5*u, 2*u, 2*u);
                    ctx.fillRect(6*u, 9*u, 4*u, 2*u);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(4*u, 3*u, 3*u, 1*u);
                    ctx.fillRect(9*u, 3*u, 3*u, 1*u);
                },
                trident(ctx, s) {
                    const u = s / 16;
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(7*u, 5*u, 2*u, 10*u);
                    ctx.fillRect(4*u, 1*u, 2*u, 5*u);
                    ctx.fillRect(7*u, 1*u, 2*u, 5*u);
                    ctx.fillRect(10*u, 1*u, 2*u, 5*u);
                    ctx.fillRect(4*u, 5*u, 8*u, 2*u);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(5*u, 2*u, 1*u, 3*u);
                    ctx.fillRect(8*u, 2*u, 1*u, 3*u);
                    ctx.fillRect(11*u, 2*u, 1*u, 3*u);
                }
            }
        };

        // Easing functions for smoother animations
        const easing = {
            // Smooth deceleration
            easeOutQuad: t => t * (2 - t),
            // Smooth acceleration
            easeInQuad: t => t * t,
            // Smooth acceleration and deceleration
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            // Bouncy effect
            easeOutBack: t => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            },
            // Elastic bounce
            easeOutElastic: t => {
                if (t === 0 || t === 1) return t;
                return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
            },
            // Smooth sine wave
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2
        };

        // Smooth interpolation helper
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Game State
        const game = {
            player: {
                x: 450,  // Center of 900 wide canvas
                y: 275,  // Center of 550 tall canvas
                size: 20,
                hp: 100,
                maxHp: 100,
                mana: 100,
                maxMana: 100,
                manaRegen: 0.1, // Mana regeneration per frame
                attack: 10,
                defense: 5,
                speed: 3,
                level: 1,
                xp: 0,
                xpToNext: 100,
                gold: 0,
                inventory: [],
                equippedWeapon: null,  // Currently equipped weapon
                equippedArmor: null,   // Currently equipped armor
                baseAttack: 10,
                baseDefense: 5,
                attackCooldown: 0,
                animFrame: 0,
                direction: 0,
                // Animation states
                isMoving: false,
                walkFrame: 0,
                flashTimer: 0,
                facingLeft: false,
                facingAngle: 0,
                isAttacking: false,
                attackFrame: 0,
                isShooting: false,
                shootFrame: 0,
                isDrinking: false,
                drinkFrame: 0,
                isDying: false,
                deathFrame: 0,
                levelUpAnim: 0,
                // Abilities
                abilities: {
                    bomb: { cooldown: 0, maxCooldown: 120 }  // Only from items now
                },
                // Critical hit system
                critChance: 0.10,        // 10% base crit chance
                critMultiplier: 2.0,     // 2x damage on crit
                // Status effects
                statusEffects: [],       // { type, damage, duration, tickTimer }
                // Player abilities
                dashCooldown: 0,
                dashMaxCooldown: 90,     // 1.5 seconds
                isDashing: false,
                dashTimer: 0,
                dashDirection: { x: 0, y: 0 },
                // Spawn protection (5 seconds = 300 frames at 60fps for level 1)
                spawnProtection: 300,
                // Temporary boosts (from items/effects)
                attackBoost: 0,
                defenseBoost: 0,
                // Drinking animation state
                drinkHeal: 0,
                drinkColor: '#ef4444',
                // Equipment reference (for save/load)
                equipment: null,
                // Class passive tracking
                hasAttacked: false,
                // Revives from permanent upgrades
                revivesLeft: 0
            },
            // Difficulty setting
            difficulty: 'normal',  // 'easy', 'normal', 'hard'
            // Secret menu state
            secretMenuOpen: false,
            secretCodeBuffer: '',
            secretCodeUnlocked: false,
            bombs: [],  // Active bombs
            monsters: [],
            dyingMonsters: [],  // For death animations
            items: [],
            projectiles: [],
            particles: [],
            dashAfterimages: [], // Dash trail afterimages
            screenShake: 0,     // Screen shake effect
            roomTransition: 0,  // Room transition fade
            doorCooldown: 0,    // Prevent instant door re-trigger
            currentRoom: 1,
            roomsCleared: 0,
            monstersKilled: 0,
            walls: [],
            doors: [],
            // Multi-room system
            currentSubRoom: 0,      // Current room within floor
            subRooms: [],           // Array of rooms in current floor
            roomDoors: [],          // Doors connecting rooms
            floorCleared: false,    // All rooms on floor cleared
            // Camera for large rooms
            camera: { x: 0, y: 0 },
            worldWidth: 800,        // Total world width (will be set by room generation)
            worldHeight: 600,       // Total world height
            // Dark level system
            isDarkLevel: false,
            lightRadius: 150,
            lastDarkLevel: 0,       // Track when last dark level occurred
            // Secret room system
            hasSecretRoom: false,
            secretRoomFound: false,
            secretWalls: [],        // Breakable walls for secret rooms
            // Permanent upgrade system
            showUpgradeMenu: false,
            upgradeMenuFromGameOver: false,
            souls: 0, // Meta currency earned on death
            permanentUpgrades: {
                maxHp: 0,       // +10 HP per level
                attack: 0,     // +2 attack per level
                defense: 0,    // +1 defense per level
                critChance: 0, // +2% crit per level
                manaRegen: 0,  // +0.02 mana regen per level
                soulGain: 0,   // +10% soul gain per level
                startGold: 0,  // +50 gold start per level
                revive: 0      // +1 revive per level (max 3)
            },
            // Achievements system
            achievements: {},
            achievementNotifications: [],
            showAchievements: false,
            paused: false,
            pauseMenuSelection: 0,  // 0=Fortsetzen, 1=Steuerung, 2=Neustart, 3=Beenden
            elitesKilled: 0,
            critCount: 0,
            bossesKilled: 0,
            gameStartTime: 0, // For speedrun achievement
            damageTakenThisFloor: 0, // For no-hit achievement
            // Daily challenges tracking
            dailyChallengesCompleted: [],
            skillsUsed: 0,
            berserkKills: 0,
            maxComboReached: 0,
            lowHpSurvives: 0,
            damageTakenTotal: 0,
            // Character customization
            customization: { skin: 0, hair: 0, outfit: 0 },
            // Bestiary
            bestiary: {},
            showBestiary: false,
            // Key bindings
            keyBindings: {},
            showKeyBindings: false,
            rebindingKey: null,
            // Combo system
            comboCount: 0,
            comboTimer: 0,
            maxComboTime: 90,       // 1.5 seconds to maintain combo
            // Berserk mode
            berserkActive: false,
            berserkTimer: 0,
            // Room events
            traps: [],
            treasureChests: [],
            // Void system (Abgrund an den Seiten)
            voidZones: [],           // Bereiche wo man fallen kann
            fallingEntities: [],     // Spieler/Items die gerade fallen
            voidBorderWidth: 8,      // Dünne Randmauer um Void
            keys: {
                w: false, a: false, s: false, d: false,
                ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
                e: false, x: false,
                q: false, r: false, f: false, c: false // Skill keys
            },
            spacePressed: false,
            animCounter: 0,
            // Debug mode
            debugMode: false,
            lastFrameTime: performance.now(),
            fps: 60,
            frameCount: 0,
            fpsUpdateTime: 0,
            // Player class system
            playerClass: null, // 'warrior', 'mage', 'rogue'
            classSelected: false,
            gameOverCalled: false, // Prevent multiple gameOver calls
            // Skill system
            skills: {
                fireball: { name: 'Feuerball', cooldown: 0, maxCooldown: 180, manaCost: 20, key: 'q', damage: 30, unlocked: true },
                heal: { name: 'Heilung', cooldown: 0, maxCooldown: 300, manaCost: 35, key: 'r', healAmount: 50, unlocked: true },
                shield: { name: 'Schild', cooldown: 0, maxCooldown: 240, manaCost: 25, key: 'f', duration: 180, unlocked: true },
                whirlwind: { name: 'Wirbelwind', cooldown: 0, maxCooldown: 150, manaCost: 30, key: 'c', damage: 20, radius: 100, unlocked: true }
            },
            skillEffects: [], // Active skill visual effects
            shieldActive: false,
            shieldTimer: 0
        };

        // Player class definitions mit klassenspezifischen Skills
        const playerClasses = {
            warrior: {
                name: 'Krieger',
                description: 'Hohe HP & Verteidigung, Nahkampf-Spezialist',
                color: '#ef4444',
                icon: 'warrior',
                bonuses: {
                    maxHp: 50,
                    maxMana: -20,
                    attack: 5,
                    defense: 3,
                    speed: 0,
                    critChance: 0,
                    manaRegen: -0.02
                },
                passive: 'Berserker-Wut: +20% Schaden unter 30% HP',
                skills: {
                    fireball: { name: 'Wirbelwind', cooldown: 0, maxCooldown: 150, manaCost: 25, key: 'q', damage: 25, radius: 110, unlocked: true, execute: 'whirlwind' },
                    heal: { name: 'Kampfschrei', cooldown: 0, maxCooldown: 360, manaCost: 20, key: 'r', duration: 300, atkBoost: 8, unlocked: true, execute: 'warcry' },
                    shield: { name: 'Kriegsschild', cooldown: 0, maxCooldown: 240, manaCost: 25, key: 'f', duration: 240, unlocked: true, execute: 'shield' },
                    whirlwind: { name: 'Ansturm', cooldown: 0, maxCooldown: 180, manaCost: 30, key: 'c', damage: 40, unlocked: true, execute: 'charge' }
                },
                skillInfo: ['[Q] Wirbelwind', '[R] Kampfschrei', '[F] Schild', '[C] Ansturm']
            },
            mage: {
                name: 'Magier',
                description: 'Hohes Mana & Magie-Schaden, Fernkampf',
                color: '#8b5cf6',
                icon: 'mage',
                bonuses: {
                    maxHp: -20,
                    maxMana: 50,
                    attack: -2,
                    defense: -2,
                    speed: 0,
                    critChance: 0,
                    manaRegen: 0.05
                },
                passive: 'Arkane Macht: Skills +30% Schaden',
                skills: {
                    fireball: { name: 'Feuerball', cooldown: 0, maxCooldown: 150, manaCost: 20, key: 'q', damage: 35, unlocked: true, execute: 'fireball' },
                    heal: { name: 'Heilung', cooldown: 0, maxCooldown: 300, manaCost: 35, key: 'r', healAmount: 60, unlocked: true, execute: 'heal' },
                    shield: { name: 'Frostnova', cooldown: 0, maxCooldown: 200, manaCost: 30, key: 'f', damage: 15, radius: 130, slowDuration: 180, unlocked: true, execute: 'frostnova' },
                    whirlwind: { name: 'Blitzschlag', cooldown: 0, maxCooldown: 120, manaCost: 15, key: 'c', damage: 22, chains: 3, unlocked: true, execute: 'lightning' }
                },
                skillInfo: ['[Q] Feuerball', '[R] Heilung', '[F] Frostnova', '[C] Blitz']
            },
            rogue: {
                name: 'Schurke',
                description: 'Schnell & tödlich, hohe Crit-Chance',
                color: '#22c55e',
                icon: 'rogue',
                bonuses: {
                    maxHp: -10,
                    maxMana: 0,
                    attack: 3,
                    defense: -1,
                    speed: 0.5,
                    critChance: 0.15,
                    manaRegen: 0
                },
                passive: 'Hinterhalt: Erste Attacke +50% Schaden',
                skills: {
                    fireball: { name: 'Messerwurf', cooldown: 0, maxCooldown: 90, manaCost: 12, key: 'q', damage: 18, unlocked: true, execute: 'knifethrow' },
                    heal: { name: 'Giftklinge', cooldown: 0, maxCooldown: 240, manaCost: 20, key: 'r', damage: 5, duration: 240, unlocked: true, execute: 'poisonblade' },
                    shield: { name: 'Rauchbombe', cooldown: 0, maxCooldown: 300, manaCost: 25, key: 'f', duration: 180, unlocked: true, execute: 'smokebomb' },
                    whirlwind: { name: 'Schattenschritt', cooldown: 0, maxCooldown: 150, manaCost: 20, key: 'c', damage: 30, unlocked: true, execute: 'shadowstep' }
                },
                skillInfo: ['[Q] Messerwurf', '[R] Giftklinge', '[F] Rauchbombe', '[C] Schatten']
            }
        };

        // Apply class bonuses to player
        function selectPlayerClass(className) {
            if (!playerClasses[className]) return;

            const classData = playerClasses[className];
            game.playerClass = className;
            game.classSelected = true;

            // Apply bonuses
            game.player.maxHp += classData.bonuses.maxHp;
            game.player.hp = game.player.maxHp;
            game.player.maxMana += classData.bonuses.maxMana;
            game.player.mana = game.player.maxMana;
            game.player.attack += classData.bonuses.attack;
            game.player.baseAttack += classData.bonuses.attack;
            game.player.defense += classData.bonuses.defense;
            game.player.baseDefense += classData.bonuses.defense;
            game.player.speed += classData.bonuses.speed;
            game.player.critChance += classData.bonuses.critChance;
            game.player.manaRegen += classData.bonuses.manaRegen;

            // Apply class-specific skills
            if (classData.skills) {
                for (const key in classData.skills) {
                    const skillDef = classData.skills[key];
                    game.skills[key] = {
                        name: skillDef.name,
                        cooldown: 0,
                        maxCooldown: skillDef.maxCooldown,
                        manaCost: skillDef.manaCost,
                        key: skillDef.key,
                        unlocked: skillDef.unlocked,
                        execute: skillDef.execute,
                        damage: skillDef.damage,
                        radius: skillDef.radius,
                        healAmount: skillDef.healAmount,
                        duration: skillDef.duration,
                        atkBoost: skillDef.atkBoost,
                        slowDuration: skillDef.slowDuration,
                        chains: skillDef.chains
                    };
                }
            }

            addLog(`[KLASSE] ${classData.name} gewählt!`, 'skill');
            addLog(`[PASSIV] ${classData.passive}`, 'info');

            // Apply permanent upgrades after class selection
            applyPermanentUpgrades();
        }

        // Permanent upgrade definitions
        const permanentUpgradesDef = {
            maxHp: {
                name: 'Vitalität',
                description: '+10 Max HP',
                icon: 'heart',
                baseCost: 50,
                costMultiplier: 1.5,
                maxLevel: 20,
                effect: (level) => level * 10
            },
            attack: {
                name: 'Stärke',
                description: '+2 Angriff',
                icon: 'sword',
                baseCost: 75,
                costMultiplier: 1.6,
                maxLevel: 15,
                effect: (level) => level * 2
            },
            defense: {
                name: 'Zähigkeit',
                description: '+1 Verteidigung',
                icon: 'shield',
                baseCost: 60,
                costMultiplier: 1.5,
                maxLevel: 15,
                effect: (level) => level * 1
            },
            critChance: {
                name: 'Präzision',
                description: '+2% Krit-Chance',
                icon: 'target',
                baseCost: 100,
                costMultiplier: 1.7,
                maxLevel: 10,
                effect: (level) => level * 0.02
            },
            manaRegen: {
                name: 'Meditation',
                description: '+0.02 Mana-Regen',
                icon: 'mana',
                baseCost: 80,
                costMultiplier: 1.5,
                maxLevel: 10,
                effect: (level) => level * 0.02
            },
            soulGain: {
                name: 'Seelensammler',
                description: '+10% Seelen-Gewinn',
                icon: 'soul',
                baseCost: 150,
                costMultiplier: 2.0,
                maxLevel: 10,
                effect: (level) => level * 0.1
            },
            startGold: {
                name: 'Erbe',
                description: '+50 Start-Gold',
                icon: 'gold',
                baseCost: 100,
                costMultiplier: 1.8,
                maxLevel: 10,
                effect: (level) => level * 50
            },
            revive: {
                name: 'Zweite Chance',
                description: '+1 Wiederbelebung',
                icon: 'revive',
                baseCost: 500,
                costMultiplier: 3.0,
                maxLevel: 3,
                effect: (level) => level
            }
        };

        // Calculate upgrade cost
        function getUpgradeCost(upgradeKey) {
            const def = permanentUpgradesDef[upgradeKey];
            const level = game.permanentUpgrades[upgradeKey];
            return Math.floor(def.baseCost * Math.pow(def.costMultiplier, level));
        }

        // Purchase upgrade
        function purchaseUpgrade(upgradeKey) {
            const def = permanentUpgradesDef[upgradeKey];
            const currentLevel = game.permanentUpgrades[upgradeKey];

            if (currentLevel >= def.maxLevel) return false;

            const cost = getUpgradeCost(upgradeKey);
            if (game.souls < cost) return false;

            game.souls -= cost;
            game.permanentUpgrades[upgradeKey]++;
            savePermanentProgress();
            sfx.levelUp();
            return true;
        }

        // Apply permanent upgrades to player
        function applyPermanentUpgrades() {
            const u = game.permanentUpgrades;

            // Apply stat bonuses
            game.player.maxHp += permanentUpgradesDef.maxHp.effect(u.maxHp);
            game.player.hp = game.player.maxHp;
            game.player.attack += permanentUpgradesDef.attack.effect(u.attack);
            game.player.baseAttack += permanentUpgradesDef.attack.effect(u.attack);
            game.player.defense += permanentUpgradesDef.defense.effect(u.defense);
            game.player.baseDefense += permanentUpgradesDef.defense.effect(u.defense);
            game.player.critChance += permanentUpgradesDef.critChance.effect(u.critChance);
            game.player.manaRegen += permanentUpgradesDef.manaRegen.effect(u.manaRegen);

            // Start gold
            game.player.gold += permanentUpgradesDef.startGold.effect(u.startGold);

            // Revives stored for later use
            game.player.revivesLeft = u.revive;
        }

        // Save permanent progress to localStorage
        function savePermanentProgress() {
            const data = {
                souls: game.souls,
                upgrades: game.permanentUpgrades,
                totalRuns: game.totalRuns || 0,
                bestRoom: game.bestRoom || 0,
                totalKills: game.totalKills || 0
            };
            localStorage.setItem('dungeonCrawlerPermanent', JSON.stringify(data));
        }

        // Load permanent progress from localStorage
        function loadPermanentProgress() {
            const saved = localStorage.getItem('dungeonCrawlerPermanent');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    game.souls = data.souls || 0;
                    game.permanentUpgrades = { ...game.permanentUpgrades, ...data.upgrades };
                    game.totalRuns = data.totalRuns || 0;
                    game.bestRoom = data.bestRoom || 0;
                    game.totalKills = data.totalKills || 0;
                } catch (e) {
                    console.error('Failed to load permanent progress:', e);
                }
            }
        }

        // Calculate souls earned on death
        function calculateSoulsEarned() {
            let base = game.currentRoom * 10 + game.player.level * 5;
            // Bonus for kills
            base += game.monstersKilled * 2;
            // Bonus for boss kills
            base += game.bossesKilled * 50;
            // Apply soul gain bonus
            const soulBonus = 1 + permanentUpgradesDef.soulGain.effect(game.permanentUpgrades.soulGain);
            return Math.floor(base * soulBonus);
        }

        // ==================== ACHIEVEMENTS SYSTEM ====================
        const achievementsDef = {
            // Combat achievements
            firstBlood: { name: 'Erstes Blut', description: 'Töte deinen ersten Feind', icon: 'dagger', reward: 10 },
            slayer10: { name: 'Schlächter', description: 'Töte 10 Monster in einem Run', icon: 'sword', reward: 20 },
            slayer50: { name: 'Massenmörder', description: 'Töte 50 Monster in einem Run', icon: 'skull', reward: 50 },
            slayer100: { name: 'Völkermord', description: 'Töte 100 Monster in einem Run', icon: 'coffin', reward: 100 },
            bossKiller: { name: 'Boss-Bezwinger', description: 'Besiege deinen ersten Boss', icon: 'demon', reward: 30 },
            bossSlayer5: { name: 'Boss-Jäger', description: 'Besiege 5 Bosse in einem Run', icon: 'trident', reward: 75 },
            eliteHunter: { name: 'Elite-Jäger', description: 'Besiege 10 Elite-Monster', icon: 'sparkle', reward: 40 },
            critMaster: { name: 'Krit-Meister', description: 'Lande 50 kritische Treffer', icon: 'target', reward: 35 },

            // Progression achievements
            level5: { name: 'Aufsteiger', description: 'Erreiche Level 5', icon: 'upgrade', reward: 15 },
            level10: { name: 'Veteran', description: 'Erreiche Level 10', icon: 'medal', reward: 30 },
            level20: { name: 'Held', description: 'Erreiche Level 20', icon: 'trophy', reward: 60 },
            room5: { name: 'Erkunder', description: 'Erreiche Etage 5', icon: 'door', reward: 20 },
            room10: { name: 'Abenteurer', description: 'Erreiche Etage 10', icon: 'map', reward: 40 },
            room20: { name: 'Legendär', description: 'Erreiche Etage 20', icon: 'trophy', reward: 100 },

            // Wealth achievements
            gold100: { name: 'Sammler', description: 'Sammle 100 Gold', icon: 'coin', reward: 10 },
            gold500: { name: 'Reicher', description: 'Sammle 500 Gold', icon: 'gold', reward: 25 },
            gold1000: { name: 'Millionär', description: 'Sammle 1000 Gold', icon: 'gem', reward: 50 },

            // Special achievements
            noHit: { name: 'Unberührt', description: 'Schließe Etage 1 ohne Schaden', icon: 'shield', reward: 50 },
            speedRunner: { name: 'Speed-Runner', description: 'Erreiche Etage 5 in unter 3 Minuten', icon: 'lightning', reward: 40 },
            survivor: { name: 'Überlebender', description: 'Überlebe mit unter 10 HP', icon: 'heart', reward: 25 },
            secretFinder: { name: 'Geheimnis-Finder', description: 'Finde einen geheimen Raum', icon: 'magnifier', reward: 30 },
            fullInventory: { name: 'Hamster', description: 'Fülle dein Inventar komplett', icon: 'bag', reward: 15 },
            comboKing: { name: 'Kombo-König', description: 'Erreiche eine 10er Kombo', icon: 'fire', reward: 35 },
            berserker: { name: 'Berserker', description: 'Aktiviere den Berserker-Modus', icon: 'angry', reward: 20 },

            // Class achievements
            warriorMaster: { name: 'Krieger-Meister', description: 'Erreiche Etage 10 als Krieger', icon: 'warrior', reward: 40 },
            mageMaster: { name: 'Magier-Meister', description: 'Erreiche Etage 10 als Magier', icon: 'mage', reward: 40 },
            rogueMaster: { name: 'Schurken-Meister', description: 'Erreiche Etage 10 als Schurke', icon: 'rogue', reward: 40 },

            // Meta achievements
            runs10: { name: 'Anfänger', description: 'Spiele 10 Runs', icon: 'controller', reward: 25 },
            runs50: { name: 'Stammgast', description: 'Spiele 50 Runs', icon: 'target', reward: 75 },
            totalKills100: { name: 'Mörder', description: 'Töte insgesamt 100 Monster', icon: 'skull', reward: 30 },
            totalKills1000: { name: 'Sensenmann', description: 'Töte insgesamt 1000 Monster', icon: 'coffin', reward: 100 },
            souls500: { name: 'Seelensammler', description: 'Sammle insgesamt 500 Seelen', icon: 'soul', reward: 50 },
            allUpgrades: { name: 'Maximiert', description: 'Kaufe alle Upgrades', icon: 'star', reward: 200 }
        };

        // Initialize achievements tracking in game state
        function initAchievements() {
            if (!game.achievements) {
                game.achievements = {};
                for (const key of Object.keys(achievementsDef)) {
                    game.achievements[key] = false;
                }
            }
            if (!game.achievementNotifications) {
                game.achievementNotifications = [];
            }
            game.showAchievements = false;
        }

        // Check and unlock achievement
        function unlockAchievement(key) {
            if (!game.achievements || game.achievements[key]) return false;

            const achievement = achievementsDef[key];
            if (!achievement) return false;

            game.achievements[key] = true;
            game.souls += achievement.reward;

            // Add notification
            game.achievementNotifications.push({
                name: achievement.name,
                icon: achievement.icon,
                reward: achievement.reward,
                timer: 180 // 3 seconds
            });

            saveAchievements();
            sfx.achievement(); // Triumphant achievement sound
            addLog(`[ERFOLG] ${achievement.name} freigeschaltet! +${achievement.reward} Seelen`, 'legendary');
            return true;
        }

        // Check achievements based on current game state
        function checkAchievements() {
            if (!game.achievements) initAchievements();

            // Combat achievements
            if (game.monstersKilled >= 1) unlockAchievement('firstBlood');
            if (game.monstersKilled >= 10) unlockAchievement('slayer10');
            if (game.monstersKilled >= 50) unlockAchievement('slayer50');
            if (game.monstersKilled >= 100) unlockAchievement('slayer100');
            if (game.bossesKilled >= 1) unlockAchievement('bossKiller');
            if (game.bossesKilled >= 5) unlockAchievement('bossSlayer5');
            if (game.elitesKilled >= 10) unlockAchievement('eliteHunter');
            if (game.critCount >= 50) unlockAchievement('critMaster');

            // Progression achievements
            if (game.player.level >= 5) unlockAchievement('level5');
            if (game.player.level >= 10) unlockAchievement('level10');
            if (game.player.level >= 20) unlockAchievement('level20');
            if (game.currentRoom >= 5) unlockAchievement('room5');
            if (game.currentRoom >= 10) unlockAchievement('room10');
            if (game.currentRoom >= 20) unlockAchievement('room20');

            // Wealth achievements
            if (game.player.gold >= 100) unlockAchievement('gold100');
            if (game.player.gold >= 500) unlockAchievement('gold500');
            if (game.player.gold >= 1000) unlockAchievement('gold1000');

            // Special achievements
            if (game.player.hp < 10 && game.player.hp > 0) unlockAchievement('survivor');
            if (game.secretRoomFound) unlockAchievement('secretFinder');
            if (game.player.inventory.length >= 10) unlockAchievement('fullInventory');
            if (game.comboCount >= 10) unlockAchievement('comboKing');
            if (game.berserkActive) unlockAchievement('berserker');

            // Class achievements
            if (game.currentRoom >= 10 && game.playerClass === 'warrior') unlockAchievement('warriorMaster');
            if (game.currentRoom >= 10 && game.playerClass === 'mage') unlockAchievement('mageMaster');
            if (game.currentRoom >= 10 && game.playerClass === 'rogue') unlockAchievement('rogueMaster');

            // Meta achievements (checked with total stats)
            if (game.totalRuns >= 10) unlockAchievement('runs10');
            if (game.totalRuns >= 50) unlockAchievement('runs50');
            if (game.totalKills >= 100) unlockAchievement('totalKills100');
            if (game.totalKills >= 1000) unlockAchievement('totalKills1000');
            if (game.souls >= 500) unlockAchievement('souls500');

            // Check if all upgrades are maxed
            const allMaxed = Object.keys(permanentUpgradesDef).every(key =>
                game.permanentUpgrades[key] >= permanentUpgradesDef[key].maxLevel
            );
            if (allMaxed) unlockAchievement('allUpgrades');
        }

        // Save achievements to localStorage
        function saveAchievements() {
            localStorage.setItem('dungeonCrawlerAchievements', JSON.stringify(game.achievements));
            savePermanentProgress(); // Also save souls
        }

        // Load achievements from localStorage
        function loadAchievements() {
            const saved = localStorage.getItem('dungeonCrawlerAchievements');
            if (saved) {
                try {
                    game.achievements = JSON.parse(saved);
                } catch (e) {
                    initAchievements();
                }
            } else {
                initAchievements();
            }
        }

        // Draw achievement notifications
        function drawAchievementNotifications() {
            if (!game.achievementNotifications || game.achievementNotifications.length === 0) return;

            for (let i = game.achievementNotifications.length - 1; i >= 0; i--) {
                const notif = game.achievementNotifications[i];
                notif.timer--;

                const y = 100 + i * 60;
                const alpha = Math.min(1, notif.timer / 30);

                ctx.save();
                ctx.globalAlpha = alpha;

                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(canvas.width - 260, y, 250, 50);
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 260, y, 250, 50);

                // Icon - pixel art
                ctx.save();
                ctx.globalAlpha = 1;
                Icons.draw(notif.icon, canvas.width - 238, y + 28, 24);
                ctx.restore();

                // Text with trophy icon
                Icons.draw('trophy', canvas.width - 215, y + 18, 14);
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillStyle = '#fbbf24';
                ctx.textAlign = 'left';
                ctx.fillText(notif.name, canvas.width - 200, y + 22);

                ctx.font = '10px "Courier New"';
                ctx.fillStyle = '#a855f7';
                ctx.fillText(`+${notif.reward} Seelen`, canvas.width - 215, y + 38);

                ctx.restore();

                if (notif.timer <= 0) {
                    game.achievementNotifications.splice(i, 1);
                }
            }
        }

        // Draw achievements menu
        // Achievement categories for organized display
        const achievementCategories = [
            { name: 'Kampf', color: '#ef4444', keys: ['firstBlood', 'slayer10', 'slayer50', 'slayer100', 'bossKiller', 'bossSlayer5', 'eliteHunter', 'critMaster'] },
            { name: 'Fortschritt', color: '#3b82f6', keys: ['level5', 'level10', 'level20', 'room5', 'room10', 'room20'] },
            { name: 'Reichtum', color: '#fbbf24', keys: ['gold100', 'gold500', 'gold1000'] },
            { name: 'Spezial', color: '#a855f7', keys: ['noHit', 'speedRunner', 'survivor', 'secretFinder', 'fullInventory', 'comboKing', 'berserker'] },
            { name: 'Klassen', color: '#22c55e', keys: ['warriorMaster', 'mageMaster', 'rogueMaster'] },
            { name: 'Meta', color: '#f97316', keys: ['runs10', 'runs50', 'totalKills100', 'totalKills1000', 'souls500', 'allUpgrades'] }
        ];

        // Scroll position for achievements menu
        let achievementScrollY = 0;

        function drawAchievementsMenu() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 26px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fbbf24';
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 8;
            ctx.fillText('Erfolge', canvas.width / 2, 32);
            ctx.shadowBlur = 0;

            // Overall progress
            const total = Object.keys(achievementsDef).length;
            const unlocked = Object.values(game.achievements).filter(v => v).length;
            const progressPct = unlocked / total;

            // Progress bar
            const barW = 300, barH = 12, barX = (canvas.width - barW) / 2, barY = 42;
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(barX, barY, barW, barH);
            const progGrad = ctx.createLinearGradient(barX, barY, barX + barW * progressPct, barY);
            progGrad.addColorStop(0, '#fbbf24');
            progGrad.addColorStop(1, '#f59e0b');
            ctx.fillStyle = progGrad;
            ctx.fillRect(barX, barY, barW * progressPct, barH);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
            ctx.font = '10px "Courier New"';
            ctx.fillStyle = '#fff';
            ctx.fillText(`${unlocked}/${total} (${Math.floor(progressPct * 100)}%)`, canvas.width / 2, barY + 10);

            // Total souls earned from achievements
            const totalSoulsFromAch = Object.keys(achievementsDef).reduce((sum, key) => {
                return sum + (game.achievements[key] ? achievementsDef[key].reward : 0);
            }, 0);
            ctx.font = '10px "Courier New"';
            ctx.fillStyle = '#a855f7';
            ctx.fillText(`Seelen aus Erfolgen: ${totalSoulsFromAch}`, canvas.width / 2, barY + 24);

            // Draw categories with scrolling
            let yOffset = 80 + achievementScrollY;
            const cols = 4;
            const cardW = 200, cardH = 52, cardGap = 6;

            for (const cat of achievementCategories) {
                // Category header
                const catUnlocked = cat.keys.filter(k => game.achievements[k]).length;
                const catTotal = cat.keys.length;

                // Category title bar
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(15, yOffset, canvas.width - 30, 22);
                ctx.font = 'bold 12px "Courier New"';
                ctx.textAlign = 'left';
                ctx.fillStyle = cat.color;
                ctx.fillText(`${cat.name}`, 25, yOffset + 15);

                // Category progress
                const catPct = catUnlocked / catTotal;
                const catBarW = 100, catBarX = canvas.width - 140;
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(catBarX, yOffset + 5, catBarW, 10);
                ctx.fillStyle = cat.color;
                ctx.fillRect(catBarX, yOffset + 5, catBarW * catPct, 10);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(catBarX, yOffset + 5, catBarW, 10);
                ctx.font = '9px "Courier New"';
                ctx.fillStyle = '#ccc';
                ctx.textAlign = 'right';
                ctx.fillText(`${catUnlocked}/${catTotal}`, catBarX - 5, yOffset + 14);

                yOffset += 26;

                // Achievement cards in this category
                const totalCatWidth = cols * cardW + (cols - 1) * cardGap;
                const catStartX = (canvas.width - totalCatWidth) / 2;

                for (let i = 0; i < cat.keys.length; i++) {
                    const key = cat.keys[i];
                    const def = achievementsDef[key];
                    if (!def) continue;
                    const isUnlocked = game.achievements[key];

                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const cardX = catStartX + col * (cardW + cardGap);
                    const cardY = yOffset + row * (cardH + cardGap);

                    // Card background
                    if (isUnlocked) {
                        const cardGrad = ctx.createLinearGradient(cardX, cardY, cardX + cardW, cardY);
                        cardGrad.addColorStop(0, '#1a2a1a');
                        cardGrad.addColorStop(1, '#1a2e1a');
                        ctx.fillStyle = cardGrad;
                    } else {
                        ctx.fillStyle = '#111';
                    }
                    ctx.fillRect(cardX, cardY, cardW, cardH);

                    // Left color accent
                    ctx.fillStyle = isUnlocked ? cat.color : '#222';
                    ctx.fillRect(cardX, cardY, 3, cardH);

                    // Border
                    ctx.strokeStyle = isUnlocked ? cat.color + '88' : '#222';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(cardX, cardY, cardW, cardH);

                    // Icon
                    ctx.save();
                    ctx.globalAlpha = isUnlocked ? 1 : 0.2;
                    Icons.draw(def.icon, cardX + 18, cardY + cardH / 2 + 2, 20);
                    ctx.restore();

                    // Name
                    ctx.font = 'bold 10px "Courier New"';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = isUnlocked ? '#fff' : '#555';
                    ctx.fillText(def.name, cardX + 35, cardY + 16);

                    // Description (single line, truncated)
                    ctx.font = '8px "Courier New"';
                    ctx.fillStyle = isUnlocked ? '#aaa' : '#333';
                    let desc = def.description;
                    while (ctx.measureText(desc).width > cardW - 45 && desc.length > 0) {
                        desc = desc.slice(0, -1);
                    }
                    if (desc !== def.description) desc += '..';
                    ctx.fillText(desc, cardX + 35, cardY + 30);

                    // Reward
                    ctx.font = '9px "Courier New"';
                    ctx.fillStyle = isUnlocked ? '#a855f7' : '#2a2a2a';
                    ctx.fillText(`+${def.reward}`, cardX + 35, cardY + 44);
                    ctx.save();
                    ctx.globalAlpha = isUnlocked ? 0.8 : 0.15;
                    Icons.draw('soul', cardX + 65, cardY + 42, 10);
                    ctx.restore();

                    // Checkmark for unlocked
                    if (isUnlocked) {
                        ctx.font = 'bold 14px "Courier New"';
                        ctx.fillStyle = '#22c55e';
                        ctx.textAlign = 'right';
                        ctx.fillText('\u2713', cardX + cardW - 8, cardY + 18);
                    }
                }

                const catRows = Math.ceil(cat.keys.length / cols);
                yOffset += catRows * (cardH + cardGap) + 8;
            }

            // Instructions
            ctx.font = '11px "Courier New"';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('[ESC] oder [A] zum Schließen', canvas.width / 2, canvas.height - 10);
        }

        // ==================== DAILY CHALLENGES SYSTEM ====================
        const dailyChallengeTypes = [
            {
                id: 'speedster',
                name: 'Geschwindigkeits-Dämon',
                description: 'Erreiche Etage 5 in unter 4 Minuten',
                icon: 'lightning',
                check: () => game.currentRoom >= 5 && ((Date.now() - game.gameStartTime) / 1000 / 60) < 4,
                reward: 100
            },
            {
                id: 'pacifist',
                name: 'Pazifist',
                description: 'Schließe Etage 3 ab, ohne Schaden zu nehmen',
                icon: 'peace',
                modifier: { noDamageTaken: true, targetRoom: 3 },
                check: () => game.currentRoom >= 3 && game.damageTakenTotal === 0,
                reward: 150
            },
            {
                id: 'berserker',
                name: 'Berserker',
                description: 'Töte 30 Monster im Berserker-Modus',
                icon: 'fire',
                check: () => game.berserkKills >= 30,
                reward: 80
            },
            {
                id: 'combo',
                name: 'Kombo-Meister',
                description: 'Erreiche eine 15er Kombo',
                icon: 'sparkle',
                check: () => game.maxComboReached >= 15,
                reward: 75
            },
            {
                id: 'gold',
                name: 'Goldgräber',
                description: 'Sammle 500 Gold in einem Run',
                icon: 'gold',
                check: () => game.player.gold >= 500,
                reward: 60
            },
            {
                id: 'boss',
                name: 'Boss-Jäger',
                description: 'Besiege 2 Bosse in einem Run',
                icon: 'demon',
                check: () => game.bossesKilled >= 2,
                reward: 120
            },
            {
                id: 'elite',
                name: 'Elite-Vernichter',
                description: 'Besiege 5 Elite-Monster',
                icon: 'star',
                check: () => game.elitesKilled >= 5,
                reward: 90
            },
            {
                id: 'skill',
                name: 'Magie-Meister',
                description: 'Benutze 20 Skills',
                icon: 'mana',
                check: () => game.skillsUsed >= 20,
                reward: 70
            },
            {
                id: 'crit',
                name: 'Präzisions-Killer',
                description: 'Lande 25 kritische Treffer',
                icon: 'target',
                check: () => game.critCount >= 25,
                reward: 65
            },
            {
                id: 'survivor',
                name: 'Überlebenskünstler',
                description: 'Überlebe 10 Mal unter 20% HP',
                icon: 'heart',
                check: () => game.lowHpSurvives >= 10,
                reward: 85
            }
        ];

        // Get today's date as seed
        function getDailySeed() {
            const now = new Date();
            return `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}`;
        }

        // Simple seeded random
        function seededRandom(seed) {
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // Get today's daily challenges (3 challenges per day)
        function getDailyChallenges() {
            const seed = getDailySeed();
            const random = seededRandom(seed);
            const challenges = [];

            // Pick 3 unique challenges based on seed
            const shuffled = [...dailyChallengeTypes];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = (random + i * 31) % (i + 1);
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled.slice(0, 3);
        }

        // Initialize daily challenge tracking
        function initDailyChallenges() {
            const today = getDailySeed();
            const saved = localStorage.getItem('dungeonCrawlerDaily');

            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.date === today) {
                        game.dailyChallengesCompleted = data.completed || [];
                        return;
                    }
                } catch (e) {}
            }

            // New day - reset challenges
            game.dailyChallengesCompleted = [];
            saveDailyChallenges();
        }

        // Save daily challenge progress
        function saveDailyChallenges() {
            const data = {
                date: getDailySeed(),
                completed: game.dailyChallengesCompleted
            };
            localStorage.setItem('dungeonCrawlerDaily', JSON.stringify(data));
        }

        // Check daily challenges
        function checkDailyChallenges() {
            const challenges = getDailyChallenges();

            for (const challenge of challenges) {
                if (game.dailyChallengesCompleted.includes(challenge.id)) continue;

                if (challenge.check()) {
                    game.dailyChallengesCompleted.push(challenge.id);
                    game.souls += challenge.reward;

                    // Show notification
                    game.achievementNotifications.push({
                        name: challenge.name,
                        icon: challenge.icon,
                        reward: challenge.reward,
                        timer: 240 // 4 seconds
                    });

                    saveDailyChallenges();
                    savePermanentProgress();
                    sfx.levelUp();
                    addLog(`[TÄGLICH] ${challenge.name} abgeschlossen! +${challenge.reward} Seelen`, 'legendary');
                }
            }
        }

        // Draw daily challenges panel (shown on class selection)
        function drawDailyChallengesPanel() {
            const challenges = getDailyChallenges();
            const panelX = 10;
            const panelY = 390;
            const panelWidth = 280;
            const panelHeight = 150;

            // Background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title with clock icon
            Icons.draw('clock', panelX + 18, panelY + 16, 14);
            ctx.font = 'bold 14px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText('Tägliche Herausforderungen', panelX + 32, panelY + 20);

            // Challenges
            for (let i = 0; i < challenges.length; i++) {
                const challenge = challenges[i];
                const isCompleted = game.dailyChallengesCompleted.includes(challenge.id);
                const y = panelY + 45 + i * 35;

                // Icon - pixel art
                if (isCompleted) {
                    // Draw checkmark for completed
                    ctx.save();
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(panelX + 20, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(panelX + 15, y);
                    ctx.lineTo(panelX + 18, y + 3);
                    ctx.lineTo(panelX + 25, y - 4);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    Icons.draw(challenge.icon, panelX + 20, y, 16);
                }

                // Name
                ctx.font = isCompleted ? 'bold 10px "Courier New"' : '10px "Courier New"';
                ctx.fillStyle = isCompleted ? '#22c55e' : '#fff';
                ctx.fillText(challenge.name, panelX + 40, y - 5);

                // Description
                ctx.font = '9px "Courier New"';
                ctx.fillStyle = isCompleted ? '#22c55e' : '#888';
                ctx.fillText(challenge.description, panelX + 40, y + 8);

                // Reward with soul icon
                ctx.fillStyle = isCompleted ? '#22c55e' : '#a855f7';
                ctx.fillText(`+${challenge.reward}`, panelX + 40, y + 20);
                Icons.draw('soul', panelX + 78, y + 18, 10);
            }
        }

        // ==================== ENVIRONMENT THEMES ====================
        const environmentThemes = {
            dungeon: {
                name: 'Kerker',
                floorColor: '#2a2a2a',
                floorAccent: '#333333',
                wallColor: '#4a4a4a',
                wallAccent: '#555555',
                doorColor: '#8b4513',
                ambientColor: 'rgba(50, 50, 80, 0.1)',
                fogColor: 'rgba(0, 0, 0, 0.3)',
                minRoom: 1,
                maxRoom: 5
            },
            catacombs: {
                name: 'Katakomben',
                floorColor: '#3a3530',
                floorAccent: '#4a4540',
                wallColor: '#5a5550',
                wallAccent: '#6a6560',
                doorColor: '#6b4423',
                ambientColor: 'rgba(80, 60, 40, 0.15)',
                fogColor: 'rgba(30, 20, 10, 0.2)',
                minRoom: 6,
                maxRoom: 10
            },
            ice: {
                name: 'Eishöhle',
                floorColor: '#3a4a5a',
                floorAccent: '#4a5a6a',
                wallColor: '#5a7a9a',
                wallAccent: '#6a8aaa',
                doorColor: '#4a6080',
                ambientColor: 'rgba(100, 150, 200, 0.15)',
                fogColor: 'rgba(200, 220, 255, 0.1)',
                minRoom: 11,
                maxRoom: 15
            },
            lava: {
                name: 'Lavahöhle',
                floorColor: '#3a2020',
                floorAccent: '#4a2828',
                wallColor: '#5a3030',
                wallAccent: '#6a4040',
                doorColor: '#8b2020',
                ambientColor: 'rgba(255, 100, 50, 0.1)',
                fogColor: 'rgba(100, 20, 0, 0.15)',
                minRoom: 16,
                maxRoom: 20
            },
            abyss: {
                name: 'Abgrund',
                floorColor: '#1a1a2a',
                floorAccent: '#2a2a3a',
                wallColor: '#3a3a5a',
                wallAccent: '#4a4a6a',
                doorColor: '#5a3a7a',
                ambientColor: 'rgba(100, 50, 150, 0.15)',
                fogColor: 'rgba(20, 0, 40, 0.25)',
                minRoom: 21,
                maxRoom: 999
            }
        };

        function getCurrentTheme() {
            const room = game.currentRoom;
            for (const key in environmentThemes) {
                const theme = environmentThemes[key];
                if (room >= theme.minRoom && room <= theme.maxRoom) {
                    return theme;
                }
            }
            return environmentThemes.dungeon;
        }

        // ==================== BESTIARY SYSTEM ====================
        const bestiaryData = {
            goblin: { name: 'Goblin', icon: 'goblin', description: 'Kleine, hinterhältige Kreaturen', weakness: 'Langsam', strength: 'Schnelle Angriffe' },
            skeleton: { name: 'Skelett', icon: 'skull', description: 'Untote Krieger aus alten Zeiten', weakness: 'Heilige Magie', strength: 'Kann sich wieder zusammensetzen' },
            orc: { name: 'Ork', icon: 'orc', description: 'Brutale Krieger mit roher Gewalt', weakness: 'Langsam', strength: 'Hoher Schaden' },
            mage: { name: 'Magier', icon: 'wizard', description: 'Dunkle Zauberer des Dungeons', weakness: 'Nah-Kampf', strength: 'Fernkampf-Magie' },
            demon: { name: 'Dämon', icon: 'demon', description: 'Kreaturen aus der Unterwelt', weakness: 'Heilige Waffen', strength: 'Feuer-Resistenz' },
            boss: { name: 'Boss', icon: 'boss', description: 'Mächtige Wächter des Dungeons', weakness: 'Phasen-Schwächen', strength: 'Mehrere Phasen' }
        };

        function initBestiary() {
            const saved = localStorage.getItem('dungeonCrawlerBestiary');
            if (saved) {
                try {
                    game.bestiary = JSON.parse(saved);
                } catch (e) {
                    game.bestiary = {};
                }
            } else {
                game.bestiary = {};
            }
            game.showBestiary = false;
        }

        function saveBestiary() {
            localStorage.setItem('dungeonCrawlerBestiary', JSON.stringify(game.bestiary));
        }

        function recordMonsterEncounter(monsterType) {
            if (!game.bestiary[monsterType]) {
                game.bestiary[monsterType] = { encountered: 0, killed: 0 };
            }
            game.bestiary[monsterType].encountered++;
            saveBestiary();
        }

        function recordMonsterKill(monsterType) {
            if (!game.bestiary[monsterType]) {
                game.bestiary[monsterType] = { encountered: 0, killed: 0 };
            }
            game.bestiary[monsterType].killed++;
            saveBestiary();
        }

        function drawBestiaryMenu() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('Bestiarum', canvas.width / 2, 45);

            // Monster cards
            const types = Object.keys(bestiaryData);
            const cols = 3;
            const cardWidth = 250;
            const cardHeight = 150;
            const cardGap = 20;
            const totalWidth = cols * cardWidth + (cols - 1) * cardGap;
            const startX = (canvas.width - totalWidth) / 2;
            const startY = 80;

            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                const data = bestiaryData[type];
                const stats = game.bestiary[type] || { encountered: 0, killed: 0 };
                const isDiscovered = stats.encountered > 0;

                const col = i % cols;
                const row = Math.floor(i / cols);
                const cardX = startX + col * (cardWidth + cardGap);
                const cardY = startY + row * (cardHeight + cardGap);

                // Card background
                ctx.fillStyle = isDiscovered ? '#1a2a1a' : '#1a1a1a';
                ctx.fillRect(cardX, cardY, cardWidth, cardHeight);

                // Border
                ctx.strokeStyle = isDiscovered ? '#22c55e' : '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(cardX, cardY, cardWidth, cardHeight);

                // Icon - pixel art
                ctx.save();
                ctx.globalAlpha = isDiscovered ? 1 : 0.2;
                Icons.draw(data.icon, cardX + 40, cardY + 42, 36);
                ctx.restore();

                if (isDiscovered) {
                    // Name
                    ctx.font = 'bold 14px "Courier New"';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(data.name, cardX + 75, cardY + 30);

                    // Description
                    ctx.font = '10px "Courier New"';
                    ctx.fillStyle = '#888';
                    ctx.fillText(data.description, cardX + 75, cardY + 48);

                    // Stats
                    ctx.fillStyle = '#22c55e';
                    ctx.fillText(`Getötet: ${stats.killed}`, cardX + 75, cardY + 70);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillText(`Begegnet: ${stats.encountered}`, cardX + 75, cardY + 85);

                    // Weakness/Strength
                    ctx.font = '9px "Courier New"';
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText(`Schwäche: ${data.weakness}`, cardX + 10, cardY + 110);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillText(`Stärke: ${data.strength}`, cardX + 10, cardY + 125);
                } else {
                    // Unknown
                    ctx.font = 'bold 14px "Courier New"';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#444';
                    ctx.fillText('???', cardX + 75, cardY + 30);
                    ctx.font = '10px "Courier New"';
                    ctx.fillText('Noch nicht entdeckt', cardX + 75, cardY + 48);
                }
            }

            // Instructions
            ctx.font = '12px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('[ESC] oder [B] zum Schließen', canvas.width / 2, canvas.height - 20);
        }

        // ==================== KEY REBINDING SYSTEM ====================
        const defaultKeyBindings = {
            moveUp: 'w',
            moveDown: 's',
            moveLeft: 'a',
            moveRight: 'd',
            attack: ' ',
            interact: 'e',
            drop: 'x',
            skill1: 'q',
            skill2: 'r',
            skill3: 'f',
            skill4: 'c',
            dash: 'Shift'
        };

        function initKeyBindings() {
            const saved = localStorage.getItem('dungeonCrawlerKeys');
            if (saved) {
                try {
                    game.keyBindings = { ...defaultKeyBindings, ...JSON.parse(saved) };
                } catch (e) {
                    game.keyBindings = { ...defaultKeyBindings };
                }
            } else {
                game.keyBindings = { ...defaultKeyBindings };
            }
            game.showKeyBindings = false;
            game.rebindingKey = null;
        }

        function saveKeyBindings() {
            localStorage.setItem('dungeonCrawlerKeys', JSON.stringify(game.keyBindings));
        }

        function getKeyName(key) {
            if (key === ' ') return 'SPACE';
            if (key === 'Shift') return 'SHIFT';
            return key.toUpperCase();
        }

        function drawKeyBindingsMenu() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#60a5fa';
            ctx.fillText('Tastenbelegung', canvas.width / 2, 45);

            const bindings = [
                { key: 'moveUp', label: 'Nach oben' },
                { key: 'moveDown', label: 'Nach unten' },
                { key: 'moveLeft', label: 'Nach links' },
                { key: 'moveRight', label: 'Nach rechts' },
                { key: 'attack', label: 'Angriff' },
                { key: 'interact', label: 'Interaktion' },
                { key: 'drop', label: 'Ablegen' },
                { key: 'skill1', label: 'Skill 1 (Feuerball)' },
                { key: 'skill2', label: 'Skill 2 (Heilung)' },
                { key: 'skill3', label: 'Skill 3 (Schild)' },
                { key: 'skill4', label: 'Skill 4 (Wirbelwind)' },
                { key: 'dash', label: 'Dash' }
            ];

            const cols = 2;
            const startX = canvas.width / 2 - 350;
            const startY = 90;
            const rowHeight = 40;

            for (let i = 0; i < bindings.length; i++) {
                const binding = bindings[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = startX + col * 350;
                const y = startY + row * rowHeight;

                const isRebinding = game.rebindingKey === binding.key;

                // Label
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#888';
                ctx.fillText(binding.label, x, y);

                // Key box
                const keyBoxX = x + 200;
                ctx.fillStyle = isRebinding ? '#3b82f6' : '#2a2a3a';
                ctx.fillRect(keyBoxX, y - 15, 80, 25);
                ctx.strokeStyle = isRebinding ? '#60a5fa' : '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(keyBoxX, y - 15, 80, 25);

                // Key text
                ctx.font = 'bold 12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillStyle = isRebinding ? '#fff' : '#60a5fa';
                ctx.fillText(isRebinding ? '...' : getKeyName(game.keyBindings[binding.key]), keyBoxX + 40, y);

                // Number hint
                ctx.font = '10px "Courier New"';
                ctx.fillStyle = '#555';
                ctx.textAlign = 'left';
                ctx.fillText(`[${i + 1}]`, x - 30, y);
            }

            // Instructions
            ctx.font = '12px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText(game.rebindingKey ?
                'Drücke eine Taste zum Binden (ESC zum Abbrechen)' :
                'Drücke 1-12 zum Ändern | [R] Reset | [ESC]/[K] Schließen',
                canvas.width / 2, canvas.height - 40);

            // Reset button hint
            ctx.fillStyle = '#ef4444';
            ctx.fillText('(R = Zurücksetzen auf Standard)', canvas.width / 2, canvas.height - 20);
        }

        // ==================== CHARACTER CUSTOMIZATION ====================
        const characterColors = {
            skin: ['#f5d0c5', '#d4a574', '#8d5524', '#c68642', '#e0ac69', '#ffdbac'],
            hair: ['#2c1810', '#4a3728', '#8b4513', '#ffd700', '#ff4500', '#800080', '#ffffff', '#1e90ff'],
            outfit: ['#3b82f6', '#ef4444', '#22c55e', '#8b5cf6', '#f59e0b', '#06b6d4', '#ec4899', '#6b7280']
        };

        function initCharacterCustomization() {
            const saved = localStorage.getItem('dungeonCrawlerCustom');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    game.customization = data;
                } catch (e) {
                    game.customization = { skin: 0, hair: 0, outfit: 0 };
                }
            } else {
                game.customization = { skin: 0, hair: 0, outfit: 0 };
            }
        }

        function saveCharacterCustomization() {
            localStorage.setItem('dungeonCrawlerCustom', JSON.stringify(game.customization));
        }

        function getPlayerColors() {
            const c = game.customization || { skin: 0, hair: 0, outfit: 0 };
            return {
                skin: characterColors.skin[c.skin] || characterColors.skin[0],
                hair: characterColors.hair[c.hair] || characterColors.hair[0],
                outfit: characterColors.outfit[c.outfit] || characterColors.outfit[0]
            };
        }

        // Draw customization panel on class selection
        function drawCustomizationPanel() {
            const panelX = canvas.width - 290;
            const panelY = 390;
            const panelWidth = 280;
            const panelHeight = 150;

            // Background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
            ctx.strokeStyle = '#ec4899';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title
            ctx.font = 'bold 14px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ec4899';
            ctx.fillText('🎨 Charakter-Anpassung', panelX + 10, panelY + 20);

            const c = game.customization || { skin: 0, hair: 0, outfit: 0 };

            // Draw preview character
            const previewX = panelX + 50;
            const previewY = panelY + 85;
            const colors = getPlayerColors();

            // Body
            ctx.fillStyle = colors.outfit;
            ctx.fillRect(previewX - 12, previewY - 5, 24, 30);

            // Head
            ctx.fillStyle = colors.skin;
            ctx.beginPath();
            ctx.arc(previewX, previewY - 15, 12, 0, Math.PI * 2);
            ctx.fill();

            // Hair
            ctx.fillStyle = colors.hair;
            ctx.beginPath();
            ctx.arc(previewX, previewY - 20, 10, Math.PI, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(previewX - 5, previewY - 17, 3, 3);
            ctx.fillRect(previewX + 2, previewY - 17, 3, 3);

            // Color selectors
            const categories = [
                { name: 'Haut [Z]', key: 'skin', colors: characterColors.skin },
                { name: 'Haar [X]', key: 'hair', colors: characterColors.hair },
                { name: 'Outfit [C]', key: 'outfit', colors: characterColors.outfit }
            ];

            for (let i = 0; i < categories.length; i++) {
                const cat = categories[i];
                const y = panelY + 45 + i * 35;

                ctx.font = '10px "Courier New"';
                ctx.fillStyle = '#888';
                ctx.fillText(cat.name, panelX + 90, y);

                // Color swatches
                for (let j = 0; j < cat.colors.length; j++) {
                    const swatchX = panelX + 90 + j * 22;
                    const swatchY = y + 5;

                    ctx.fillStyle = cat.colors[j];
                    ctx.fillRect(swatchX, swatchY, 18, 18);

                    // Selected border
                    if (c[cat.key] === j) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(swatchX - 1, swatchY - 1, 20, 20);
                    }
                }
            }

            ctx.font = '9px "Courier New"';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('Drücke Z/X/C um Farben zu wechseln', panelX + panelWidth / 2, panelY + panelHeight - 8);
        }

        // Monster Templates with unique designs and attack types
        // Monster weapon pool (weapons monsters can spawn with)
        const monsterWeapons = {
            goblin: [
                { name: 'Goblin-Dolch', attack: 6, type: 'weapon', style: 'dagger', range: 50, speed: 0.7 },
                { name: 'Rostiger Dolch', attack: 4, type: 'weapon', style: 'dagger', range: 50, speed: 0.8 },
                null  // 33% chance no weapon (uses fists)
            ],
            skeleton: [
                { name: 'Knochenschwert', attack: 8, type: 'weapon', style: 'bone', range: 80 },
                { name: 'Rostiges Schwert', attack: 5, type: 'weapon', style: 'rusty_sword', range: 80 },
                { name: 'Alter Speer', attack: 7, type: 'weapon', style: 'spear', range: 110 }
            ],
            orc: [
                { name: 'Ork-Axt', attack: 14, type: 'weapon', style: 'axe', range: 70, speed: 1.3 },
                { name: 'Kriegshammer', attack: 16, type: 'weapon', style: 'hammer', range: 65, speed: 1.5 },
                { name: 'Grobe Keule', attack: 12, type: 'weapon', style: 'hammer', range: 60, speed: 1.4 }
            ],
            mage: [
                { name: 'Magierstab', attack: 14, type: 'weapon', style: 'staff', range: 100 }
            ],
            demon: [
                { name: 'Dämonenklaue', attack: 22, type: 'weapon', style: 'claw', range: 60, speed: 0.8 },
                { name: 'Höllenschwert', attack: 20, type: 'weapon', style: 'flame', range: 85 }
            ]
        };

        // Monster armor pool
        const monsterArmors = {
            goblin: [
                null, null,  // 66% chance no armor
                { name: 'Lumpige Rüstung', defense: 2, type: 'armor', style: 'leather' }
            ],
            skeleton: [
                null,  // 33% chance no armor
                { name: 'Verrostete Kettenrüstung', defense: 4, type: 'armor', style: 'chain' },
                { name: 'Knochenrüstung', defense: 3, type: 'armor', style: 'leather' }
            ],
            orc: [
                { name: 'Ork-Lederrüstung', defense: 5, type: 'armor', style: 'leather' },
                { name: 'Ork-Kettenhemd', defense: 7, type: 'armor', style: 'chain' },
                { name: 'Schwere Ork-Rüstung', defense: 10, type: 'armor', style: 'plate' }
            ],
            mage: [
                { name: 'Magierrobe', defense: 2, type: 'armor', style: 'leather' },
                null  // 50% chance no armor
            ],
            demon: [
                { name: 'Dämonenhaut', defense: 8, type: 'armor', style: 'dragon' },
                { name: 'Höllenpanzer', defense: 12, type: 'armor', style: 'plate' }
            ]
        };

        // Elite Monster weapon pools (bessere Waffen als normale Monster)
        const eliteMonsterWeapons = {
            goblin: [
                { name: 'Elite-Goblinklinge', attack: 18, type: 'weapon', style: 'sword', range: 75, speed: 0.8, tier: 'rare' },
                { name: 'Vergifteter Dolch', attack: 15, type: 'weapon', style: 'dagger', range: 55, speed: 0.6, tier: 'rare' },
                { name: 'Goblin-Assassinenklinge', attack: 22, type: 'weapon', style: 'dagger', range: 60, speed: 0.7, tier: 'epic' }
            ],
            skeleton: [
                { name: 'Verfluchtes Schwert', attack: 20, type: 'weapon', style: 'bone', range: 85, tier: 'rare' },
                { name: 'Seelenschneider', attack: 25, type: 'weapon', style: 'sword', range: 90, tier: 'epic' },
                { name: 'Knochensense', attack: 28, type: 'weapon', style: 'battleaxe', range: 95, speed: 1.3, tier: 'epic' }
            ],
            orc: [
                { name: 'Ork-Kriegsaxt', attack: 30, type: 'weapon', style: 'battleaxe', range: 80, speed: 1.4, tier: 'rare' },
                { name: 'Berserker-Hammer', attack: 35, type: 'weapon', style: 'hammer', range: 75, speed: 1.5, tier: 'epic' },
                { name: 'Blutdurst', attack: 38, type: 'weapon', style: 'battleaxe', range: 85, speed: 1.3, tier: 'legendary' }
            ],
            mage: [
                { name: 'Erzmagier-Stab', attack: 28, type: 'weapon', style: 'staff', range: 110, tier: 'rare' },
                { name: 'Stab der Verdammnis', attack: 32, type: 'weapon', style: 'fire_staff', range: 115, tier: 'epic' },
                { name: 'Seelenstab', attack: 36, type: 'weapon', style: 'staff', range: 120, tier: 'legendary' }
            ],
            demon: [
                { name: 'Höllenfürst-Klaue', attack: 35, type: 'weapon', style: 'claw', range: 70, speed: 0.7, tier: 'rare' },
                { name: 'Dämonenschwert', attack: 40, type: 'weapon', style: 'flame', range: 90, tier: 'epic' },
                { name: 'Verderbnis', attack: 45, type: 'weapon', style: 'flame', range: 95, tier: 'legendary' }
            ]
        };

        // Elite Monster armor pools (bessere Rüstungen)
        const eliteMonsterArmors = {
            goblin: [
                { name: 'Elite-Goblinrüstung', defense: 8, type: 'armor', style: 'leather', tier: 'rare' },
                { name: 'Schatten-Leder', defense: 10, type: 'armor', style: 'leather', tier: 'epic' }
            ],
            skeleton: [
                { name: 'Verfluchte Rüstung', defense: 12, type: 'armor', style: 'chain', tier: 'rare' },
                { name: 'Totenknochen-Panzer', defense: 15, type: 'armor', style: 'plate', tier: 'epic' }
            ],
            orc: [
                { name: 'Ork-Kriegsrüstung', defense: 14, type: 'armor', style: 'plate', tier: 'rare' },
                { name: 'Berserker-Rüstung', defense: 18, type: 'armor', style: 'plate', tier: 'epic' }
            ],
            mage: [
                { name: 'Erzmagier-Robe', defense: 6, type: 'armor', style: 'leather', tier: 'rare' },
                { name: 'Robe der Macht', defense: 8, type: 'armor', style: 'leather', tier: 'epic' }
            ],
            demon: [
                { name: 'Dämonenlord-Panzer', defense: 18, type: 'armor', style: 'dragon', tier: 'rare' },
                { name: 'Höllenfürst-Rüstung', defense: 24, type: 'armor', style: 'plate', tier: 'legendary' }
            ]
        };

        const monsterTypes = [
            {
                name: 'Goblin',
                color: '#4ade80',
                colorDark: '#22c55e',
                hp: 30,
                baseAttack: 4,  // Base attack without weapon
                baseDefense: 1,  // Base defense without armor
                xp: 25,
                gold: 12,
                speed: 1.5,
                attackType: 'melee',
                style: 'goblin',
                // Special ability: Can steal gold from player on hit
                specialAbility: 'steal',
                stealChance: 0.3,
                stealAmount: 5
            },
            {
                name: 'Skeleton',
                color: '#e2e8f0',
                colorDark: '#94a3b8',
                hp: 40,
                baseAttack: 5,
                baseDefense: 1,
                xp: 35,
                gold: 18,
                speed: 1.2,
                attackType: 'melee',
                style: 'skeleton',
                // Special ability: Can reassemble after death (30% chance)
                specialAbility: 'reassemble',
                reassembleChance: 0.3,
                reassembleHp: 0.5  // Comes back with 50% HP
            },
            {
                name: 'Orc',
                color: '#4ade80',
                colorDark: '#166534',
                hp: 45,
                baseAttack: 6,
                baseDefense: 2,
                xp: 50,
                gold: 30,
                speed: 1,
                attackType: 'melee',
                style: 'orc',
                // Special ability: Enrage when below 30% HP
                specialAbility: 'enrage',
                enrageThreshold: 0.3,
                enrageAttackBonus: 1.5,
                enrageSpeedBonus: 1.3
            },
            {
                name: 'Dark Mage',
                color: '#a78bfa',
                colorDark: '#7c3aed',
                hp: 50,
                baseAttack: 8,
                baseDefense: 1,
                xp: 60,
                gold: 35,
                speed: 0.8,
                attackType: 'ranged',
                projectileColor: '#c084fc',
                projectileSpeed: 4,
                attackRange: 250,
                attackCooldown: 120,
                style: 'mage'
            },
            {
                name: 'Demon',
                color: '#ef4444',
                colorDark: '#b91c1c',
                hp: 80,
                baseAttack: 10,
                baseDefense: 4,
                xp: 100,
                gold: 60,
                speed: 1.3,
                attackType: 'melee',
                style: 'demon',
                minLevel: 7
            },
            // Hybrid Monsters (erscheinen ab Level 15) - können melee und ranged angreifen
            {
                name: 'Hexenmeister',
                color: '#6b21a8',
                colorDark: '#581c87',
                hp: 70,
                baseAttack: 7,
                baseDefense: 2,
                xp: 85,
                gold: 50,
                speed: 1.0,
                attackType: 'hybrid',
                projectileColor: '#a855f7',
                projectileSpeed: 5,
                attackRange: 200,
                attackCooldown: 90,
                meleeRange: 50,
                style: 'mage',
                minLevel: 15
            },
            {
                name: 'Bandit-Hauptmann',
                color: '#78350f',
                colorDark: '#451a03',
                hp: 65,
                baseAttack: 9,
                baseDefense: 3,
                xp: 75,
                gold: 55,
                speed: 1.4,
                attackType: 'hybrid',
                projectileColor: '#a3a3a3',
                projectileSpeed: 7,
                attackRange: 150,
                attackCooldown: 100,
                meleeRange: 60,
                style: 'skeleton',
                minLevel: 15
            },
            {
                name: 'Feuer-Elementar',
                color: '#f97316',
                colorDark: '#ea580c',
                hp: 90,
                baseAttack: 12,
                baseDefense: 5,
                xp: 120,
                gold: 70,
                speed: 1.1,
                attackType: 'hybrid',
                projectileColor: '#ef4444',
                projectileSpeed: 4,
                attackRange: 180,
                attackCooldown: 80,
                meleeRange: 55,
                style: 'demon',
                minLevel: 20
            },
            {
                name: 'Eis-Golem',
                color: '#22d3ee',
                colorDark: '#0891b2',
                hp: 150,
                baseAttack: 14,
                baseDefense: 8,
                xp: 140,
                gold: 80,
                speed: 0.7,
                attackType: 'hybrid',
                projectileColor: '#67e8f9',
                projectileSpeed: 5,
                attackRange: 160,
                attackCooldown: 110,
                meleeRange: 60,
                style: 'orc',
                minLevel: 20
            },
            {
                name: 'Schattenläufer',
                color: '#1e1b4b',
                colorDark: '#0f0d24',
                hp: 55,
                baseAttack: 11,
                baseDefense: 2,
                xp: 100,
                gold: 65,
                speed: 2.0,
                attackType: 'hybrid',
                projectileColor: '#4c1d95',
                projectileSpeed: 8,
                attackRange: 170,
                attackCooldown: 70,
                meleeRange: 45,
                style: 'demon',
                minLevel: 18
            },
            {
                name: 'Drachenwelpe',
                color: '#dc2626',
                colorDark: '#991b1b',
                hp: 120,
                baseAttack: 15,
                baseDefense: 6,
                xp: 160,
                gold: 100,
                speed: 1.2,
                attackType: 'hybrid',
                projectileColor: '#f97316',
                projectileSpeed: 6,
                attackRange: 200,
                attackCooldown: 100,
                meleeRange: 65,
                style: 'demon',
                minLevel: 25
            }
        ];

        // Item Templates
        // tier: 'common' (grau), 'uncommon' (grün), 'rare' (blau, ab lvl 10), 'legendary' (orange, ab lvl 10)
        const itemTypes = {
            weapons: [
                // Swords - Common/Uncommon
                { name: 'Rostiges Schwert', attack: 5, type: 'weapon', rarity: 0.35, style: 'rusty_sword', range: 80, tier: 'common' },
                { name: 'Eisenschwert', attack: 10, type: 'weapon', rarity: 0.28, style: 'iron_sword', range: 80, tier: 'common' },
                { name: 'Stahlschwert', attack: 15, type: 'weapon', rarity: 0.15, style: 'steel_sword', range: 85, tier: 'uncommon' },
                { name: 'Silberschwert', attack: 18, type: 'weapon', rarity: 0.08, style: 'silver_sword', range: 85, tier: 'rare', minLevel: 8 },
                { name: 'Breitschwert', attack: 22, type: 'weapon', rarity: 0.05, style: 'broadsword', range: 90, speed: 1.2, tier: 'rare', minLevel: 12 },
                // Swords - Rare/Legendary (ab Level 10)
                { name: 'Flammschwert', attack: 25, type: 'weapon', rarity: 0.04, style: 'flame', range: 90, tier: 'legendary', minLevel: 10, statusEffect: { type: 'burn', damage: 3, duration: 120, chance: 0.25 } },
                { name: 'Frostschwert', attack: 23, type: 'weapon', rarity: 0.04, style: 'frost_sword', range: 90, tier: 'legendary', minLevel: 10, statusEffect: { type: 'freeze', damage: 0, duration: 90, chance: 0.2 } },
                { name: 'Blitzschwert', attack: 28, type: 'weapon', rarity: 0.03, style: 'lightning_sword', range: 95, speed: 0.8, tier: 'legendary', minLevel: 15 },
                { name: 'Seelenschneider', attack: 35, type: 'weapon', rarity: 0.02, style: 'soul_sword', range: 100, tier: 'legendary', minLevel: 20, lifeSteal: 0.15 },
                // Daggers (fast, short range, high crit)
                { name: 'Dolch', attack: 4, type: 'weapon', rarity: 0.22, style: 'dagger', range: 50, speed: 0.7, tier: 'common', critBonus: 0.10 },
                { name: 'Giftdolch', attack: 8, type: 'weapon', rarity: 0.08, style: 'poison_dagger', range: 50, speed: 0.6, tier: 'uncommon', critBonus: 0.15, statusEffect: { type: 'poison', damage: 2, duration: 180, chance: 0.3 } },
                { name: 'Schattendolch', attack: 12, type: 'weapon', rarity: 0.04, style: 'shadow_dagger', range: 55, speed: 0.5, tier: 'rare', minLevel: 10, critBonus: 0.25 },
                { name: 'Assassinenklinge', attack: 18, type: 'weapon', rarity: 0.025, style: 'assassin_blade', range: 55, speed: 0.4, tier: 'legendary', minLevel: 15, critBonus: 0.35 },
                // Axes (slow, high damage)
                { name: 'Handaxt', attack: 12, type: 'weapon', rarity: 0.12, style: 'axe', range: 70, speed: 1.3, tier: 'common' },
                { name: 'Kriegsaxt', attack: 20, type: 'weapon', rarity: 0.05, style: 'battleaxe', range: 75, speed: 1.5, tier: 'rare', minLevel: 10 },
                { name: 'Henkeraxt', attack: 28, type: 'weapon', rarity: 0.03, style: 'executioner_axe', range: 80, speed: 1.7, tier: 'legendary', minLevel: 15 },
                { name: 'Zweihandaxt', attack: 35, type: 'weapon', rarity: 0.02, style: 'greataxe', range: 85, speed: 2.0, tier: 'legendary', minLevel: 20 },
                // Hammers (very slow, very high damage)
                { name: 'Kriegshammer', attack: 18, type: 'weapon', rarity: 0.06, style: 'hammer', range: 65, speed: 1.6, tier: 'uncommon' },
                { name: 'Titanenhammer', attack: 30, type: 'weapon', rarity: 0.025, style: 'titan_hammer', range: 70, speed: 1.9, tier: 'legendary', minLevel: 15 },
                { name: 'Donnerhammer', attack: 38, type: 'weapon', rarity: 0.015, style: 'thunder_hammer', range: 75, speed: 2.0, tier: 'legendary', minLevel: 20, statusEffect: { type: 'stun', damage: 0, duration: 60, chance: 0.2 } },
                // Spears (long range)
                { name: 'Speer', attack: 9, type: 'weapon', rarity: 0.10, style: 'spear', range: 110, tier: 'common' },
                { name: 'Hellebarde', attack: 16, type: 'weapon', rarity: 0.04, style: 'halberd', range: 120, speed: 1.4, tier: 'rare', minLevel: 10 },
                { name: 'Drachen-Lanze', attack: 26, type: 'weapon', rarity: 0.02, style: 'dragon_lance', range: 130, speed: 1.3, tier: 'legendary', minLevel: 15 },
                // Maces/Flails
                { name: 'Streitkolben', attack: 14, type: 'weapon', rarity: 0.06, style: 'mace', range: 60, speed: 1.2, tier: 'rare', minLevel: 5 },
                { name: 'Morgenstern', attack: 20, type: 'weapon', rarity: 0.04, style: 'morning_star', range: 65, speed: 1.4, tier: 'rare', minLevel: 10 },
                { name: 'Flegel', attack: 24, type: 'weapon', rarity: 0.03, style: 'flail', range: 75, speed: 1.5, tier: 'rare', minLevel: 12 },
                // Katanas (balanced, high crit)
                { name: 'Katana', attack: 16, type: 'weapon', rarity: 0.06, style: 'katana', range: 90, speed: 0.9, tier: 'rare', minLevel: 8, critBonus: 0.20 },
                { name: 'Muramasa', attack: 30, type: 'weapon', rarity: 0.02, style: 'muramasa', range: 95, speed: 0.8, tier: 'legendary', minLevel: 18, critBonus: 0.30 },
                // Magic weapons
                { name: 'Magierstab', attack: 14, type: 'weapon', rarity: 0.05, style: 'staff', range: 100, tier: 'rare', minLevel: 10 },
                { name: 'Feuerstab', attack: 22, type: 'weapon', rarity: 0.03, style: 'fire_staff', range: 110, tier: 'legendary', minLevel: 12, statusEffect: { type: 'burn', damage: 4, duration: 150, chance: 0.35 } },
                { name: 'Eisstab', attack: 20, type: 'weapon', rarity: 0.03, style: 'ice_staff', range: 110, tier: 'legendary', minLevel: 12, statusEffect: { type: 'freeze', damage: 0, duration: 120, chance: 0.25 } },
                { name: 'Blitzstab', attack: 24, type: 'weapon', rarity: 0.025, style: 'lightning_staff', range: 115, tier: 'legendary', minLevel: 15 },
                { name: 'Nekromanten-Stab', attack: 28, type: 'weapon', rarity: 0.02, style: 'necro_staff', range: 120, tier: 'legendary', minLevel: 18, lifeSteal: 0.20 },
                // Unique/Special weapons
                { name: 'Vampirklinge', attack: 15, type: 'weapon', rarity: 0.035, style: 'vampire_blade', range: 80, tier: 'rare', minLevel: 10, lifeSteal: 0.10 },
                { name: 'Berserker-Axt', attack: 32, type: 'weapon', rarity: 0.02, style: 'berserker_axe', range: 80, speed: 1.3, tier: 'legendary', minLevel: 15, berserkBonus: 0.30 },
                { name: 'Heiliger Hammer', attack: 25, type: 'weapon', rarity: 0.025, style: 'holy_hammer', range: 70, speed: 1.5, tier: 'legendary', minLevel: 15, holyDamage: 10 }
            ],
            armor: [
                { name: 'Lederrüstung', defense: 2, type: 'armor', rarity: 0.5, style: 'leather' },
                { name: 'Kettenrüstung', defense: 4, type: 'armor', rarity: 0.3, style: 'chain', minLevel: 3 },
                { name: 'Plattenrüstung', defense: 6, type: 'armor', rarity: 0.15, style: 'plate', minLevel: 6 },
                { name: 'Drachenrüstung', defense: 10, type: 'armor', rarity: 0.05, style: 'dragon', minLevel: 12 }
            ],
            potions: [
                { name: 'Kleiner Heiltrank', heal: 30, type: 'potion', rarity: 0.5 },
                { name: 'Heiltrank', heal: 50, type: 'potion', rarity: 0.35 },
                { name: 'Großer Heiltrank', heal: 100, type: 'potion', rarity: 0.15 }
            ],
            bombs: [
                { name: 'Bombe', damage: 40, type: 'bomb', rarity: 0.7 },
                { name: 'Große Bombe', damage: 80, type: 'bomb', rarity: 0.3 }
            ],
            // Monster-specific drops with drop chances
            monsterDrops: {
                goblin: { chance: 0.3, items: [{ name: 'Goblin-Dolch', attack: 6, type: 'weapon', style: 'dagger', range: 50, speed: 0.7 }] },
                skeleton: { chance: 0.25, items: [{ name: 'Knochenschwert', attack: 8, type: 'weapon', style: 'bone', range: 80 }] },
                orc: { chance: 0.2, items: [{ name: 'Ork-Axt', attack: 14, type: 'weapon', style: 'axe', range: 70, speed: 1.3 }] },
                mage: { chance: 0.1, items: [{ name: 'Magierstab', attack: 14, type: 'weapon', style: 'staff', range: 100 }] },
                demon: { chance: 0.15, items: [{ name: 'Dämonenklaue', attack: 22, type: 'weapon', style: 'claw', range: 60, speed: 0.8 }] }
            }
        };

        // Select item by rarity (respects minLevel requirement)
        function selectByRarity(items, isBossDrop = false, rarityBoost = 0) {
            // Filter items based on current room level and boss-only restrictions
            const currentLevel = game.currentRoom || 1;
            let availableItems = items.filter(item => {
                // Level requirement check
                if (item.minLevel && currentLevel < item.minLevel) return false;
                // LEGENDARY items ONLY from bosses!
                if (item.tier === 'legendary' && !isBossDrop) return false;
                return true;
            });

            // If no items available after filtering, use common items
            if (availableItems.length === 0) {
                availableItems = items.filter(item => !item.minLevel && item.tier !== 'legendary');
            }

            // Boss drops have +20% bonus for rare/legendary items
            const roll = Math.random();
            let cumulative = 0;

            // Recalculate rarities for available items
            let totalRarity = availableItems.reduce((sum, item) => sum + (item.rarity || 0.1), 0);

            for (const item of availableItems) {
                let itemRarity = (item.rarity || 0.1) / totalRarity;
                // Boss bonus for rare/legendary
                if (isBossDrop && (item.tier === 'rare' || item.tier === 'legendary')) {
                    itemRarity += 0.20;
                }
                // Rarity boost from chests/level scaling
                if (rarityBoost > 0 && (item.tier === 'rare' || item.tier === 'epic')) {
                    itemRarity += rarityBoost;
                }
                cumulative += itemRarity;
                if (roll < cumulative) return { ...item };
            }
            return { ...availableItems[0] };
        }

        // Gewichtete Monster-Auswahl: Stärkere Monster werden auf höheren Leveln wahrscheinlicher,
        // aber schwächere haben immer noch eine Chance
        function selectMonsterByWeight(currentRoom) {
            // Filter Monster nach minLevel
            const availableMonsters = monsterTypes.filter(m => !m.minLevel || currentRoom >= m.minLevel);
            if (availableMonsters.length === 0) return monsterTypes[0];
            if (availableMonsters.length === 1) return availableMonsters[0];

            // Berechne Gewichte: Index 0 (schwächstes) bekommt niedrigstes Gewicht auf hohen Leveln
            // Formel: Basisgewicht + Level-Bonus für stärkere Monster
            const weights = availableMonsters.map((monster, index) => {
                // Basisgewicht: Jedes Monster hat mindestens 15% relative Chance
                const baseWeight = 0.15;
                // Level-Skalierung: Höhere Index = stärkeres Monster = mehr Gewicht auf höheren Leveln
                const levelFactor = Math.min(currentRoom / 20, 1); // 0 bis 1, max bei Level 20
                const indexWeight = (index / (availableMonsters.length - 1)) * levelFactor;
                return baseWeight + indexWeight;
            });

            // Normalisiere Gewichte
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const normalizedWeights = weights.map(w => w / totalWeight);

            // Wähle basierend auf Gewicht
            const roll = Math.random();
            let cumulative = 0;
            for (let i = 0; i < availableMonsters.length; i++) {
                cumulative += normalizedWeights[i];
                if (roll < cumulative) return availableMonsters[i];
            }
            return availableMonsters[availableMonsters.length - 1];
        }

        // Gewichtete Elite-Monster-Auswahl basierend auf Level
        function selectEliteMonsterByLevel(currentRoom) {
            // Elite-Monster erst ab Level 10
            if (currentRoom < 10) return null;

            // Berechne wie viele Elite-Typen verfügbar sind (progressiv)
            // Level 10-13: nur Index 0 (Elite-Goblin)
            // Level 14-17: Index 0-1
            // Level 18-21: Index 0-2
            // Level 22+: alle
            const maxEliteIndex = Math.min(
                Math.floor((currentRoom - 10) / 4),
                eliteMonsterTypes.length - 1
            );

            // Gewichtete Auswahl: neuere Elite-Monster haben höhere Chance, alte haben noch ~20%
            const availableElites = eliteMonsterTypes.slice(0, maxEliteIndex + 1);
            const weights = availableElites.map((_, index) => {
                // Ältere Elites behalten 20% Basis-Chance
                const baseWeight = 0.2;
                // Neuere bekommen Bonus
                const indexBonus = index / maxEliteIndex * 0.8;
                return baseWeight + indexBonus;
            });

            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const roll = Math.random() * totalWeight;
            let cumulative = 0;
            for (let i = 0; i < availableElites.length; i++) {
                cumulative += weights[i];
                if (roll < cumulative) return availableElites[i];
            }
            return availableElites[maxEliteIndex];
        }

        // Level Layouts
        // WICHTIG: Layouts dürfen den Korridor-Bereich nicht blockieren!
        // Korridor ist bei x: 400-500, y: 0-60 (oben) und y: 440-500 (unten)
        // Auch nicht zu nah an Void-Zonen (x: 0-43 links, x: 857-900 rechts)
        const levelLayouts = {
            1: { // Tutorial Level - Einfach
                walls: [
                    { x: 200, y: 180, width: 180, height: 15 },
                    { x: 500, y: 300, width: 180, height: 15 }
                ]
            },
            2: { // Kreuzung
                walls: [
                    { x: 100, y: 250, width: 180, height: 15 },
                    { x: 550, y: 250, width: 180, height: 15 },
                    { x: 200, y: 100, width: 15, height: 130 },
                    { x: 650, y: 280, width: 15, height: 130 }
                ]
            },
            3: { // Labyrinth - angepasst, keine Blockade
                walls: [
                    { x: 120, y: 100, width: 15, height: 180 },
                    { x: 250, y: 150, width: 15, height: 200 },
                    { x: 550, y: 100, width: 15, height: 180 },
                    { x: 700, y: 200, width: 15, height: 180 },
                    { x: 120, y: 280, width: 130, height: 15 }
                ]
            },
            4: { // Vier Räume - angepasst für Void-Zonen
                walls: [
                    { x: 100, y: 250, width: 200, height: 15 },
                    { x: 550, y: 250, width: 200, height: 15 },
                    { x: 300, y: 100, width: 15, height: 130 },
                    { x: 550, y: 300, width: 15, height: 130 }
                ]
            },
            5: { // Spiral - angepasst
                walls: [
                    { x: 150, y: 120, width: 300, height: 15 },
                    { x: 150, y: 120, width: 15, height: 200 },
                    { x: 250, y: 220, width: 250, height: 15 },
                    { x: 500, y: 220, width: 15, height: 150 },
                    { x: 350, y: 320, width: 150, height: 15 }
                ]
            },
            6: { // Pillar Arena
                walls: [
                    { x: 200, y: 150, width: 40, height: 40 },
                    { x: 650, y: 150, width: 40, height: 40 },
                    { x: 200, y: 350, width: 40, height: 40 },
                    { x: 650, y: 350, width: 40, height: 40 },
                    { x: 420, y: 240, width: 50, height: 50 }
                ]
            },
            7: { // Enge Gänge - angepasst für breiteren Raum
                walls: [
                    { x: 150, y: 120, width: 15, height: 250 },
                    { x: 280, y: 100, width: 15, height: 280 },
                    { x: 550, y: 120, width: 15, height: 250 },
                    { x: 680, y: 100, width: 15, height: 280 }
                ]
            },
            8: { // Chaotisches Layout - angepasst
                walls: [
                    { x: 100, y: 120, width: 120, height: 15 },
                    { x: 280, y: 100, width: 15, height: 140 },
                    { x: 550, y: 180, width: 150, height: 15 },
                    { x: 180, y: 280, width: 15, height: 130 },
                    { x: 600, y: 300, width: 15, height: 120 },
                    { x: 150, y: 380, width: 180, height: 15 }
                ]
            },
            9: { // Vor-Boss Level - angepasst
                walls: [
                    { x: 120, y: 100, width: 15, height: 140 },
                    { x: 720, y: 100, width: 15, height: 140 },
                    { x: 120, y: 320, width: 15, height: 120 },
                    { x: 720, y: 320, width: 15, height: 120 },
                    { x: 200, y: 200, width: 180, height: 15 },
                    { x: 520, y: 300, width: 180, height: 15 }
                ]
            },
            10: { // BOSS ARENA - Offene Arena mit Eck-Säulen
                walls: [
                    // Vier Eck-Säulen (weg von Void-Zonen)
                    { x: 120, y: 100, width: 45, height: 45 },
                    { x: 720, y: 100, width: 45, height: 45 },
                    { x: 120, y: 360, width: 45, height: 45 },
                    { x: 720, y: 360, width: 45, height: 45 }
                ]
            }
        };

        // Generate a floor with connected sections (one big room)
        function generateFloor() {
            const isBossLevel = game.currentRoom % 10 === 0;

            // Determine number of sections (2-4 based on level, 1 for boss)
            let numSections;
            if (isBossLevel) {
                numSections = 1;
            } else {
                const baseSections = 2;
                const extraSections = Math.min(Math.floor(game.currentRoom / 10), 2);
                numSections = baseSections + extraSections;
            }

            // Clear game state
            game.walls = [];
            game.doors = [];
            game.monsters = [];
            game.items = [];
            game.traps = [];
            game.treasureChests = [];
            game.subRooms = [];
            game.roomDoors = [];
            game.voidZones = [];
            game.fallingEntities = [];
            game.currentSubRoom = 0;
            game.floorCleared = false;
            game.secretWalls = [];
            game.secretRoomFound = false;

            // Secret room chance (15% from level 3+, not on boss levels)
            game.hasSecretRoom = !isBossLevel && game.currentRoom >= 3 && Math.random() < 0.15;

            // Section size
            const sectionWidth = canvas.width;
            const sectionHeight = 500;

            // Calculate world size - sections stacked vertically
            game.worldWidth = sectionWidth;
            game.worldHeight = sectionHeight * numSections;

            // Check for dark level
            const levelsSinceLastDark = game.currentRoom - game.lastDarkLevel;
            if (game.currentRoom >= 4 && !isBossLevel) {
                if (levelsSinceLastDark >= 10) {
                    game.isDarkLevel = true;
                } else if (levelsSinceLastDark >= 3) {
                    game.isDarkLevel = Math.random() < 0.3;
                } else {
                    game.isDarkLevel = false;
                }
            } else {
                game.isDarkLevel = false;
            }

            if (game.isDarkLevel) {
                game.lastDarkLevel = game.currentRoom;
                game.lightRadius = 120 + game.player.level * 5;
                addLog('🌑 Dunkelheit umgibt dich...', 'info');
            }

            // Generate sections
            for (let i = 0; i < numSections; i++) {
                const sectionY = i * sectionHeight;
                const sectionType = determineRoomType(i, numSections);

                game.subRooms.push({
                    index: i,
                    type: sectionType,
                    cleared: false,
                    x: 0,
                    y: sectionY,
                    width: sectionWidth,
                    height: sectionHeight
                });

                // Void-Zonen an den Seiten (Abgrund)
                const voidWidth = 35;  // Breite des Abgrunds
                const borderWidth = game.voidBorderWidth || 8;  // Dünne Randmauer

                // Linke Void-Zone
                game.voidZones.push({
                    x: 0,
                    y: sectionY,
                    width: voidWidth,
                    height: sectionHeight,
                    side: 'left'
                });
                // Dünne Mauer am Rand des linken Void
                game.walls.push({ x: voidWidth, y: sectionY, width: borderWidth, height: sectionHeight, isVoidBorder: true });

                // Rechte Void-Zone
                game.voidZones.push({
                    x: sectionWidth - voidWidth,
                    y: sectionY,
                    width: voidWidth,
                    height: sectionHeight,
                    side: 'right'
                });
                // Dünne Mauer am Rand des rechten Void
                game.walls.push({ x: sectionWidth - voidWidth - borderWidth, y: sectionY, width: borderWidth, height: sectionHeight, isVoidBorder: true });

                // Top wall with gap for passage (except first section)
                if (i === 0) {
                    // Solid top wall for first section
                    game.walls.push({ x: 0, y: sectionY, width: sectionWidth, height: 20 });
                } else {
                    // Corridor transition from previous room
                    const corridorWidth = 100;
                    const corridorLength = 60;
                    const corridorStart = (sectionWidth - corridorWidth) / 2;

                    // Top wall with corridor opening
                    game.walls.push({ x: 0, y: sectionY, width: corridorStart, height: 20 });
                    game.walls.push({ x: corridorStart + corridorWidth, y: sectionY, width: sectionWidth - corridorStart - corridorWidth, height: 20 });

                    // Corridor side walls (extends into the room)
                    game.walls.push({ x: corridorStart, y: sectionY, width: 15, height: corridorLength, isCorridorWall: true });
                    game.walls.push({ x: corridorStart + corridorWidth - 15, y: sectionY, width: 15, height: corridorLength, isCorridorWall: true });
                }

                // Bottom wall with gap (except last section)
                if (i === numSections - 1) {
                    // Last section - exit door area with corridor
                    const corridorWidth = 80;
                    const corridorLength = 50;
                    const corridorStart = (sectionWidth - corridorWidth) / 2;

                    game.walls.push({ x: 0, y: sectionY + sectionHeight - 20, width: corridorStart, height: 20 });
                    game.walls.push({ x: corridorStart + corridorWidth, y: sectionY + sectionHeight - 20, width: sectionWidth - corridorStart - corridorWidth, height: 20 });

                    // Corridor walls leading to exit
                    game.walls.push({ x: corridorStart, y: sectionY + sectionHeight - corridorLength, width: 15, height: corridorLength - 20, isCorridorWall: true });
                    game.walls.push({ x: corridorStart + corridorWidth - 15, y: sectionY + sectionHeight - corridorLength, width: 15, height: corridorLength - 20, isCorridorWall: true });
                } else {
                    // Corridor transition to next section
                    const corridorWidth = 100;
                    const corridorLength = 60;
                    const corridorStart = (sectionWidth - corridorWidth) / 2;

                    game.walls.push({ x: 0, y: sectionY + sectionHeight - 20, width: corridorStart, height: 20 });
                    game.walls.push({ x: corridorStart + corridorWidth, y: sectionY + sectionHeight - 20, width: sectionWidth - corridorStart - corridorWidth, height: 20 });

                    // Corridor side walls
                    game.walls.push({ x: corridorStart, y: sectionY + sectionHeight - corridorLength, width: 15, height: corridorLength - 20, isCorridorWall: true });
                    game.walls.push({ x: corridorStart + corridorWidth - 15, y: sectionY + sectionHeight - corridorLength, width: 15, height: corridorLength - 20, isCorridorWall: true });
                }

                // Add obstacles in sections
                if (i === 0 && game.currentRoom <= 10 && levelLayouts[game.currentRoom]) {
                    // Use predefined layout for first 10 levels
                    const layout = levelLayouts[game.currentRoom];
                    for (const wall of layout.walls) {
                        game.walls.push({ ...wall, y: wall.y + sectionY });
                    }
                } else if (sectionType !== 'boss') {
                    // Random obstacles
                    const numObstacles = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < numObstacles; j++) {
                        const horizontal = Math.random() > 0.5;
                        let wx, wy, ww, wh;
                        let attempts = 0;
                        do {
                            if (horizontal) {
                                ww = Math.random() * 150 + 80;
                                wh = 20;
                                wx = Math.random() * (sectionWidth - ww - 100) + 50;
                                wy = sectionY + Math.random() * (sectionHeight - 150) + 75;
                            } else {
                                ww = 20;
                                wh = Math.random() * 100 + 60;
                                wx = Math.random() * (sectionWidth - 100) + 50;
                                wy = sectionY + Math.random() * (sectionHeight - wh - 100) + 50;
                            }
                            attempts++;
                        } while (attempts < 20 && (
                            Math.abs(wx - sectionWidth / 2) < 80 || // Don't block passage
                            wy < sectionY + 60 || wy + wh > sectionY + sectionHeight - 60
                        ));
                        if (attempts < 20) {
                            game.walls.push({ x: wx, y: wy, width: ww, height: wh });
                        }
                    }
                }

                // Spawn content based on section type
                const centerX = sectionWidth / 2;
                const centerY = sectionY + sectionHeight / 2;

                if (sectionType === 'treasure') {
                    // Treasure room
                    game.treasureChests.push({
                        x: centerX,
                        y: centerY,
                        opened: false,
                        size: 30
                    });
                    // Few guards
                    spawnMonstersInArea(sectionY + 50, sectionY + sectionHeight - 50, 2);
                } else if (sectionType === 'trap') {
                    // Trap room
                    spawnTrapsInArea(sectionY + 50, sectionY + sectionHeight - 50);
                    spawnMonstersInArea(sectionY + 50, sectionY + sectionHeight - 50, 3);
                } else if (sectionType === 'miniboss') {
                    // Mini-boss room
                    spawnMiniBossAt(centerX, centerY);
                } else if (sectionType === 'boss') {
                    // Boss room - handled by spawnMonsters
                    spawnMonstersInArea(sectionY + 50, sectionY + sectionHeight - 50, 1);
                } else {
                    // Normal room
                    spawnMonstersInArea(sectionY + 50, sectionY + sectionHeight - 50, 0);
                    spawnItemsInArea(sectionY + 50, sectionY + sectionHeight - 50);
                }
            }

            // Exit door at the very bottom
            game.doors.push({
                x: game.worldWidth / 2 - 30,
                y: game.worldHeight - 35,
                width: 60,
                height: 35,
                active: false, // Opens when all monsters dead
                isExit: true,
                direction: 'south'
            });

            // Generate secret room if applicable
            if (game.hasSecretRoom) {
                generateSecretRoom();
            }

            // Set player start position (top of world)
            game.player.x = game.worldWidth / 2;
            game.player.y = 80;

            // Initialize camera
            game.camera.x = 0;
            game.camera.y = 0;
            updateCamera();
        }

        // Generate a secret room accessible through a breakable wall
        function generateSecretRoom() {
            // Find a random section to add secret room to (not first or last)
            const validSections = game.subRooms.filter((room, i) =>
                i > 0 && i < game.subRooms.length - 1 && room.type !== 'boss'
            );
            if (validSections.length === 0) {
                game.hasSecretRoom = false;
                return;
            }

            const targetSection = validSections[Math.floor(Math.random() * validSections.length)];
            const isLeftWall = Math.random() < 0.5;

            // Secret room dimensions
            const secretWidth = 180;
            const secretHeight = 150;
            const secretX = isLeftWall ? -secretWidth : game.worldWidth;
            const secretY = targetSection.y + 150;

            // Add secret room walls
            // Top wall
            game.walls.push({ x: secretX, y: secretY, width: secretWidth, height: 15, isSecretRoom: true });
            // Bottom wall
            game.walls.push({ x: secretX, y: secretY + secretHeight - 15, width: secretWidth, height: 15, isSecretRoom: true });
            // Outer side wall
            if (isLeftWall) {
                game.walls.push({ x: secretX, y: secretY, width: 15, height: secretHeight, isSecretRoom: true });
            } else {
                game.walls.push({ x: secretX + secretWidth - 15, y: secretY, width: 15, height: secretHeight, isSecretRoom: true });
            }

            // Add breakable wall (entrance)
            const breakableWall = {
                x: isLeftWall ? 5 : game.worldWidth - 25,
                y: secretY + 30,
                width: 20,
                height: 90,
                isBreakable: true,
                hp: 50,
                maxHp: 50,
                secretRoom: true,
                cracked: false
            };
            game.secretWalls.push(breakableWall);

            // Add special treasure in secret room
            const chestX = secretX + secretWidth / 2;
            const chestY = secretY + secretHeight / 2;

            game.treasureChests.push({
                x: chestX,
                y: chestY,
                opened: false,
                isSecret: true // Marks as secret chest for better loot
            });

            // Expand world bounds to include secret room
            if (isLeftWall) {
                game.worldWidth += secretWidth;
                // Shift everything right
                for (const wall of game.walls) {
                    if (!wall.isSecretRoom) wall.x += secretWidth;
                }
                for (const chest of game.treasureChests) {
                    if (!chest.isSecret) chest.x += secretWidth;
                }
                for (const monster of game.monsters) {
                    monster.x += secretWidth;
                }
                for (const item of game.items) {
                    item.x += secretWidth;
                }
                for (const trap of game.traps) {
                    trap.x += secretWidth;
                }
                for (const door of game.doors) {
                    door.x += secretWidth;
                }
                for (const subRoom of game.subRooms) {
                    subRoom.x += secretWidth;
                }
                for (const secretWall of game.secretWalls) {
                    if (!secretWall.secretRoom) secretWall.x += secretWidth;
                    else secretWall.x = secretWidth - 25; // Adjust breakable wall position
                }
                game.player.x += secretWidth;
            }

            // Mark secret room in subRooms
            game.subRooms.push({
                index: game.subRooms.length,
                type: 'secret',
                cleared: false,
                x: isLeftWall ? 0 : game.worldWidth - secretWidth,
                y: secretY,
                width: secretWidth,
                height: secretHeight
            });

            // Hint for players
            addLog('[GEHEIM] Dieser Bereich fühlt sich seltsam an...', 'info');
        }

        function determineRoomType(roomIndex, totalRooms) {
            // Boss levels have boss room type
            if (game.currentRoom % 10 === 0) {
                return 'boss';
            }
            // Last room on mini-boss levels (5, 15, 25...) is mini-boss
            if (roomIndex === totalRooms - 1 && game.currentRoom % 5 === 0 && game.currentRoom % 10 !== 0) {
                return 'miniboss';
            }
            // Random chance for special rooms (not in first room)
            const roll = Math.random();
            if (roll < 0.15 && roomIndex > 0) return 'treasure';
            if (roll < 0.30 && roomIndex > 0) return 'trap';
            return 'normal';
        }

        // Update camera to follow player smoothly
        function updateCamera() {
            // Target camera position (center player on screen)
            const targetX = game.player.x - canvas.width / 2;
            const targetY = game.player.y - canvas.height / 2;

            // Smooth camera follow
            game.camera.x += (targetX - game.camera.x) * 0.1;
            game.camera.y += (targetY - game.camera.y) * 0.1;

            // Clamp camera to world bounds
            game.camera.x = Math.max(0, Math.min(game.worldWidth - canvas.width, game.camera.x));
            game.camera.y = Math.max(0, Math.min(game.worldHeight - canvas.height, game.camera.y));
        }

        // Spawn monsters in a specific Y area
        function spawnMonstersInArea(minY, maxY, overrideCount) {
            const isBossLevel = game.currentRoom % 10 === 0;

            let numMonsters;
            if (overrideCount !== undefined && overrideCount > 0) {
                numMonsters = overrideCount;
            } else if (isBossLevel) {
                numMonsters = 1; // Just the boss
            } else if (game.currentRoom === 1) {
                numMonsters = 2; // Level 1: 2 monsters
            } else {
                numMonsters = Math.floor(Math.random() * 3) + 2 + Math.floor(game.currentRoom / 5);
                numMonsters = Math.min(numMonsters, 8);
            }

            for (let i = 0; i < numMonsters; i++) {
                let x, y, attempts = 0;
                do {
                    x = Math.random() * (game.worldWidth - 100) + 50;
                    y = minY + Math.random() * (maxY - minY);
                    attempts++;
                } while (isInWall(x, y, 30) && attempts < 50);

                if (attempts < 50) {
                    // Decide monster type based on level
                    let monsterTemplate;
                    if (isBossLevel && i === 0) {
                        // Spawn boss
                        const bossIndex = Math.max(0, Math.min(Math.floor(game.currentRoom / 10) - 1, bossTypes.length - 1));
                        monsterTemplate = bossTypes[bossIndex];
                    } else if (game.currentRoom >= 10 && Math.random() < 0.12 + (game.currentRoom - 10) * 0.01) {
                        // Elite monster - ab Level 10, Chance steigt langsam (12% bis max 22%)
                        monsterTemplate = selectEliteMonsterByLevel(game.currentRoom);
                        if (!monsterTemplate) {
                            // Fallback falls Elite-Auswahl fehlschlägt
                            monsterTemplate = selectMonsterByWeight(game.currentRoom);
                        }
                    } else {
                        // Regular monster - gewichtete Auswahl
                        monsterTemplate = selectMonsterByWeight(game.currentRoom);
                    }

                    // Skip if no valid template
                    if (!monsterTemplate) continue;

                    const isElite = monsterTemplate.isElite || false;
                    const levelScale = 1 + (game.currentRoom - 1) * 0.1;

                    // Get weapon and armor pools based on monster style
                    const style = monsterTemplate.style || 'goblin';
                    const weaponPool = monsterWeapons[style] || [null];
                    const armorPool = monsterArmors[style] || [null];

                    // Select random weapon and armor (level 1: no weapons, level 2+: normal)
                    let equippedWeapon = null;
                    let equippedArmor = null;
                    if (game.currentRoom >= 3) {
                        equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                        equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];
                    } else if (game.currentRoom === 2) {
                        equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                    }

                    // Calculate stats with equipped items
                    const baseAtk = monsterTemplate.baseAttack || monsterTemplate.attack || 5;
                    const baseDef = monsterTemplate.baseDefense || monsterTemplate.defense || 1;
                    const baseHp = monsterTemplate.hp || 30;
                    const weaponAtk = equippedWeapon ? equippedWeapon.attack : 0;
                    const armorDef = equippedArmor ? equippedArmor.defense : 0;

                    // Level 1 monsters slightly weaker
                    const earlyLevelMult = game.currentRoom === 1 ? 0.85 : 1;
                    // Elite monsters get extra scaling
                    const eliteMultiplier = isElite ? 1.5 : 1;
                    const totalAttack = Math.floor((baseAtk + weaponAtk) * levelScale * eliteMultiplier * earlyLevelMult);
                    const totalDefense = Math.floor((baseDef + armorDef) * levelScale * eliteMultiplier * earlyLevelMult);
                    const totalHp = Math.floor(baseHp * levelScale * eliteMultiplier * earlyLevelMult);

                    // Calculate proper size based on monster style
                    let monsterSize = 18; // Default size
                    if (monsterTemplate.isBoss) {
                        monsterSize = 50;
                    } else if (style === 'goblin') {
                        monsterSize = isElite ? 18 : 14;
                    } else if (style === 'orc') {
                        monsterSize = isElite ? 26 : 22;
                    } else if (isElite) {
                        monsterSize = 24;
                    }

                    game.monsters.push({
                        ...monsterTemplate,
                        x, y,
                        hp: totalHp,
                        maxHp: totalHp,
                        attack: totalAttack,
                        defense: totalDefense,
                        size: monsterSize,
                        equippedWeapon: equippedWeapon ? { ...equippedWeapon } : null,
                        equippedArmor: equippedArmor ? { ...equippedArmor } : null,
                        weaponRange: equippedWeapon ? (equippedWeapon.range || 60) : 40,
                        animFrame: Math.random() * Math.PI * 2,
                        aiTimer: 0,
                        flashTimer: 0,
                        targetX: x,
                        targetY: y,
                        isAttacking: false,
                        attackFrame: 0,
                        isElite: isElite,
                        rangedCooldown: 0,
                        meleeCooldown: 0
                    });

                    // Record encounter in bestiary
                    recordMonsterEncounter(style);
                }
            }
        }

        // Spawn items in a specific Y area
        function spawnItemsInArea(minY, maxY) {
            // Level 1: Always spawn a starter weapon first
            if (game.currentRoom === 1 && game.items.length === 0) {
                const starterWeapons = itemTypes.weapons.filter(w => !w.minLevel && w.tier !== 'legendary' && w.tier !== 'rare');
                if (starterWeapons.length > 0) {
                    const weapon = { ...starterWeapons[Math.floor(Math.random() * starterWeapons.length)] };
                    let x, y, attempts = 0;
                    do {
                        x = Math.random() * (game.worldWidth - 100) + 50;
                        y = minY + Math.random() * (maxY - minY);
                        attempts++;
                    } while (isInWall(x, y, 20) && attempts < 50);
                    weapon.x = x;
                    weapon.y = y;
                    weapon.size = 12;
                    weapon.animOffset = Math.random() * Math.PI * 2;
                    game.items.push(weapon);
                }
            }

            const numItems = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < numItems; i++) {
                let x, y, attempts = 0;
                do {
                    x = Math.random() * (game.worldWidth - 100) + 50;
                    y = minY + Math.random() * (maxY - minY);
                    attempts++;
                } while (isInWall(x, y, 20) && attempts < 50);

                if (attempts < 50) {
                    const roll = Math.random();
                    let item;
                    if (roll < 0.5) {
                        item = selectByRarity(itemTypes.potions);
                    } else if (roll < 0.8) {
                        item = selectByRarity(itemTypes.weapons);
                    } else {
                        item = selectByRarity(itemTypes.armor);
                    }
                    item.x = x;
                    item.y = y;
                    item.size = 12;
                    item.animOffset = Math.random() * Math.PI * 2;
                    game.items.push(item);
                }
            }
        }

        // Spawn traps in a specific Y area
        function spawnTrapsInArea(minY, maxY) {
            const numTraps = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < numTraps; i++) {
                const trapType = trapTypes[Math.floor(Math.random() * trapTypes.length)];
                let x, y, attempts = 0;
                do {
                    x = Math.random() * (game.worldWidth - 100) + 50;
                    y = minY + Math.random() * (maxY - minY);
                    attempts++;
                } while (isInWall(x, y, 40) && attempts < 50);

                if (attempts < 50) {
                    game.traps.push({
                        ...trapType,
                        x, y,
                        size: 40,
                        timer: 0,
                        warning: false,
                        active: false,
                        animTimer: Math.random() * Math.PI * 2,
                        spikeHeight: 0,
                        fountainParticles: []
                    });
                }
            }
        }

        // Spawn mini-boss at specific location
        function spawnMiniBossAt(x, y) {
            const miniBossTemplate = miniBossTypes[Math.floor(Math.random() * miniBossTypes.length)];
            if (!miniBossTemplate) return; // Safety check

            const levelScale = 1 + (game.currentRoom - 1) * 0.08;
            const baseAtk = miniBossTemplate.attack || miniBossTemplate.baseAttack || 20;
            const baseDef = miniBossTemplate.defense || miniBossTemplate.baseDefense || 5;
            const baseHp = miniBossTemplate.hp || 150;

            game.monsters.push({
                ...miniBossTemplate,
                x, y,
                hp: Math.floor(baseHp * levelScale),
                maxHp: Math.floor(baseHp * levelScale),
                attack: Math.floor(baseAtk * levelScale),
                defense: Math.floor(baseDef * levelScale),
                size: 40,
                animFrame: Math.random() * Math.PI * 2,
                aiTimer: 0,
                flashTimer: 0,
                targetX: x,
                targetY: y,
                isAttacking: false,
                attackFrame: 0,
                isMiniBoss: true,
                rangedCooldown: 0,
                meleeCooldown: 0
            });
            addLog(`[ELITE] ${miniBossTemplate.name} erscheint!`, 'combat');
        }

        // Get current section based on player Y position
        function getCurrentSection() {
            for (const room of game.subRooms) {
                if (game.player.y >= room.y && game.player.y < room.y + room.height) {
                    return room.index;
                }
            }
            return 0;
        }

        function spawnTraps() {
            const numTraps = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < numTraps; i++) {
                const trapType = trapTypes[Math.floor(Math.random() * trapTypes.length)];
                let x, y, valid, attempts = 0;
                do {
                    x = Math.random() * (canvas.width - 150) + 75;
                    y = Math.random() * (canvas.height - 150) + 75;
                    valid = !isInWall(x, y, 40) && Math.hypot(x - game.player.x, y - game.player.y) > 100;
                    attempts++;
                } while (!valid && attempts < 50);

                game.traps.push({
                    ...trapType,
                    x, y,
                    size: 40,
                    timer: 0,
                    warning: false,
                    active: false,
                    animTimer: Math.random() * Math.PI * 2, // Animation phase offset
                    spikeHeight: 0, // For spike animation
                    fountainParticles: [] // For fire fountain
                });
            }
        }

        function spawnTreasureRoom() {
            // Spawn treasure chest in center
            game.treasureChests.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                opened: false,
                size: 30
            });
            // A few monsters guard it
            const numGuards = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < numGuards; i++) {
                spawnSingleMonster();
            }
        }

        function spawnMiniBoss() {
            const bossIndex = Math.max(0, Math.min(Math.floor(game.currentRoom / 10), miniBossTypes.length - 1));
            const template = miniBossTypes[bossIndex];
            if (!template) return;

            const levelMult = 1 + (game.currentRoom - 5) * 0.05;

            const diffMult = {
                easy: { hp: 0.7, attack: 0.7, defense: 0.8 },
                normal: { hp: 1, attack: 1, defense: 1 },
                hard: { hp: 1.5, attack: 1.3, defense: 1.2 }
            }[game.difficulty] || { hp: 1, attack: 1, defense: 1 };

            const baseHp = template.hp || 150;
            const baseAtk = template.attack || template.baseAttack || 20;
            const baseDef = template.defense || template.baseDefense || 5;
            const baseXp = template.xp || 100;
            const baseGold = template.gold || 50;

            const miniBoss = {
                ...template,
                x: game.worldWidth / 2,
                y: game.player.y + 200,
                size: 28,
                hp: Math.floor(baseHp * levelMult * diffMult.hp),
                maxHp: Math.floor(baseHp * levelMult * diffMult.hp),
                attack: Math.floor(baseAtk * levelMult * diffMult.attack),
                defense: Math.floor(baseDef * levelMult * diffMult.defense),
                xp: Math.floor(baseXp * levelMult),
                gold: Math.floor(baseGold * levelMult),
                isMiniBoss: true,
                targetX: game.worldWidth / 2,
                targetY: game.player.y + 200,
                aiTimer: 0,
                animFrame: 0,
                attackFrame: 0,
                flashTimer: 0,
                rangedCooldown: 0,
                meleeCooldown: 0
            };

            game.monsters.push(miniBoss);
            addLog(`[ELITE] ${miniBoss.name} erscheint!`, 'combat');
        }

        function spawnSingleMonster() {
            // Gewichtete Monster-Auswahl verwenden
            const template = selectMonsterByWeight(game.currentRoom);
            if (!template) return;

            let x, y, valid, attempts = 0;
            do {
                x = Math.random() * (game.worldWidth - 100) + 50;
                y = Math.random() * (game.worldHeight - 100) + 50;
                valid = Math.hypot(x - game.player.x, y - game.player.y) > 150 && !isInWall(x, y, 25);
                attempts++;
            } while (!valid && attempts < 100);

            // Get weapon and armor pools
            const style = template.style || 'goblin';
            const weaponPool = monsterWeapons[style] || [null];
            const armorPool = monsterArmors[style] || [null];
            const equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
            const equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];

            const levelScale = 1 + (game.currentRoom - 1) * 0.1;
            const baseHp = template.hp || 30;
            const baseAtk = template.baseAttack || template.attack || 5;
            const baseDef = template.baseDefense || template.defense || 1;
            const weaponAtk = equippedWeapon ? equippedWeapon.attack : 0;
            const armorDef = equippedArmor ? equippedArmor.defense : 0;

            // Calculate proper size based on monster style
            const isElite = template.isElite || false;
            let monsterSize = 18;
            if (template.isBoss) {
                monsterSize = 50;
            } else if (style === 'goblin') {
                monsterSize = isElite ? 18 : 14;
            } else if (style === 'orc') {
                monsterSize = isElite ? 26 : 22;
            } else if (isElite) {
                monsterSize = 24;
            }

            game.monsters.push({
                ...template,
                x, y,
                size: monsterSize,
                hp: Math.floor(baseHp * levelScale),
                maxHp: Math.floor(baseHp * levelScale),
                attack: Math.floor((baseAtk + weaponAtk) * levelScale),
                defense: Math.floor((baseDef + armorDef) * levelScale),
                equippedWeapon: equippedWeapon ? { ...equippedWeapon } : null,
                equippedArmor: equippedArmor ? { ...equippedArmor } : null,
                weaponRange: equippedWeapon ? (equippedWeapon.range || 60) : 40,
                targetX: x, targetY: y,
                aiTimer: 0, animFrame: 0, attackFrame: 0, flashTimer: 0,
                rangedCooldown: 0, meleeCooldown: 0,
                isElite: isElite
            });
        }

        // Legacy function for compatibility
        function generateRoom() {
            generateFloor();
        }

        // Legacy function - no longer used (connected room system)
        function moveToSubRoom(roomIndex, fromDirection) {
            // No longer needed - rooms are now connected without transitions
        }

        // Update treasure chests
        function updateTreasureChests() {
            // Chests just sit there waiting to be opened
        }

        // Open a treasure chest if player is near
        function openTreasureChest() {
            for (const chest of game.treasureChests) {
                if (chest.opened) continue;

                const chestDist = Math.hypot(game.player.x - chest.x, game.player.y - chest.y);
                if (chestDist < 50) {
                    chest.opened = true;
                    sfx.chestOpen(); // Chest opening sound

                    // Generate loot - scales with level, bonus for secret chests
                    const isSecret = chest.isSecret || false;
                    const secretMult = isSecret ? 2.0 : 1.0;
                    const levelMult = 1 + game.currentRoom * 0.2;
                    const goldAmount = Math.floor((80 + Math.random() * 150) * levelMult * secretMult);
                    game.player.gold += goldAmount;

                    // Always drop items - amount scales with level (2-4 items, secret: 4-6)
                    const baseItems = isSecret ? 4 : 2;
                    const bonusItems = Math.floor(game.currentRoom / 5); // +1 item every 5 levels
                    const itemCount = Math.min(baseItems + bonusItems + (Math.random() < 0.3 ? 1 : 0), isSecret ? 7 : 5);

                    // Higher levels = better rarity chances (secret chests have huge bonus)
                    const rarityBoost = Math.min(game.currentRoom * 0.02 + (isSecret ? 0.3 : 0), 0.6); // Up to 60% boost for secret

                    for (let i = 0; i < itemCount; i++) {
                        const roll = Math.random();
                        let item;

                        // Adjust drop chances based on level
                        const weaponChance = 0.35 + (game.currentRoom > 10 ? 0.1 : 0);
                        const armorChance = weaponChance + 0.25;

                        if (roll < weaponChance) {
                            item = selectByRarity(itemTypes.weapons, false, rarityBoost);
                        } else if (roll < armorChance) {
                            item = selectByRarity(itemTypes.armor, false, rarityBoost);
                        } else {
                            item = selectByRarity(itemTypes.potions, false);
                        }

                        // Spread items in a circle around chest
                        const angle = (i / itemCount) * Math.PI * 2 + Math.random() * 0.5;
                        const spreadDist = 25 + Math.random() * 20;
                        item.x = chest.x + Math.cos(angle) * spreadDist;
                        item.y = chest.y + Math.sin(angle) * spreadDist;
                        item.size = 12;
                        item.animOffset = Math.random() * Math.PI * 2;
                        game.items.push(item);
                    }

                    if (isSecret) {
                        addLog(`[GEHEIM] Schatztruhe geöffnet! +${goldAmount} Gold! ${itemCount} seltene Items!`, 'legendary');
                        game.secretRoomFound = true;
                    } else {
                        addLog(`[TRUHE] Geöffnet! +${goldAmount} Gold! ${itemCount} Items!`, 'loot');
                    }
                    sfx.goldPickup();

                    // Enhanced sparkle effect for better chests
                    const particleCount = 15 + Math.floor(game.currentRoom / 3) * 5;
                    const colors = ['#fbbf24', '#f59e0b', '#fcd34d', '#ffffff'];
                    for (let i = 0; i < Math.min(particleCount, 40); i++) {
                        game.particles.push({
                            x: chest.x + (Math.random() - 0.5) * 50,
                            y: chest.y + (Math.random() - 0.5) * 50,
                            vx: (Math.random() - 0.5) * 4,
                            vy: -Math.random() * 4 - 1,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            life: 50,
                            size: 3 + Math.random() * 3
                        });
                    }

                    // Mark room as cleared if it was a treasure room
                    if (game.subRooms[game.currentSubRoom].type === 'treasure' && game.monsters.length === 0) {
                        roomCleared();
                    }
                    break;
                }
            }
        }

        // Boss types for different levels
        const bossTypes = [
            // Tier 1: Level 10-50
            { name: 'Dungeon Lord', color: '#9333ea', hp: 300, attack: 30, defense: 10, xp: 500, gold: 200, speed: 0.7,
              meleeBonus: 15, specialAttacks: ['jumpAttack', 'groundSlam'], minionType: 'goblin_elite', style: 'demon' },
            { name: 'Skelett-König', color: '#e2e8f0', hp: 400, attack: 40, defense: 15, xp: 800, gold: 350, speed: 0.8,
              meleeBonus: 20, specialAttacks: ['arrowRain', 'boneShield'], minionType: 'skeleton_knight', style: 'skeleton' },
            { name: 'Drachen-Fürst', color: '#ef4444', hp: 550, attack: 55, defense: 20, xp: 1200, gold: 500, speed: 0.9,
              meleeBonus: 25, specialAttacks: ['fireBreath', 'wingGust'], minionType: 'orc_berserker', style: 'demon' },
            { name: 'Schatten-Lord', color: '#1a1a2e', hp: 700, attack: 70, defense: 25, xp: 1800, gold: 700, speed: 1.0,
              meleeBonus: 30, specialAttacks: ['shadowDash', 'darkOrbs'], minionType: 'mage_corrupted', style: 'demon' },
            { name: 'Uralt-Titan', color: '#fbbf24', hp: 1000, attack: 90, defense: 35, xp: 2500, gold: 1000, speed: 0.6,
              meleeBonus: 40, specialAttacks: ['earthquake', 'meteorStrike'], minionType: 'demon_spawn', style: 'demon' },
            // Tier 2: Level 60-100
            { name: 'Frost-Hexer', color: '#60a5fa', hp: 850, attack: 75, defense: 20, xp: 3000, gold: 1200, speed: 0.8,
              meleeBonus: 25, specialAttacks: ['iceSpikes', 'frostNova'], minionType: 'frost_elemental', style: 'mage' },
            { name: 'Gift-Königin', color: '#22c55e', hp: 750, attack: 85, defense: 18, xp: 3500, gold: 1400, speed: 1.1,
              meleeBonus: 35, specialAttacks: ['poisonCloud', 'acidSpit'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Blut-Baron', color: '#dc2626', hp: 900, attack: 95, defense: 28, xp: 4000, gold: 1600, speed: 1.2,
              meleeBonus: 40, specialAttacks: ['bloodDrain', 'batSwarm'], minionType: 'vampire_spawn', style: 'demon' },
            { name: 'Sturm-Wächter', color: '#fbbf24', hp: 1100, attack: 110, defense: 32, xp: 4500, gold: 1800, speed: 1.3,
              meleeBonus: 45, specialAttacks: ['lightningStrike', 'thunderWave'], minionType: 'storm_elemental', style: 'demon' },
            { name: 'Chaos-Imperator', color: '#a855f7', hp: 1500, attack: 130, defense: 40, xp: 6000, gold: 2500, speed: 1.0,
              meleeBonus: 55, specialAttacks: ['chaosRift', 'voidBlast'], minionType: 'chaos_spawn', style: 'demon' },
            // Tier 3: Level 110-150
            { name: 'Nekromant', color: '#4a044e', hp: 1200, attack: 140, defense: 35, xp: 7000, gold: 3000, speed: 0.9,
              meleeBonus: 50, specialAttacks: ['summonUndead', 'deathWave', 'soulDrain'], minionType: 'skeleton_knight', style: 'mage' },
            { name: 'Lavabiest', color: '#f97316', hp: 1800, attack: 155, defense: 45, xp: 8000, gold: 3500, speed: 0.7,
              meleeBonus: 60, specialAttacks: ['lavaPool', 'fireBreath', 'eruption'], minionType: 'fire_imp', style: 'demon' },
            { name: 'Eiskönig', color: '#0ea5e9', hp: 1600, attack: 145, defense: 50, xp: 8500, gold: 3800, speed: 0.8,
              meleeBonus: 55, specialAttacks: ['blizzard', 'iceSpikes', 'freezeAura'], minionType: 'frost_elemental', style: 'skeleton' },
            { name: 'Seelenfresser', color: '#6b21a8', hp: 1400, attack: 170, defense: 30, xp: 9000, gold: 4000, speed: 1.2,
              meleeBonus: 65, specialAttacks: ['soulDrain', 'terrorScream', 'shadowClones'], minionType: 'wraith', style: 'demon' },
            { name: 'Kriegsherr', color: '#78350f', hp: 2200, attack: 160, defense: 60, xp: 9500, gold: 4200, speed: 0.6,
              meleeBonus: 70, specialAttacks: ['battleCry', 'shieldBash', 'whirlwind'], minionType: 'orc_berserker', style: 'orc' },
            // Tier 4: Level 160-200
            { name: 'Void-Wanderer', color: '#312e81', hp: 1900, attack: 185, defense: 40, xp: 10000, gold: 4500, speed: 1.1,
              meleeBonus: 75, specialAttacks: ['voidBlast', 'dimensionRift', 'darkPulse'], minionType: 'void_spawn', style: 'demon' },
            { name: 'Phönix-Lord', color: '#fbbf24', hp: 2000, attack: 175, defense: 35, xp: 11000, gold: 5000, speed: 1.3,
              meleeBonus: 70, specialAttacks: ['fireBreath', 'rebirth', 'inferno'], minionType: 'fire_imp', style: 'demon' },
            { name: 'Kristall-Golem', color: '#67e8f9', hp: 3000, attack: 150, defense: 80, xp: 12000, gold: 5500, speed: 0.4,
              meleeBonus: 80, specialAttacks: ['crystalShards', 'reflectShield', 'earthquake'], minionType: 'crystal_shard', style: 'demon' },
            { name: 'Giftdrache', color: '#84cc16', hp: 2400, attack: 195, defense: 45, xp: 13000, gold: 6000, speed: 1.0,
              meleeBonus: 85, specialAttacks: ['poisonCloud', 'acidBreath', 'toxicRain'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Zeitwächter', color: '#e0e7ff', hp: 2100, attack: 180, defense: 55, xp: 14000, gold: 6500, speed: 1.4,
              meleeBonus: 75, specialAttacks: ['timeFreeze', 'chronoBlast', 'rewind'], minionType: 'time_phantom', style: 'mage' },
            // Tier 5: Level 210-250
            { name: 'Hydra', color: '#14b8a6', hp: 3500, attack: 200, defense: 50, xp: 15000, gold: 7000, speed: 0.8,
              meleeBonus: 90, specialAttacks: ['multiHead', 'acidSpit', 'regenerate'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Lichkönig', color: '#d4d4d8', hp: 2800, attack: 220, defense: 45, xp: 16000, gold: 7500, speed: 0.9,
              meleeBonus: 95, specialAttacks: ['frostNova', 'summonUndead', 'deathGrip'], minionType: 'death_knight', style: 'skeleton' },
            { name: 'Erz-Dämon', color: '#b91c1c', hp: 3200, attack: 230, defense: 55, xp: 17000, gold: 8000, speed: 1.1,
              meleeBonus: 100, specialAttacks: ['hellfire', 'demonGate', 'corruption'], minionType: 'demon_lord', style: 'demon' },
            { name: 'Sturmriese', color: '#3b82f6', hp: 4000, attack: 210, defense: 65, xp: 18000, gold: 8500, speed: 0.5,
              meleeBonus: 110, specialAttacks: ['thunderStorm', 'earthquake', 'giantSmash'], minionType: 'storm_elemental', style: 'orc' },
            { name: 'Schattenfürst', color: '#1e1b4b', hp: 2600, attack: 250, defense: 40, xp: 19000, gold: 9000, speed: 1.5,
              meleeBonus: 105, specialAttacks: ['shadowDash', 'darkOrbs', 'nightmare'], minionType: 'shadow_assassin', style: 'demon' },
            // Tier 6: Level 260-300 (Endgame)
            { name: 'Weltenverschlinger', color: '#581c87', hp: 4500, attack: 270, defense: 60, xp: 22000, gold: 10000, speed: 0.9,
              meleeBonus: 120, specialAttacks: ['voidBlast', 'consume', 'dimensionRift'], minionType: 'void_spawn', style: 'demon' },
            { name: 'Uralter Drache', color: '#dc2626', hp: 5000, attack: 280, defense: 70, xp: 25000, gold: 12000, speed: 0.8,
              meleeBonus: 130, specialAttacks: ['fireBreath', 'tailSwipe', 'dragonRoar'], minionType: 'dragon_whelp', style: 'demon' },
            { name: 'Götterbote', color: '#fcd34d', hp: 4200, attack: 300, defense: 55, xp: 28000, gold: 14000, speed: 1.2,
              meleeBonus: 140, specialAttacks: ['holySmite', 'judgement', 'divineWrath'], minionType: 'angel_warrior', style: 'mage' },
            { name: 'Apokalypse', color: '#7c2d12', hp: 5500, attack: 320, defense: 75, xp: 32000, gold: 16000, speed: 1.0,
              meleeBonus: 150, specialAttacks: ['meteorStrike', 'hellfire', 'worldEnder'], minionType: 'demon_lord', style: 'demon' },
            { name: 'Der Ewige', color: '#fafafa', hp: 6666, attack: 350, defense: 80, xp: 40000, gold: 20000, speed: 1.1,
              meleeBonus: 175, specialAttacks: ['timeFreeze', 'cosmicBlast', 'rebirth', 'judgment'], minionType: 'eternal_guardian', style: 'demon' }
        ];

        // Mutierte Monster-Typen (von Bossen gespawnt)
        const mutatedMonsters = {
            goblin_elite: { name: 'Goblin-Elite', color: '#4a5c3a', hp: 60, attack: 12, defense: 5, xp: 40, gold: 25, speed: 2.2, style: 'goblin' },
            skeleton_knight: { name: 'Skelett-Ritter', color: '#d4d4d8', hp: 80, attack: 18, defense: 10, xp: 60, gold: 35, speed: 1.5, style: 'skeleton' },
            orc_berserker: { name: 'Ork-Berserker', color: '#4a7c3a', hp: 100, attack: 22, defense: 8, xp: 80, gold: 45, speed: 1.8, style: 'orc' },
            mage_corrupted: { name: 'Verdorbener Magier', color: '#6b21a8', hp: 70, attack: 25, defense: 4, xp: 90, gold: 55, speed: 1.3, style: 'mage', attackType: 'ranged', attackRange: 200, attackCooldown: 90, projectileColor: '#9333ea', projectileSpeed: 5 },
            demon_spawn: { name: 'Dämonenbrut', color: '#7f1d1d', hp: 120, attack: 28, defense: 12, xp: 100, gold: 65, speed: 2.0, style: 'demon' },
            frost_elemental: { name: 'Frost-Elementar', color: '#93c5fd', hp: 90, attack: 30, defense: 8, xp: 120, gold: 70, speed: 1.4, style: 'mage', attackType: 'ranged', attackRange: 180, attackCooldown: 80, projectileColor: '#60a5fa', projectileSpeed: 5 },
            poison_spider: { name: 'Gift-Spinne', color: '#4ade80', hp: 70, attack: 35, defense: 5, xp: 130, gold: 75, speed: 2.5, style: 'goblin' },
            vampire_spawn: { name: 'Vampir-Brut', color: '#991b1b', hp: 100, attack: 38, defense: 10, xp: 150, gold: 85, speed: 2.0, style: 'demon' },
            storm_elemental: { name: 'Sturm-Elementar', color: '#fcd34d', hp: 110, attack: 42, defense: 12, xp: 170, gold: 95, speed: 1.8, style: 'mage', attackType: 'ranged', attackRange: 220, attackCooldown: 70, projectileColor: '#fbbf24', projectileSpeed: 7 },
            chaos_spawn: { name: 'Chaos-Brut', color: '#c084fc', hp: 140, attack: 50, defense: 15, xp: 200, gold: 120, speed: 2.2, style: 'demon' },
            // New minion types for new bosses
            fire_imp: { name: 'Feuer-Imp', color: '#f97316', hp: 80, attack: 45, defense: 8, xp: 140, gold: 80, speed: 2.3, style: 'goblin', attackType: 'ranged', attackRange: 150, attackCooldown: 100, projectileColor: '#ef4444', projectileSpeed: 6 },
            wraith: { name: 'Geist', color: '#a1a1aa', hp: 60, attack: 55, defense: 3, xp: 160, gold: 90, speed: 2.5, style: 'mage', attackType: 'ranged', attackRange: 200, attackCooldown: 85, projectileColor: '#6b21a8', projectileSpeed: 5 },
            void_spawn: { name: 'Leerenbrut', color: '#312e81', hp: 150, attack: 60, defense: 18, xp: 220, gold: 130, speed: 1.8, style: 'demon' },
            crystal_shard: { name: 'Kristallsplitter', color: '#67e8f9', hp: 200, attack: 40, defense: 35, xp: 180, gold: 100, speed: 1.0, style: 'demon' },
            time_phantom: { name: 'Zeitphantom', color: '#e0e7ff', hp: 90, attack: 65, defense: 10, xp: 200, gold: 110, speed: 2.8, style: 'mage', attackType: 'ranged', attackRange: 250, attackCooldown: 60, projectileColor: '#818cf8', projectileSpeed: 8 },
            death_knight: { name: 'Todesritter', color: '#1f2937', hp: 180, attack: 70, defense: 25, xp: 280, gold: 160, speed: 1.4, style: 'skeleton' },
            demon_lord: { name: 'Dämonenfürst', color: '#7f1d1d', hp: 220, attack: 80, defense: 22, xp: 320, gold: 180, speed: 1.6, style: 'demon' },
            shadow_assassin: { name: 'Schatten-Assassine', color: '#1e1b4b', hp: 100, attack: 90, defense: 8, xp: 300, gold: 170, speed: 3.0, style: 'demon' },
            dragon_whelp: { name: 'Drachenwelpe', color: '#dc2626', hp: 250, attack: 85, defense: 30, xp: 350, gold: 200, speed: 1.5, style: 'demon', attackType: 'ranged', attackRange: 180, attackCooldown: 90, projectileColor: '#f97316', projectileSpeed: 6 },
            angel_warrior: { name: 'Engel-Krieger', color: '#fcd34d', hp: 200, attack: 95, defense: 28, xp: 380, gold: 220, speed: 1.8, style: 'mage' },
            eternal_guardian: { name: 'Ewiger Wächter', color: '#fafafa', hp: 300, attack: 100, defense: 35, xp: 450, gold: 280, speed: 1.4, style: 'demon' }
        };

        // Mini-Bosse (erscheinen alle 5 Level, außer Boss-Level)
        const miniBossTypes = [
            { name: 'Goblin-Häuptling', color: '#166534', hp: 150, attack: 18, defense: 8, xp: 150, gold: 80, speed: 1.8, style: 'goblin',
              specialAbility: 'summon', summonType: 'goblin', summonCount: 2 },
            { name: 'Knochen-Golem', color: '#d4d4d8', hp: 200, attack: 22, defense: 15, xp: 200, gold: 100, speed: 0.8, style: 'skeleton',
              specialAbility: 'groundSlam', slamRadius: 100, slamDamage: 15 },
            { name: 'Ork-Kriegsherr', color: '#14532d', hp: 250, attack: 28, defense: 12, xp: 250, gold: 120, speed: 1.2, style: 'orc',
              specialAbility: 'enrage', enrageThreshold: 0.5, enrageAttackBonus: 2.0, enrageSpeedBonus: 1.5 },
            { name: 'Dunkler Erzmagier', color: '#581c87', hp: 180, attack: 35, defense: 6, xp: 300, gold: 150, speed: 1.0, style: 'mage',
              attackType: 'ranged', attackRange: 300, attackCooldown: 60, projectileColor: '#9333ea', projectileSpeed: 6,
              specialAbility: 'multishot', multishotCount: 3 },
            { name: 'Höllenwächter', color: '#991b1b', hp: 300, attack: 40, defense: 18, xp: 350, gold: 180, speed: 1.4, style: 'demon',
              specialAbility: 'fireAura', auraDamage: 5, auraRadius: 80 }
        ];

        // Trap types for room events
        const trapTypes = [
            { type: 'spikes', damage: 15, cooldown: 120, color: '#6b7280', warningTime: 60, activeHeight: 20 },
            { type: 'fire', damage: 20, cooldown: 180, color: '#ef4444', warningTime: 90, fountainHeight: 60 },
            { type: 'poison', damage: 8, duration: 180, cooldown: 240, color: '#22c55e', warningTime: 60, bubbleRate: 0.3 },
            { type: 'ice', damage: 5, slowAmount: 0.5, duration: 120, cooldown: 200, color: '#60a5fa', warningTime: 45, crystalCount: 5 }
        ];

        // Elite Monster Templates (ab Level 10, progressiv stärker) - droppen Elite-Waffen
        const eliteMonsterTypes = [
            { name: 'Elite-Goblin', color: '#2d4a1c', colorDark: '#1a2e10', hp: 80, attack: 20, defense: 8, xp: 100, gold: 60, speed: 2.0, style: 'goblin', isElite: true },
            { name: 'Elite-Skelett', color: '#f5f5f5', colorDark: '#b8b8b8', hp: 100, attack: 25, defense: 12, xp: 120, gold: 75, speed: 1.5, style: 'skeleton', isElite: true },
            { name: 'Elite-Ork', color: '#22c55e', colorDark: '#0f5132', hp: 150, attack: 32, defense: 15, xp: 150, gold: 90, speed: 1.3, style: 'orc', isElite: true },
            { name: 'Elite-Magier', color: '#7c3aed', colorDark: '#4c1d95', hp: 90, attack: 35, defense: 6, xp: 180, gold: 110, speed: 1.2, style: 'mage', isElite: true, attackType: 'ranged', attackRange: 280, attackCooldown: 70, projectileColor: '#a855f7', projectileSpeed: 6 },
            { name: 'Elite-Dämon', color: '#dc2626', colorDark: '#7f1d1d', hp: 200, attack: 45, defense: 18, xp: 250, gold: 150, speed: 1.5, style: 'demon', isElite: true }
        ];

        // Elite-Waffen Generator - skaliert mit Level
        function generateEliteWeapon(level) {
            const weaponTypes = [
                { baseName: 'Eliteklinge', style: 'sword', baseAttack: 20, range: 85 },
                { baseName: 'Eliteaxt', style: 'battleaxe', baseAttack: 25, range: 75, speed: 1.4 },
                { baseName: 'Elitespeer', style: 'spear', baseAttack: 18, range: 115 },
                { baseName: 'Elitehammer', style: 'hammer', baseAttack: 28, range: 70, speed: 1.5 },
                { baseName: 'Elitestab', style: 'staff', baseAttack: 22, range: 100 }
            ];

            const baseWeapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
            const levelBonus = Math.floor((level - 12) * 2);  // +2 attack pro Level über 12
            const tierSuffix = level >= 20 ? ' III' : level >= 16 ? ' II' : '';

            return {
                name: baseWeapon.baseName + tierSuffix,
                attack: baseWeapon.baseAttack + levelBonus,
                type: 'weapon',
                style: baseWeapon.style,
                range: baseWeapon.range,
                speed: baseWeapon.speed || 1,
                tier: 'rare',
                isEliteWeapon: true
            };
        }

        // Spawn mutated minion from boss
        function spawnBossMinion(boss) {
            const template = mutatedMonsters[boss.minionType];
            if (!template) return;

            // Find valid spawn position near boss
            let x, y, valid;
            let attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const dist = 60 + Math.random() * 40;
                x = boss.x + Math.cos(angle) * dist;
                y = boss.y + Math.sin(angle) * dist;
                valid = x > 50 && x < game.worldWidth - 50 && y > 50 && y < game.worldHeight - 50 && !isInWall(x, y, 20);
                attempts++;
            } while (!valid && attempts < 30);

            if (!valid) return;

            const baseHp = template.hp || 50;
            const baseAtk = template.attack || template.baseAttack || 15;
            const baseDef = template.defense || template.baseDefense || 5;

            // Calculate proper size based on minion style
            const minionStyle = template.style || 'goblin';
            let minionSize = 18;
            if (minionStyle === 'goblin') {
                minionSize = 14;
            } else if (minionStyle === 'orc') {
                minionSize = 22;
            } else if (minionStyle === 'skeleton') {
                minionSize = 18;
            }

            const minion = {
                name: template.name || 'Minion',
                color: template.color || '#888',
                hp: baseHp,
                maxHp: baseHp,
                attack: baseAtk,
                defense: baseDef,
                xp: template.xp || 30,
                gold: template.gold || 20,
                speed: template.speed || 1.5,
                style: minionStyle,
                x: x,
                y: y,
                size: minionSize,
                targetX: x,
                targetY: y,
                aiTimer: 0,
                animFrame: 0,
                flashTimer: 0,
                rangedCooldown: 0,
                meleeCooldown: 0,
                spawnedByBoss: boss,
                isMutated: true,
                attackType: template.attackType || 'melee',
                attackRange: template.attackRange || 0,
                attackCooldown: template.attackCooldown || 60,
                projectileColor: template.projectileColor || '#ff0000',
                projectileSpeed: template.projectileSpeed || 4
            };

            game.monsters.push(minion);
            addLog(`[BOSS] ${boss.name} beschwört ${template.name}!`, 'combat');

            // Spawn effect particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    color: boss.color,
                    life: 30,
                    size: 4
                });
            }
        }

        // Execute boss special attack
        function executeBossSpecialAttack(boss, attackType) {
            const playerDist = Math.hypot(game.player.x - boss.x, game.player.y - boss.y);

            switch(attackType) {
                case 'jumpAttack':
                    // Dungeon Lord jumps to player location
                    boss.isJumping = true;
                    boss.jumpTarget = { x: game.player.x, y: game.player.y };
                    boss.jumpProgress = 0;
                    boss.jumpStartX = boss.x;
                    boss.jumpStartY = boss.y;
                    addLog(`💥 ${boss.name} springt auf dich zu!`, 'combat');
                    break;

                case 'groundSlam':
                    // Area damage around boss
                    if (playerDist < 150) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.6) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 20;
                        game.screenShake = 20;
                        addLog(`💥 ${boss.name} schlägt auf den Boden! ${damage} Schaden!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    // Visual effect
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        game.particles.push({
                            x: boss.x + Math.cos(angle) * 50,
                            y: boss.y + Math.sin(angle) * 50,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            color: '#9333ea',
                            life: 40,
                            size: 6
                        });
                    }
                    break;

                case 'arrowRain':
                    // Skeleton King - Rain of arrows from above
                    addLog(`🏹 ${boss.name} ruft einen Pfeilregen herbei!`, 'combat');
                    for (let i = 0; i < 12; i++) {
                        setTimeout(() => {
                            if (game.player.isDying) return;
                            const targetX = game.player.x + (Math.random() - 0.5) * 150;
                            const targetY = game.player.y + (Math.random() - 0.5) * 150;
                            game.projectiles.push({
                                x: targetX,
                                y: -20,
                                vx: 0,
                                vy: 6,
                                color: '#e2e8f0',
                                damage: Math.floor(boss.attack * 0.4),
                                size: 6,
                                life: 120,
                                fromMonster: true,
                                trail: [],
                                isArrow: true
                            });
                        }, i * 100);
                    }
                    break;

                case 'boneShield':
                    // Skeleton King activates damage reduction
                    boss.shieldActive = true;
                    boss.shieldTimer = 180; // 3 seconds
                    addLog(`[BOSS] ${boss.name} aktiviert Knochenschild!`, 'combat');
                    break;

                case 'fireBreath':
                    // Dragon - Cone of fire projectiles
                    addLog(`[BOSS] ${boss.name} spuckt Feuer!`, 'combat');
                    const angleToPlayer = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                    for (let i = -2; i <= 2; i++) {
                        const spreadAngle = angleToPlayer + (i * 0.2);
                        game.projectiles.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(spreadAngle) * 5,
                            vy: Math.sin(spreadAngle) * 5,
                            color: '#ff6600',
                            damage: Math.floor(boss.attack * 0.5),
                            size: 12,
                            life: 90,
                            fromMonster: true,
                            trail: []
                        });
                    }
                    break;

                case 'wingGust':
                    // Dragon pushes player away
                    if (playerDist < 200) {
                        const pushAngle = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                        const pushDist = 100;
                        let newX = game.player.x + Math.cos(pushAngle) * pushDist;
                        let newY = game.player.y + Math.sin(pushAngle) * pushDist;
                        // Clamp to bounds
                        newX = Math.max(30, Math.min(game.worldWidth - 30, newX));
                        newY = Math.max(30, Math.min(game.worldHeight - 30, newY));
                        if (!isInWall(newX, newY, 20)) {
                            game.player.x = newX;
                            game.player.y = newY;
                        }
                        addLog(`💨 ${boss.name} bläst dich zurück!`, 'combat');
                    }
                    break;

                case 'shadowDash':
                    // Shadow Lord dashes through player
                    const dashAngle = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                    const dashDist = 200;
                    let dashX = boss.x + Math.cos(dashAngle) * dashDist;
                    let dashY = boss.y + Math.sin(dashAngle) * dashDist;
                    dashX = Math.max(50, Math.min(game.worldWidth - 50, dashX));
                    dashY = Math.max(50, Math.min(game.worldHeight - 50, dashY));
                    // Create trail particles
                    for (let i = 0; i < 15; i++) {
                        const t = i / 15;
                        game.particles.push({
                            x: boss.x + (dashX - boss.x) * t,
                            y: boss.y + (dashY - boss.y) * t,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#1a1a2e',
                            life: 40,
                            size: 8
                        });
                    }
                    boss.x = dashX;
                    boss.y = dashY;
                    // Damage if player was in path
                    if (playerDist < dashDist) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.7) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 15;
                        addLog(`🌑 ${boss.name} durchbohrt dich! ${damage} Schaden!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    break;

                case 'darkOrbs':
                    // Shadow Lord fires homing orbs
                    addLog(`[BOSS] ${boss.name} beschwört Schattenkugeln!`, 'combat');
                    for (let i = 0; i < 4; i++) {
                        const orbAngle = (i / 4) * Math.PI * 2;
                        game.projectiles.push({
                            x: boss.x + Math.cos(orbAngle) * 30,
                            y: boss.y + Math.sin(orbAngle) * 30,
                            vx: Math.cos(orbAngle) * 2,
                            vy: Math.sin(orbAngle) * 2,
                            color: '#6b21a8',
                            damage: Math.floor(boss.attack * 0.35),
                            size: 10,
                            life: 180,
                            fromMonster: true,
                            trail: [],
                            isHoming: true,
                            homingStrength: 0.03
                        });
                    }
                    break;

                case 'earthquake':
                    // Titan shakes the ground
                    game.screenShake = 30;
                    addLog(`🌋 ${boss.name} erschüttert die Erde!`, 'combat');
                    // Damage all in range and create obstacles
                    if (playerDist < 250) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.5) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 20;
                        addLog(`Du nimmst ${damage} Schaden vom Erdbeben!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    // Ground crack particles
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * 150;
                        game.particles.push({
                            x: boss.x + Math.cos(angle) * dist,
                            y: boss.y + Math.sin(angle) * dist,
                            vx: 0,
                            vy: -2 - Math.random() * 3,
                            color: '#92400e',
                            life: 50,
                            size: 5 + Math.random() * 5
                        });
                    }
                    break;

                case 'meteorStrike':
                    // Titan calls meteors
                    addLog(`[BOSS] ${boss.name} ruft Meteore herbei!`, 'combat');
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (game.player.isDying) return;
                            const targetX = Math.random() * (game.worldWidth - 100) + 50;
                            const targetY = Math.random() * (game.worldHeight - 100) + 50;
                            // Warning indicator
                            game.particles.push({
                                x: targetX,
                                y: targetY,
                                vx: 0,
                                vy: 0,
                                color: '#fbbf24',
                                life: 60,
                                size: 30,
                                isMeteorWarning: true
                            });
                            // Actual meteor
                            setTimeout(() => {
                                if (game.player.isDying) return;
                                const distToTarget = Math.hypot(game.player.x - targetX, game.player.y - targetY);
                                if (distToTarget < 50) {
                                    const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                                    const damage = Math.max(1, Math.floor(boss.attack * 0.8) - totalDef);
                                    game.player.hp = Math.max(0, game.player.hp - damage);
                                    game.player.flashTimer = 20;
                                    game.screenShake = 15;
                                    addLog(`[METEOR] Treffer! ${damage} Schaden!`, 'combat');
                                    if (game.player.hp <= 0) startPlayerDeath();
                                }
                                // Impact particles
                                for (let j = 0; j < 15; j++) {
                                    const pAngle = Math.random() * Math.PI * 2;
                                    game.particles.push({
                                        x: targetX,
                                        y: targetY,
                                        vx: Math.cos(pAngle) * 4,
                                        vy: Math.sin(pAngle) * 4,
                                        color: '#f97316',
                                        life: 30,
                                        size: 6
                                    });
                                }
                            }, 1000);
                        }, i * 400);
                    }
                    break;
            }
        }

        function spawnMonsters() {
            game.monsters = [];

            // BOSS FIGHT every 10 levels
            if (game.currentRoom % 10 === 0) {
                const bossIndex = Math.min(Math.floor(game.currentRoom / 10) - 1, bossTypes.length - 1);
                const bossTemplate = bossTypes[bossIndex];
                // Scale boss with level progression
                const levelMultiplier = 1 + (game.currentRoom - 10) * 0.1;

                // Find valid spawn position for boss (not in wall, far from player)
                let bossX, bossY, validPos;
                let attempts = 0;
                do {
                    bossX = game.worldWidth / 2 + (Math.random() - 0.5) * 200;
                    bossY = game.worldHeight / 2 + (Math.random() - 0.5) * 150;
                    validPos = !isInWall(bossX, bossY, 40) && Math.hypot(bossX - game.player.x, bossY - game.player.y) > 150;
                    attempts++;
                } while (!validPos && attempts < 100);

                // Difficulty multipliers for boss
                const diffMult = {
                    easy: { hp: 0.7, attack: 0.7, defense: 0.8 },
                    normal: { hp: 1, attack: 1, defense: 1 },
                    hard: { hp: 1.5, attack: 1.3, defense: 1.2 }
                }[game.difficulty] || { hp: 1, attack: 1, defense: 1 };

                const boss = {
                    name: bossTemplate.name,
                    color: bossTemplate.color,
                    hp: Math.floor(bossTemplate.hp * levelMultiplier * diffMult.hp),
                    maxHp: Math.floor(bossTemplate.hp * levelMultiplier * diffMult.hp),
                    attack: Math.floor(bossTemplate.attack * levelMultiplier * diffMult.attack),
                    defense: Math.floor(bossTemplate.defense * levelMultiplier * diffMult.defense),
                    xp: Math.floor(bossTemplate.xp * levelMultiplier),
                    gold: Math.floor(bossTemplate.gold * levelMultiplier),
                    speed: bossTemplate.speed,
                    x: bossX,
                    y: bossY,
                    size: 35 + bossIndex * 3,
                    targetX: bossX,
                    targetY: bossY,
                    aiTimer: 0,
                    animFrame: 0,
                    flashTimer: 0,
                    rangedCooldown: 0,
                    meleeCooldown: 0,
                    isBoss: true,
                    bossType: bossIndex,
                    attackType: 'melee',
                    style: bossTemplate.style,
                    // Boss special abilities
                    meleeBonus: bossTemplate.meleeBonus || 0,
                    specialAttacks: bossTemplate.specialAttacks || [],
                    minionType: bossTemplate.minionType,
                    specialCooldown: 0,
                    minionCooldown: 0,
                    minionCount: 0,
                    isJumping: false,
                    jumpTarget: null,
                    shieldActive: false,
                    shieldTimer: 0,
                    // Boss phase system
                    phase: 1,
                    maxPhases: 3,
                    phaseTriggered: [false, false, false] // Track which phases have been triggered
                };
                game.monsters.push(boss);
                recordMonsterEncounter('boss');
                addLog(`>>> BOSS ERSCHIENEN: ${boss.name}! <<<`, 'combat');
            } else {
                // Normal levels
                const numMonsters = Math.min(game.currentRoom + 1, 8);

                // Ab Level 10: Elite-Monster erscheinen (12% bis max 22%)
                const eliteChance = game.currentRoom >= 10 ? Math.min(0.12 + (game.currentRoom - 10) * 0.01, 0.22) : 0;
                const levelScale = game.currentRoom >= 10 ? 1 + (game.currentRoom - 10) * 0.05 : 1;

                for (let i = 0; i < numMonsters; i++) {
                    let template;
                    let isElite = false;

                    // Prüfe ob Elite-Monster spawnen soll (ab Level 10)
                    if (game.currentRoom >= 10 && Math.random() < eliteChance) {
                        // Elite Monster - gewichtete Auswahl basierend auf Level
                        template = selectEliteMonsterByLevel(game.currentRoom);
                        if (template) {
                            isElite = true;
                        } else {
                            // Fallback zu normalem Monster
                            template = selectMonsterByWeight(game.currentRoom);
                        }
                    } else {
                        // Normales Monster - gewichtete Auswahl (schwächere haben immer noch Chance)
                        template = selectMonsterByWeight(game.currentRoom);
                    }

                    let x, y, valid;
                    let attempts = 0;
                    do {
                        x = Math.random() * (game.worldWidth - 100) + 50;
                        y = Math.random() * (game.worldHeight - 100) + 50;
                        // Check distance from player AND not in wall
                        valid = Math.hypot(x - game.player.x, y - game.player.y) > 150 && !isInWall(x, y, 25);
                        attempts++;
                    } while (!valid && attempts < 100);

                    // Select random weapon and armor for monster (elite monsters get better gear)
                    const weaponPool = isElite
                        ? (eliteMonsterWeapons[template.style] || monsterWeapons[template.style] || [null])
                        : (monsterWeapons[template.style] || [null]);
                    const armorPool = isElite
                        ? (eliteMonsterArmors[template.style] || monsterArmors[template.style] || [null])
                        : (monsterArmors[template.style] || [null]);
                    const equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                    const equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];

                    // Calculate total attack and defense with difficulty multipliers
                    const diffMult = {
                        easy: { hp: 0.7, attack: 0.7, defense: 0.8 },
                        normal: { hp: 1, attack: 1, defense: 1 },
                        hard: { hp: 1.5, attack: 1.3, defense: 1.2 }
                    }[game.difficulty] || { hp: 1, attack: 1, defense: 1 };

                    const baseAtk = template.baseAttack || template.attack || 5;
                    const baseDef = template.baseDefense || template.defense || 1;
                    const weaponAtk = equippedWeapon ? equippedWeapon.attack : 0;
                    const armorDef = equippedArmor ? equippedArmor.defense : 0;
                    const totalAttack = baseAtk + weaponAtk;
                    const totalDefense = baseDef + armorDef;

                    const monster = {
                        ...template,
                        x, y,
                        size: template.style === 'orc' ? 22 : (template.style === 'goblin' ? 14 : (isElite ? 24 : 18)),
                        hp: Math.floor((isElite ? template.hp * levelScale : template.hp) * diffMult.hp),
                        maxHp: Math.floor((isElite ? template.hp * levelScale : template.hp) * diffMult.hp),
                        attack: Math.floor((isElite ? totalAttack * levelScale : totalAttack) * diffMult.attack),
                        defense: Math.floor((isElite ? totalDefense * levelScale : totalDefense) * diffMult.defense),
                        equippedWeapon: equippedWeapon ? { ...equippedWeapon } : null,
                        equippedArmor: equippedArmor ? { ...equippedArmor } : null,
                        weaponRange: equippedWeapon ? (equippedWeapon.range || 60) : 40,
                        targetX: x,
                        targetY: y,
                        aiTimer: 0,
                        animFrame: 0,
                        attackFrame: 0,
                        flashTimer: 0,
                        rangedCooldown: 0,
                        meleeCooldown: 0,
                        isElite: isElite
                    };

                    game.monsters.push(monster);

                    if (isElite) {
                        addLog(`[MONSTER] ${monster.name} erscheint!`, 'combat');
                    }
                }
            }
            updateMonsterCount();
        }

        function spawnItems() {
            game.items = [];
            const numItems = Math.floor(Math.random() * 3) + 1;

            // Level 1: Always spawn at least one weapon first
            if (game.currentRoom === 1) {
                const starterWeapons = itemTypes.weapons.filter(w => w.tier === 'common');
                const weapon = { ...starterWeapons[Math.floor(Math.random() * starterWeapons.length)] };
                let x, y, valid, attempts = 0;
                do {
                    x = Math.random() * (canvas.width - 100) + 50;
                    y = Math.random() * (canvas.height - 100) + 50;
                    valid = !isInWall(x, y, 15);
                    attempts++;
                } while (!valid && attempts < 50);
                weapon.x = x;
                weapon.y = y;
                weapon.size = 12;
                weapon.animOffset = Math.random() * Math.PI * 2;
                game.items.push(weapon);
            }

            for (let i = 0; i < numItems; i++) {
                const roll = Math.random();
                let item;

                if (roll < 0.45) {
                    item = selectByRarity(itemTypes.potions);
                } else if (roll < 0.70) {
                    item = selectByRarity(itemTypes.weapons);
                } else if (roll < 0.85) {
                    item = selectByRarity(itemTypes.armor);
                } else {
                    // 15% chance for bombs
                    item = selectByRarity(itemTypes.bombs);
                }

                // Find valid spawn position (not in wall)
                let x, y, valid;
                let attempts = 0;
                do {
                    x = Math.random() * (canvas.width - 100) + 50;
                    y = Math.random() * (canvas.height - 100) + 50;
                    valid = !isInWall(x, y, 15);
                    attempts++;
                } while (!valid && attempts < 50);

                item.x = x;
                item.y = y;
                item.size = 12;
                item.animOffset = Math.random() * Math.PI * 2;

                game.items.push(item);
            }
        }

        // Check if position is inside a wall
        function isInWall(x, y, padding = 20) {
            for (const wall of game.walls) {
                if (x > wall.x - padding && x < wall.x + wall.width + padding &&
                    y > wall.y - padding && y < wall.y + wall.height + padding) {
                    return true;
                }
            }
            return false;
        }

        // Drop item from monster with animation
        // Monsters now drop what they have equipped or potions
        function dropMonsterLoot(monster) {
            const isBoss = monster.isBoss || false;
            const isElite = monster.isElite || false;
            let item = null;

            // Difficulty drop rate modifier
            const dropMult = { easy: 1.2, normal: 1, hard: 0.8 }[game.difficulty] || 1;

            // Drop chances based on monster type (modified by difficulty)
            const baseDropChance = isBoss ? 1.0 : (isElite ? 0.85 : 0.50);
            const dropChance = Math.min(1.0, baseDropChance * dropMult);

            if (Math.random() > dropChance) return; // No drop

            // 5% chance to drop nothing (except bosses)
            if (!isBoss && Math.random() < 0.05) return;

            // Determine what to drop: equipped weapon, equipped armor, or potion
            const hasWeapon = monster.equippedWeapon;
            const hasArmor = monster.equippedArmor;

            if (isBoss) {
                // Bosses always drop their weapon with high tier (30% legendary, 70% rare)
                const isLegendary = Math.random() < 0.30;
                const tier = isLegendary ? 'legendary' : 'rare';

                // Last 6 bosses (bossType >= 4) have 25% chance to drop Feuerstab
                const bossIndex = monster.bossType || 0;
                if (bossIndex >= 4 && Math.random() < 0.25) {
                    item = {
                        name: 'Feuerstab',
                        attack: 22 + Math.floor(bossIndex * 3),  // Scales with boss level
                        type: 'weapon',
                        style: 'fire_staff',
                        range: 100,
                        tier: 'legendary'
                    };
                } else if (hasWeapon) {
                    item = { ...monster.equippedWeapon, tier: tier };
                    // Boost stats for boss drops
                    item.attack = Math.floor(item.attack * (isLegendary ? 1.5 : 1.2));
                } else {
                    item = selectByRarity(itemTypes.weapons, true);
                    item.tier = tier;
                }
                const dropPrefix = item.style === 'fire_staff' ? '[FEUER]' : (isLegendary ? '[LEGENDAR]' : '[BOSS]');
                addLog(`${dropPrefix} ${monster.name} droppt ${item.name}! (${item.tier})`, 'loot');
            } else if (isElite) {
                // Elite monsters drop elite weapons
                item = generateEliteWeapon(game.currentRoom);
                addLog(`[DROP] ${monster.name} droppt ${item.name}!`, 'loot');
            } else {
                // Normal monsters: 40% weapon, 25% armor, 35% potion
                const roll = Math.random();
                if (roll < 0.40 && hasWeapon) {
                    item = { ...monster.equippedWeapon };
                } else if (roll < 0.65 && hasArmor) {
                    item = { ...monster.equippedArmor };
                } else {
                    // Drop a potion
                    item = selectByRarity(itemTypes.potions, false);
                }
            }

            if (!item) return;

            // Find valid spawn position (not in wall)
            let itemX = monster.x;
            let itemY = monster.y;

            // If monster position is in a wall, find nearby valid position
            if (isInWall(itemX, itemY, 15)) {
                let found = false;
                // Try positions in expanding circle
                for (let radius = 20; radius <= 100 && !found; radius += 20) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const testX = monster.x + Math.cos(angle) * radius;
                        const testY = monster.y + Math.sin(angle) * radius;
                        if (!isInWall(testX, testY, 15) &&
                            testX > 50 && testX < game.worldWidth - 50 &&
                            testY > 50 && testY < game.worldHeight - 50) {
                            itemX = testX;
                            itemY = testY;
                            found = true;
                            break;
                        }
                    }
                }
            }

            // Spawn with drop animation
            item.x = itemX;
            item.y = itemY;
            item.size = 12;
            item.animOffset = Math.random() * Math.PI * 2;
            item.dropAnim = 20;  // Drop animation frames
            item.dropVy = -4;    // Initial upward velocity

            game.items.push(item);
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.size > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.size > rect2.y;
        }

        function movePlayer() {
            if (game.player.isDying) return;  // Can't move while dying
            if (game.player.isFalling) return;  // Can't move while falling into void

            const oldX = game.player.x;
            const oldY = game.player.y;

            // Movement keys
            const moveUp = game.keys.w || game.keys.ArrowUp;
            const moveDown = game.keys.s || game.keys.ArrowDown;
            const moveLeft = game.keys.a || game.keys.ArrowLeft;
            const moveRight = game.keys.d || game.keys.ArrowRight;
            const speed = game.player.speed;

            if (moveUp) game.player.y -= speed;
            if (moveDown) game.player.y += speed;
            if (moveLeft) {
                game.player.x -= speed;
                game.player.facingLeft = true;
            }
            if (moveRight) {
                game.player.x += speed;
                game.player.facingLeft = false;
            }

            // Track if player is moving for walk animation
            game.player.isMoving = (game.player.x !== oldX || game.player.y !== oldY);
            if (game.player.isMoving) {
                game.player.walkFrame += 0.3;
            }

            // Wall collision (player sprite is taller)
            for (const wall of game.walls) {
                const playerLeft = game.player.x - 10;
                const playerRight = game.player.x + 10;
                const playerTop = game.player.y - 12;
                const playerBottom = game.player.y + 25;

                if (playerLeft < wall.x + wall.width &&
                    playerRight > wall.x &&
                    playerTop < wall.y + wall.height &&
                    playerBottom > wall.y) {
                    game.player.x = oldX;
                    game.player.y = oldY;
                    break;
                }
            }

            // Exit door collision (only if active and no cooldown)
            if (game.doorCooldown <= 0) {
                for (const door of game.doors) {
                    if (door.active && door.isExit) {
                        const doorCenterX = door.x + door.width / 2;
                        const doorCenterY = door.y + door.height / 2;
                        const distX = Math.abs(game.player.x - doorCenterX);
                        const distY = Math.abs(game.player.y - doorCenterY);

                        if (distX < 40 && distY < 50) {
                            // Exit to next floor
                            nextRoom();
                            return;
                        }
                    }
                }
            }

            // Keep in world bounds
            game.player.x = Math.max(30, Math.min(game.worldWidth - 30, game.player.x));
            game.player.y = Math.max(30, Math.min(game.worldHeight - 30, game.player.y));

            // Update current section
            game.currentSubRoom = getCurrentSection();

            // Update camera to follow player
            updateCamera();
        }

        function updateMonsters() {
            for (let i = game.monsters.length - 1; i >= 0; i--) {
                const monster = game.monsters[i];

                monster.animFrame += 0.1;
                if (monster.flashTimer > 0) monster.flashTimer--;

                // Gift-Schaden über Zeit (von Fallen)
                if (monster.poisonTimer > 0) {
                    monster.poisonTimer--;
                    if (monster.poisonTimer % 30 === 0) { // Alle 0.5 Sekunden
                        monster.hp -= (monster.poisonDamage || 3);
                        monster.flashTimer = 5;
                    }
                }
                // Frost-Effekt abklingen (von Fallen)
                if (monster.frozenTimer > 0) {
                    monster.frozenTimer--;
                    if (monster.frozenTimer <= 0 && monster.originalSpeed) {
                        monster.speed = monster.originalSpeed;
                    }
                }

                // Handle skeleton reassembly animation
                if (monster.isReassembling) {
                    monster.reassembleTimer--;

                    // Update bone fragments - fly back to skeleton
                    if (monster.boneFragments) {
                        for (const bone of monster.boneFragments) {
                            // Move bones toward center
                            const dx = bone.targetX - bone.x;
                            const dy = bone.targetY - bone.y;
                            bone.x += dx * 0.08;
                            bone.y += dy * 0.08;
                            bone.rotation += 0.2;

                            // Spawn trail particles
                            if (Math.random() < 0.3) {
                                game.particles.push({
                                    x: bone.x,
                                    y: bone.y,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: (Math.random() - 0.5) * 2,
                                    color: '#94a3b8',
                                    life: 15,
                                    size: 2
                                });
                            }
                        }
                    }

                    // Reassembly complete
                    if (monster.reassembleTimer <= 0) {
                        monster.isReassembling = false;
                        monster.hp = Math.floor(monster.maxHp * monster.reassembleHp);
                        monster.boneFragments = null;
                        monster.flashTimer = 20;
                        addLog(`[UNTOT] ${monster.name} hat sich wieder zusammengesetzt!`, 'combat');

                        // Burst effect
                        for (let j = 0; j < 15; j++) {
                            game.particles.push({
                                x: monster.x + (Math.random() - 0.5) * 20,
                                y: monster.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                color: '#e2e8f0',
                                life: 30,
                                size: 4
                            });
                        }
                    }

                    continue; // Skip normal AI while reassembling
                }

                // Check for Enrage special ability (Orcs)
                if (monster.specialAbility === 'enrage' && !monster.isEnraged) {
                    const hpPercent = monster.hp / monster.maxHp;
                    if (hpPercent <= monster.enrageThreshold) {
                        monster.isEnraged = true;
                        monster.attack = Math.floor(monster.attack * monster.enrageAttackBonus);
                        monster.speed = monster.speed * monster.enrageSpeedBonus;
                        addLog(`[RAGE] ${monster.name} gerät in Rage!`, 'combat');
                        // Red flash effect
                        for (let j = 0; j < 10; j++) {
                            game.particles.push({
                                x: monster.x + (Math.random() - 0.5) * 30,
                                y: monster.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -Math.random() * 2,
                                color: '#ef4444',
                                life: 30,
                                size: 5
                            });
                        }
                    }
                }

                // AI behavior
                monster.aiTimer++;
                if (monster.aiTimer > 60) {
                    monster.aiTimer = 0;
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                    if (dist < 200 && !game.player.isInvisible) {
                        // Chase player
                        monster.targetX = game.player.x;
                        monster.targetY = game.player.y;
                    } else {
                        // Wander
                        monster.targetX = Math.random() * game.worldWidth;
                        monster.targetY = Math.random() * game.worldHeight;
                    }
                }

                // Boss Jump Attack animation
                if (monster.isBoss && monster.isJumping && monster.jumpTarget) {
                    monster.jumpProgress += 0.05;
                    const t = monster.jumpProgress;
                    // Parabolic arc
                    const arcHeight = 100;
                    monster.x = monster.jumpStartX + (monster.jumpTarget.x - monster.jumpStartX) * t;
                    monster.y = monster.jumpStartY + (monster.jumpTarget.y - monster.jumpStartY) * t - Math.sin(t * Math.PI) * arcHeight;

                    // Trail particles
                    if (Math.random() < 0.5) {
                        game.particles.push({
                            x: monster.x,
                            y: monster.y + monster.size/2,
                            vx: (Math.random() - 0.5) * 2,
                            vy: 1,
                            color: monster.color,
                            life: 20,
                            size: 4
                        });
                    }

                    // Land and deal damage
                    if (monster.jumpProgress >= 1) {
                        monster.isJumping = false;
                        monster.jumpTarget = null;
                        game.screenShake = 20;
                        // Impact damage
                        const landDist = Math.hypot(game.player.x - monster.x, game.player.y - monster.y);
                        if (landDist < 60 && !game.player.isDying && game.player.spawnProtection <= 0) {
                            const shieldBonusDef = game.shieldActive ? 15 : 0;
                            const totalDef = game.player.defense + (game.player.defenseBoost || 0) + shieldBonusDef;
                            const damage = Math.max(1, Math.floor(monster.attack * 0.8) - totalDef);
                            game.player.hp = Math.max(0, game.player.hp - damage);
                            game.player.flashTimer = 20;
                            addLog(`💥 ${monster.name} landet auf dir! ${damage} Schaden!`, 'combat');
                            if (game.player.hp <= 0) startPlayerDeath();
                        }
                        // Impact particles
                        for (let p = 0; p < 20; p++) {
                            const angle = (p / 20) * Math.PI * 2;
                            game.particles.push({
                                x: monster.x + Math.cos(angle) * 30,
                                y: monster.y + Math.sin(angle) * 30,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                color: '#92400e',
                                life: 30,
                                size: 5
                            });
                        }
                    }
                    continue; // Skip normal movement while jumping
                }

                // Move towards target
                const dx = monster.targetX - monster.x;
                const dy = monster.targetY - monster.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    const oldX = monster.x;
                    const oldY = monster.y;

                    monster.x += (dx / dist) * monster.speed;
                    monster.y += (dy / dist) * monster.speed;

                    // Wall collision for monsters
                    for (const wall of game.walls) {
                        const monsterLeft = monster.x - monster.size/2;
                        const monsterRight = monster.x + monster.size/2;
                        const monsterTop = monster.y - monster.size/2;
                        const monsterBottom = monster.y + monster.size/2;

                        if (monsterLeft < wall.x + wall.width &&
                            monsterRight > wall.x &&
                            monsterTop < wall.y + wall.height &&
                            monsterBottom > wall.y) {
                            monster.x = oldX;
                            monster.y = oldY;
                            // Change direction when hitting wall
                            monster.targetX = Math.random() * game.worldWidth;
                            monster.targetY = Math.random() * game.worldHeight;
                            break;
                        }
                    }
                }

                // Ranged attack for ranged and hybrid monsters
                if (monster.attackType === 'ranged' || monster.attackType === 'hybrid') {
                    monster.rangedCooldown = Math.max(0, monster.rangedCooldown - 1);
                    const distToPlayer = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                    // Hybrid monsters only use ranged if beyond melee range
                    const useRanged = monster.attackType === 'ranged' ||
                        (monster.attackType === 'hybrid' && distToPlayer > (monster.meleeRange || 60));

                    // Check line of sight before ranged attack
                    if (useRanged && !game.player.isInvisible && distToPlayer < monster.attackRange && monster.rangedCooldown <= 0 && hasLineOfSight(monster.x, monster.y, game.player.x, game.player.y)) {
                        // Fire projectile
                        const angle = Math.atan2(game.player.y - monster.y, game.player.x - monster.x);
                        game.projectiles.push({
                            x: monster.x,
                            y: monster.y,
                            vx: Math.cos(angle) * monster.projectileSpeed,
                            vy: Math.sin(angle) * monster.projectileSpeed,
                            color: monster.projectileColor,
                            damage: monster.attack,
                            size: 8,
                            life: 180,
                            fromMonster: true,
                            trail: []
                        });
                        monster.rangedCooldown = monster.attackCooldown;
                        monster.isAttacking = true;
                        monster.attackFrame = 0;
                    }
                }

                // Boss Phase System
                if (monster.isBoss && !game.player.isDying) {
                    const hpPercent = monster.hp / monster.maxHp;

                    // Phase 2: Below 66% HP - Enrage
                    if (hpPercent < 0.66 && monster.phase === 1 && !monster.phaseTriggered[1]) {
                        monster.phase = 2;
                        monster.phaseTriggered[1] = true;
                        monster.speed *= 1.2; // 20% faster
                        monster.attack = Math.floor(monster.attack * 1.15); // 15% more damage

                        // Phase transition effect
                        addLog(`[PHASE 2] ${monster.name} wird wütend!`, 'boss');
                        game.screenShake = 20;
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 2;
                            game.particles.push({
                                x: monster.x + Math.cos(angle) * 40,
                                y: monster.y + Math.sin(angle) * 40,
                                vx: Math.cos(angle) * 4,
                                vy: Math.sin(angle) * 4,
                                color: '#fbbf24',
                                life: 40,
                                size: 5
                            });
                        }
                        sfx.bossPhase();
                    }

                    // Phase 3: Below 33% HP - Desperate
                    if (hpPercent < 0.33 && monster.phase === 2 && !monster.phaseTriggered[2]) {
                        monster.phase = 3;
                        monster.phaseTriggered[2] = true;
                        monster.speed *= 1.3; // Even faster
                        monster.attack = Math.floor(monster.attack * 1.25); // 25% more damage
                        monster.defense = Math.floor(monster.defense * 0.8); // But weaker defense

                        // Phase 3 special: Activate shield
                        monster.shieldActive = true;
                        monster.shieldTimer = 180; // 3 seconds

                        // Spawn minions if possible
                        if (monster.minionType) {
                            spawnBossMinion(monster);
                            spawnBossMinion(monster);
                        }

                        // Phase transition effect
                        addLog(`[PHASE 3] ${monster.name} ist verzweifelt!`, 'boss');
                        game.screenShake = 30;
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            game.particles.push({
                                x: monster.x + Math.cos(angle) * 50,
                                y: monster.y + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 5,
                                vy: Math.sin(angle) * 5,
                                color: i % 2 === 0 ? '#ef4444' : '#fbbf24',
                                life: 50,
                                size: 6
                            });
                        }
                        sfx.bossPhase();
                    }
                }

                // Boss Special Abilities
                if (monster.isBoss && !game.player.isDying) {
                    monster.specialCooldown = Math.max(0, monster.specialCooldown - 1);
                    monster.minionCooldown = Math.max(0, monster.minionCooldown - 1);

                    // Shield timer countdown
                    if (monster.shieldActive) {
                        monster.shieldTimer--;
                        if (monster.shieldTimer <= 0) {
                            monster.shieldActive = false;
                        }
                    }

                    // Special Attack (every 5-8 seconds)
                    if (monster.specialCooldown <= 0 && monster.specialAttacks.length > 0) {
                        const attack = monster.specialAttacks[Math.floor(Math.random() * monster.specialAttacks.length)];
                        executeBossSpecialAttack(monster, attack);
                        monster.specialCooldown = 300 + Math.random() * 180; // 5-8 seconds
                    }

                    // Spawn Minions (max 3, every 10-15 seconds)
                    const currentMinions = game.monsters.filter(m => m.spawnedByBoss === monster).length;
                    if (monster.minionCooldown <= 0 && currentMinions < 3 && monster.minionType) {
                        spawnBossMinion(monster);
                        monster.minionCooldown = 600 + Math.random() * 300; // 10-15 seconds
                    }
                }

                // Melee attack based on weapon range (only if player not dying and not spawn protected)
                const meleeRange = monster.weaponRange || 30;
                const distToPlayer = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                // Decrement melee cooldown
                monster.meleeCooldown = Math.max(0, (monster.meleeCooldown || 0) - 1);

                // For hybrid monsters, use their meleeRange; otherwise use weaponRange
                const effectiveMeleeRange = monster.attackType === 'hybrid' ? (monster.meleeRange || 60) : meleeRange;

                // Check line of sight before melee attack (no attacking through walls)
                // Hybrid and melee monsters can melee attack
                if (!game.player.isDying && !game.player.isInvisible && game.player.spawnProtection <= 0 && monster.attackType !== 'ranged' && distToPlayer < effectiveMeleeRange && monster.meleeCooldown <= 0 && hasLineOfSight(monster.x, monster.y, game.player.x, game.player.y)) {
                    // Boss melee bonus damage
                    const meleeBonus = monster.isBoss ? (monster.meleeBonus || 0) : 0;
                    const shieldBonus = game.shieldActive ? 15 : 0; // Skill shield bonus
                    const totalDefense = game.player.defense + (game.player.defenseBoost || 0) + shieldBonus;
                    const damage = Math.max(1, monster.attack + meleeBonus - totalDefense);
                    game.player.hp = Math.max(0, game.player.hp - damage);
                    game.player.flashTimer = 15;  // Player damage flash
                    game.screenShake = monster.isBoss ? 15 : 10;  // Stronger shake for boss
                    monster.isAttacking = true;   // Monster attack animation
                    monster.attackFrame = 0;
                    sfx.playerHit();  // Player damage sound
                    addLog(`${monster.name} trifft dich für ${damage} Schaden!`, 'combat');
                    createParticles(game.player.x, game.player.y, '#ef4444');

                    // Monster special abilities on hit
                    if (monster.specialAbility === 'steal' && Math.random() < monster.stealChance) {
                        const stolen = Math.min(game.player.gold, monster.stealAmount || 5);
                        if (stolen > 0) {
                            game.player.gold -= stolen;
                            monster.gold += stolen;
                            addLog(`[DIEB] ${monster.name} stiehlt ${stolen} Gold!`, 'combat');
                        }
                    }

                    // Set cooldown (60 frames = 1 second, bosses attack faster)
                    monster.meleeCooldown = monster.isBoss ? 45 : 60;

                    if (game.player.hp <= 0) {
                        startPlayerDeath();
                    }
                }

                // Update monster attack animation
                if (monster.isAttacking) {
                    monster.attackFrame += 0.4;
                    if (monster.attackFrame > 15) {
                        monster.isAttacking = false;
                    }
                }
            }
        }

        // Update projectiles
        function updateProjectiles() {
            // Limit max projectiles to prevent lag
            const MAX_PROJECTILES = 50;
            if (game.projectiles.length > MAX_PROJECTILES) {
                game.projectiles.splice(0, game.projectiles.length - MAX_PROJECTILES);
            }

            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const proj = game.projectiles[i];

                // Store trail position
                proj.trail.push({ x: proj.x, y: proj.y });
                if (proj.trail.length > 8) proj.trail.shift();

                // Homing projectile logic
                if (proj.isHoming && proj.fromMonster) {
                    const angleToPlayer = Math.atan2(game.player.y - proj.y, game.player.x - proj.x);
                    const currentAngle = Math.atan2(proj.vy, proj.vx);
                    let angleDiff = angleToPlayer - currentAngle;
                    // Normalize angle
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const newAngle = currentAngle + angleDiff * (proj.homingStrength || 0.05);
                    const speed = Math.hypot(proj.vx, proj.vy);
                    proj.vx = Math.cos(newAngle) * speed;
                    proj.vy = Math.sin(newAngle) * speed;
                }

                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;

                // Check collision with player (monster projectiles) - only if not dying and not spawn protected
                if (proj.fromMonster && !game.player.isDying && game.player.spawnProtection <= 0) {
                    const distToPlayer = Math.hypot(proj.x - game.player.x, proj.y - game.player.y);
                    if (distToPlayer < 20) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, proj.damage - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 15;
                        game.screenShake = 8;
                        sfx.playerHit();  // Player damage sound
                        addLog(`Magischer Angriff trifft! -${damage} HP`, 'combat');
                        createParticles(game.player.x, game.player.y, proj.color);

                        if (game.player.hp <= 0) {
                            startPlayerDeath();
                        }

                        game.projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with monsters (player projectiles)
                if (proj.fromPlayer) {
                    for (let m = game.monsters.length - 1; m >= 0; m--) {
                        const monster = game.monsters[m];
                        const distToMonster = Math.hypot(proj.x - monster.x, proj.y - monster.y);
                        if (distToMonster < monster.size + 5) {
                            let damage = Math.max(1, proj.damage - monster.defense);
                            // Boss shield reduces damage
                            if (monster.isBoss && monster.shieldActive) {
                                damage = Math.max(1, Math.floor(damage * 0.5));
                            }
                            monster.hp -= damage;
                            monster.flashTimer = 10;
                            sfx.monsterHit(monster.style, monster.isBoss);  // Monster hit sound
                            addLog(`Magischer Schuss trifft ${monster.name} für ${damage} Schaden!`, 'combat');
                            createParticles(monster.x, monster.y, monster.shieldActive ? '#60a5fa' : proj.color);

                            if (monster.hp <= 0) {
                                sfx.monsterDeath(monster.style, monster.isBoss);  // Monster death sound
                                addLog(`${monster.name} besiegt! +${monster.xp} XP, +${monster.gold} Gold`, 'loot');
                                game.player.xp += monster.xp;
                                game.player.gold += monster.gold;
                                game.monstersKilled++;
                                dropMonsterLoot(monster);

                                game.monsters.splice(m, 1);
                                monster.deathFrame = 0;
                                monster.isDying = true;
                                game.dyingMonsters.push(monster);
                                game.screenShake = 8;

                                checkLevelUp();
                                updateMonsterCount();

                                if (game.monsters.length === 0) {
                                    roomCleared();
                                }
                            }

                            game.projectiles.splice(i, 1);
                            break;
                        }
                    }
                    if (!game.projectiles[i]) continue;
                }

                // Check wall collision
                let hitWall = false;
                for (const wall of game.walls) {
                    if (proj.x > wall.x && proj.x < wall.x + wall.width &&
                        proj.y > wall.y && proj.y < wall.y + wall.height) {
                        hitWall = true;
                        break;
                    }
                }

                if (hitWall || proj.life <= 0 ||
                    proj.x < 0 || proj.x > game.worldWidth ||
                    proj.y < 0 || proj.y > game.worldHeight) {
                    // Create impact particles
                    for (let j = 0; j < 6; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        game.particles.push({
                            x: proj.x,
                            y: proj.y,
                            vx: Math.cos(angle) * 2,
                            vy: Math.sin(angle) * 2,
                            color: proj.color,
                            life: 20,
                            size: 3
                        });
                    }
                    game.projectiles.splice(i, 1);
                }
            }
        }

        // Player death animation
        function startPlayerDeath() {
            // Check for revive
            if (game.player.revivesLeft && game.player.revivesLeft > 0) {
                game.player.revivesLeft--;
                game.player.hp = Math.floor(game.player.maxHp * 0.5);
                game.screenShake = 15;
                sfx.heal();
                addLog(`[REVIVE] Wiederbelebt! (${game.player.revivesLeft} übrig)`, 'heal');

                // Create revival effect
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    game.particles.push({
                        x: game.player.x,
                        y: game.player.y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        color: '#fbbf24',
                        life: 40,
                        size: 4
                    });
                }
                return;
            }

            game.player.isDying = true;
            game.player.deathFrame = 0;
            game.screenShake = 20;
            sfx.playerDeath();  // Player death sound
            addLog('Du bist gestorben!', 'combat');
        }

        function updatePlayerDeath() {
            if (game.player.isDying && !game.gameOverCalled) {
                game.player.deathFrame++;
                // Create death particles
                if (game.player.deathFrame % 3 === 0) {
                    createParticles(game.player.x, game.player.y, '#ef4444');
                }
                if (game.player.deathFrame >= 60) {
                    game.gameOverCalled = true; // Prevent multiple calls
                    gameOver();
                }
            }
        }

        // Update dying monsters
        function updateDyingMonsters() {
            // Limit dying monsters to prevent lag
            const MAX_DYING = 10;
            if (game.dyingMonsters.length > MAX_DYING) {
                game.dyingMonsters.splice(0, game.dyingMonsters.length - MAX_DYING);
            }

            for (let i = game.dyingMonsters.length - 1; i >= 0; i--) {
                const monster = game.dyingMonsters[i];
                monster.deathFrame++;

                // Create death particles with varying intensity (reduced for performance)
                const particleChance = 1 - (monster.deathFrame / 45);
                if (Math.random() < particleChance * 0.25) { // Reduced from 0.5
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 25;
                    const speed = 2 + Math.random() * 3;
                    game.particles.push({
                        x: monster.x + Math.cos(angle) * dist,
                        y: monster.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 1,
                        color: monster.color,
                        life: 25, // Reduced from 35
                        size: Math.random() * 4 + 2
                    });
                }

                // Remove after animation completes
                if (monster.deathFrame >= 45) {
                    game.dyingMonsters.splice(i, 1);
                }
            }
        }

        // Check if there's a clear line of sight (no walls between two points)
        function hasLineOfSight(x1, y1, x2, y2) {
            const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / 10);
            if (steps === 0) return true; // Same position = clear line of sight
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const checkX = x1 + (x2 - x1) * t;
                const checkY = y1 + (y2 - y1) * t;
                if (isInWall(checkX, checkY, 5)) {
                    return false;
                }
            }
            return true;
        }

        function playerAttack() {
            if (game.player.attackCooldown > 0 || game.player.isDying) return;

            // Get weapon properties
            const weapon = game.player.equippedWeapon;
            const weaponRange = weapon ? (weapon.range || 80) : 28; // Faust = 28 (realistisch kurz)
            const weaponSpeed = weapon ? (weapon.speed || 1) : 1;
            const weaponStyle = weapon ? weapon.style : 'sword';

            game.player.attackCooldown = Math.floor(30 * weaponSpeed);

            // Magic Staff - shoots projectile with auto-aim (use shooting animation)
            if (weaponStyle === 'staff' || weaponStyle === 'fire_staff') {
                game.player.isShooting = true;
                game.player.shootFrame = 0;
                game.player.isAttacking = false;
                // Sound effect
                if (weaponStyle === 'fire_staff') {
                    sfx.fireShoot();
                } else {
                    sfx.magicShoot();
                }
                // Find nearest monster for auto-aim
                let target = null;
                let targetDist = 300;  // Max targeting range

                for (const monster of game.monsters) {
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                    if (dist < targetDist) {
                        target = monster;
                        targetDist = dist;
                    }
                }

                // Fire projectile
                let angle;
                if (target) {
                    angle = Math.atan2(target.y - game.player.y, target.x - game.player.x);
                    game.player.facingLeft = target.x < game.player.x;
                } else {
                    // No target - shoot in facing direction
                    angle = game.player.facingLeft ? Math.PI : 0;
                }
                game.player.facingAngle = angle;

                const projColor = weaponStyle === 'fire_staff' ? '#ff6600' : '#c084fc';
                game.projectiles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    color: projColor,
                    damage: game.player.attack,
                    size: 10,
                    life: 120,
                    fromMonster: false,
                    fromPlayer: true,
                    trail: []
                });

                // Staff shoot effect
                for (let i = 0; i < 8; i++) {
                    const pAngle = angle + (Math.random() - 0.5) * 0.5;
                    game.particles.push({
                        x: game.player.x,
                        y: game.player.y,
                        vx: Math.cos(pAngle) * 3,
                        vy: Math.sin(pAngle) * 3,
                        color: projColor,
                        life: 20,
                        size: 3
                    });
                }
                return;
            }

            // Melee attack animation
            game.player.isAttacking = true;
            game.player.attackFrame = 0;

            // Attack sound based on weapon
            if (!weapon) {
                sfx.punch();
            } else {
                sfx.swordSwing();
            }

            // Find closest monster that we can actually hit (line of sight check)
            let closest = null;
            let closestDist = weaponRange;

            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < closestDist) {
                    // Check if there's a wall between player and monster
                    if (hasLineOfSight(game.player.x, game.player.y, monster.x, monster.y)) {
                        closest = monster;
                        closestDist = dist;
                        // Face the monster
                        game.player.facingLeft = monster.x < game.player.x;
                    }
                }
            }

            // Set facing angle for range indicator
            if (closest) {
                game.player.facingAngle = Math.atan2(closest.y - game.player.y, closest.x - game.player.x);
            } else {
                game.player.facingAngle = game.player.facingLeft ? Math.PI : 0;
            }

            if (closest) {
                const totalAttack = game.player.attack + (game.player.attackBoost || 0);
                let damage = Math.max(1, totalAttack - closest.defense);

                // Apply combo multiplier
                damage = Math.floor(damage * getComboMultiplier());

                // Apply berserk multiplier
                damage = Math.floor(damage * getBerserkMultiplier());

                // Apply class passive - Warrior: +20% damage when below 30% HP
                if (game.playerClass === 'warrior' && game.player.hp / game.player.maxHp < 0.3) {
                    damage = Math.floor(damage * 1.2);
                }

                // Apply class passive - Rogue: First attack deals +50% damage
                if (game.playerClass === 'rogue' && !game.player.hasAttacked) {
                    damage = Math.floor(damage * 1.5);
                    game.player.hasAttacked = true;
                    addLog('[HINTERHALT] +50% Schaden!', 'skill');
                }

                // Critical hit check
                const weaponCritBonus = game.player.equippedWeapon?.critBonus || 0;
                const totalCritChance = game.player.critChance + weaponCritBonus + (game.berserkActive ? 0.15 : 0);
                const isCrit = Math.random() < totalCritChance;
                if (isCrit) {
                    damage = Math.floor(damage * game.player.critMultiplier);
                }

                // Boss shield reduces damage by 50%
                if (closest.isBoss && closest.shieldActive) {
                    damage = Math.max(1, Math.floor(damage * 0.5));
                    addLog('[SCHILD] Absorbiert Schaden!', 'combat');
                }
                closest.hp -= damage;
                closest.flashTimer = isCrit ? 20 : 10;

                // Add combo hit
                addComboHit();

                if (isCrit) {
                    game.critCount++; // Track crits for achievement
                    addLog(`💥 KRITISCH! Du triffst ${closest.name} für ${damage} Schaden!`, 'combat');
                    createCritParticles(closest.x, closest.y);
                    game.screenShake = 12;
                    sfx.criticalHit(); // Critical hit impact sound
                } else {
                    addLog(`Du triffst ${closest.name} für ${damage} Schaden!`, 'combat');
                }
                createParticles(closest.x, closest.y, isCrit ? '#fde047' : (closest.shieldActive ? '#60a5fa' : '#fbbf24'));
                createSlashEffect(closest.x, closest.y);

                // Apply status effect from weapon
                if (game.player.equippedWeapon?.statusEffect) {
                    const effect = game.player.equippedWeapon.statusEffect;
                    if (Math.random() < effect.chance) {
                        applyStatusEffect(closest, effect);
                    }
                }

                // Apply poison blade effect (Rogue skill)
                if (game.player.poisonBladeTimer > 0 && game.player.poisonBladeDamage > 0) {
                    closest.poisonTimer = 120;
                    closest.poisonDamage = game.player.poisonBladeDamage;
                    // Green poison particles
                    for (let i = 0; i < 4; i++) {
                        game.particles.push({
                            x: closest.x, y: closest.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -1 - Math.random(),
                            color: '#22c55e', life: 20, size: 3
                        });
                    }
                }

                // Monster hit sound
                sfx.monsterHit(closest.style, closest.isBoss);

                if (closest.hp <= 0) {
                    // Check for Skeleton reassemble ability
                    if (closest.specialAbility === 'reassemble' && !closest.hasReassembled && Math.random() < closest.reassembleChance) {
                        // Skeleton starts reassembling - doesn't die yet!
                        closest.isReassembling = true;
                        closest.reassembleTimer = 90; // 1.5 seconds to reassemble
                        closest.hp = 1; // Keep alive during reassembly
                        closest.hasReassembled = true;
                        addLog(`[UNTOT] ${closest.name} zerfällt... aber die Knochen bewegen sich!`, 'combat');

                        // Create bone fragments that will fly back
                        closest.boneFragments = [];
                        for (let j = 0; j < 8; j++) {
                            const angle = (j / 8) * Math.PI * 2;
                            const dist = 60 + Math.random() * 40;
                            closest.boneFragments.push({
                                x: closest.x + Math.cos(angle) * dist,
                                y: closest.y + Math.sin(angle) * dist,
                                targetX: closest.x,
                                targetY: closest.y,
                                rotation: Math.random() * Math.PI * 2,
                                size: 6 + Math.random() * 4
                            });
                        }
                    } else {
                        // Monster death sound
                        sfx.monsterDeath(closest.style, closest.isBoss);
                        addLog(`${closest.name} besiegt! +${closest.xp} XP, +${closest.gold} Gold`, 'loot');
                        game.player.xp += closest.xp;
                        game.player.gold += closest.gold;
                        game.monstersKilled++;

                        // Track boss/elite kills for achievements
                        if (closest.isBoss) game.bossesKilled++;
                        if (closest.isElite) game.elitesKilled++;

                        // Track berserk kills for daily challenge
                        if (game.berserkActive) game.berserkKills++;

                        // Record kill in bestiary
                        recordMonsterKill(closest.style);

                        // Drop loot
                        dropMonsterLoot(closest);

                        // Move to dying monsters for death animation
                        const index = game.monsters.indexOf(closest);
                        game.monsters.splice(index, 1);
                        closest.deathFrame = 0;
                        closest.isDying = true;
                        game.dyingMonsters.push(closest);
                        game.screenShake = 8;  // Screen shake on kill

                        checkLevelUp();
                        updateMonsterCount();

                        if (game.monsters.length === 0) {
                            roomCleared();
                        }
                    }
                }
            }

            // Also check for breakable walls
            for (const secretWall of game.secretWalls) {
                if (secretWall.hp <= 0) continue;

                const wallCenterX = secretWall.x + secretWall.width / 2;
                const wallCenterY = secretWall.y + secretWall.height / 2;
                const distToWall = Math.hypot(wallCenterX - game.player.x, wallCenterY - game.player.y);

                if (distToWall < weaponRange + 20) {
                    // Damage the wall
                    const wallDamage = Math.floor(game.player.attack * 0.5);
                    secretWall.hp -= wallDamage;

                    // Visual feedback
                    createParticles(wallCenterX, wallCenterY, '#8a8a9a');
                    game.screenShake = 3;

                    if (secretWall.hp <= 0) {
                        // Wall broken!
                        addLog('💥 Die Wand bricht zusammen! Ein geheimer Raum!', 'legendary');
                        sfx.explosion();
                        sfx.secretRoom(); // Mysterious discovery sound
                        game.screenShake = 15;

                        // Create debris particles
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            game.particles.push({
                                x: wallCenterX + (Math.random() - 0.5) * secretWall.width,
                                y: wallCenterY + (Math.random() - 0.5) * secretWall.height,
                                vx: Math.cos(angle) * (2 + Math.random() * 3),
                                vy: Math.sin(angle) * (2 + Math.random() * 3),
                                color: i % 2 === 0 ? '#6a6a7a' : '#4a4a5a',
                                life: 40,
                                size: 4 + Math.random() * 4
                            });
                        }
                    }
                }
            }
        }

        function createSlashEffect(x, y) {
            // Create arc of slash particles
            const baseAngle = Math.atan2(y - game.player.y, x - game.player.x);
            for (let i = 0; i < 12; i++) {
                const angle = baseAngle - Math.PI/4 + (i / 12) * Math.PI/2;
                const speed = Math.random() * 6 + 6;
                const dist = Math.random() * 15 + 10;
                game.particles.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: i % 2 === 0 ? '#fbbf24' : '#ffffff',
                    life: 15,
                    size: Math.random() * 3 + 2
                });
            }

            // Create impact sparks
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                game.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: '#ff4444',
                    life: 20,
                    size: Math.random() * 2 + 1
                });
            }
        }

        function pickupItem() {
            for (let i = game.items.length - 1; i >= 0; i--) {
                const item = game.items[i];
                if (Math.hypot(item.x - game.player.x, item.y - game.player.y) < 30) {
                    // Pickup sparkle effect
                    const color = item.type === 'weapon' ? '#C0C0C0' :
                                  item.type === 'armor' ? '#4169E1' : '#FF1493';
                    for (let j = 0; j < 15; j++) {
                        const angle = (j / 15) * Math.PI * 2;
                        game.particles.push({
                            x: item.x,
                            y: item.y,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3 - 2,
                            color: color,
                            life: 30,
                            size: 3
                        });
                    }

                    // Check if stackable (potions and bombs stack, weapons/armor don't)
                    let stacked = false;
                    if (item.type === 'potion' || item.type === 'bomb') {
                        // Find existing stack of same item
                        const existingStack = game.player.inventory.find(
                            invItem => invItem.name === item.name && invItem.type === item.type
                        );
                        if (existingStack) {
                            existingStack.count = (existingStack.count || 1) + 1;
                            stacked = true;
                        }
                    }

                    if (!stacked) {
                        // Check max inventory limit (5 different items)
                        if (game.player.inventory.length >= 5) {
                            addLog('Inventar voll! (Max 5 Items)', 'combat');
                            return;
                        }
                        item.count = 1;
                        game.player.inventory.push(item);
                    }

                    game.items.splice(i, 1);
                    sfx.itemPickup();  // Item pickup sound
                    addLog(`${item.name} aufgehoben!`, 'loot');
                    updateInventory();
                }
            }
        }

        function useItem(index) {
            if (index >= game.player.inventory.length) return;

            const item = game.player.inventory[index];

            if (item.type === 'potion') {
                // Start drinking animation
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = item.heal;
                game.player.drinkColor = item.heal >= 100 ? '#ff0066' : item.heal >= 50 ? '#ff1493' : '#ff69b4';

                game.player.hp = Math.min(game.player.maxHp, game.player.hp + item.heal);
                sfx.heal();  // Heal sound
                addLog(`${item.name} benutzt! +${item.heal} HP`, 'loot');
                // Reduce stack count
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
            } else if (item.type === 'weapon') {
                // Unequip old weapon if any
                if (game.player.equippedWeapon) {
                    addToInventory(game.player.equippedWeapon);
                }
                // Equip new weapon
                game.player.equippedWeapon = { ...item };
                delete game.player.equippedWeapon.count;
                game.player.attack = game.player.baseAttack + item.attack;
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
                addLog(`${item.name} ausgerüstet! Angriff: ${game.player.attack}`, 'info');
            } else if (item.type === 'armor') {
                // Unequip old armor if any
                if (game.player.equippedArmor) {
                    addToInventory(game.player.equippedArmor);
                }
                // Equip new armor
                game.player.equippedArmor = { ...item };
                delete game.player.equippedArmor.count;
                game.player.defense = game.player.baseDefense + item.defense;
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
                addLog(`${item.name} ausgerüstet! Verteidigung: ${game.player.defense}`, 'info');
            } else if (item.type === 'bomb') {
                // Throw bomb at nearest monster
                if (game.player.abilities.bomb.cooldown > 0) {
                    addLog('Bombe wird noch vorbereitet...', 'info');
                    return;
                }

                // Find nearest monster for targeting
                let target = null;
                let targetDist = 250;
                for (const monster of game.monsters) {
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                    if (dist < targetDist) {
                        target = monster;
                        targetDist = dist;
                    }
                }

                const targetX = target ? target.x : game.player.x + (game.player.facingLeft ? -100 : 100);
                const targetY = target ? target.y : game.player.y;

                sfx.bombThrow();  // Bomb throw sound
                game.bombs.push({
                    x: game.player.x,
                    y: game.player.y,
                    startX: game.player.x,
                    startY: game.player.y,
                    targetX: targetX,
                    targetY: targetY,
                    progress: 0,
                    damage: item.damage || 40,
                    radius: item.damage >= 60 ? 80 : 60,
                    fuseTime: 60,
                    size: 10
                });

                game.player.abilities.bomb.cooldown = game.player.abilities.bomb.maxCooldown;
                addLog(`${item.name} geworfen!`, 'combat');

                // Reduce stack count
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
            }

            updateInventory();
        }

        // Add item to inventory with stacking support
        function addToInventory(item) {
            if (item.type === 'potion' || item.type === 'bomb') {
                const existingStack = game.player.inventory.find(
                    invItem => invItem.name === item.name && invItem.type === item.type
                );
                if (existingStack) {
                    existingStack.count = (existingStack.count || 1) + 1;
                    return;
                }
            }
            item.count = item.count || 1;
            game.player.inventory.push(item);
        }

        // Drop single item from inventory
        function dropItem(index) {
            if (index >= game.player.inventory.length) return;

            const item = game.player.inventory[index];

            // Create dropped item near player
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            const droppedItem = {
                ...item,
                x: game.player.x + Math.cos(angle) * dist,
                y: game.player.y + Math.sin(angle) * dist,
                size: 12,
                animOffset: Math.random() * Math.PI * 2,
                dropAnim: 15,
                dropVy: -3,
                count: undefined
            };
            delete droppedItem.count;

            // Check if position is in wall, find valid nearby position
            if (isInWall(droppedItem.x, droppedItem.y, 10)) {
                let found = false;
                for (let radius = 20; radius <= 80 && !found; radius += 20) {
                    for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                        const testX = game.player.x + Math.cos(a) * radius;
                        const testY = game.player.y + Math.sin(a) * radius;
                        if (!isInWall(testX, testY, 10)) {
                            droppedItem.x = testX;
                            droppedItem.y = testY;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    droppedItem.x = game.player.x;
                    droppedItem.y = game.player.y;
                }
            }

            game.items.push(droppedItem);

            // Reduce stack or remove
            item.count = (item.count || 1) - 1;
            if (item.count <= 0) {
                game.player.inventory.splice(index, 1);
            }

            addLog(`${item.name} fallen gelassen!`, 'info');
            updateInventory();

            // Drop particle effect
            for (let i = 0; i < 8; i++) {
                const pAngle = (i / 8) * Math.PI * 2;
                game.particles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(pAngle) * 2,
                    vy: Math.sin(pAngle) * 2,
                    color: '#888',
                    life: 20,
                    size: 2
                });
            }
        }

        function checkLevelUp() {
            while (game.player.xp >= game.player.xpToNext) {
                game.player.level++;
                game.player.xp -= game.player.xpToNext;
                game.player.xpToNext = Math.floor(game.player.xpToNext * 1.5);

                game.player.maxHp += 20;
                // Erhöhe auch baseAttack/baseDefense, damit Waffen-/Rüstungswechsel die Boni nicht verliert
                game.player.baseAttack += 3;
                game.player.baseDefense += 2;
                // Berechne aktuelle Stats neu (Basis + ausgerüstete Items)
                const weaponBonus = game.player.equippedWeapon ? game.player.equippedWeapon.attack : 0;
                const armorBonus = game.player.equippedArmor ? game.player.equippedArmor.defense : 0;
                game.player.attack = game.player.baseAttack + weaponBonus;
                game.player.defense = game.player.baseDefense + armorBonus;

                // Trigger level-up animation
                game.player.levelUpAnim = 60;
                sfx.levelUp();  // Level up sound

                addLog(`LEVEL UP! Du bist jetzt Level ${game.player.level}!`, 'level');
                // Create burst of golden particles
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    game.particles.push({
                        x: game.player.x,
                        y: game.player.y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        color: '#ffd700',
                        life: 50,
                        size: 4
                    });
                }
            }
        }

        // Update abilities UI
        function updateAbilitiesUI() {
            const section = document.getElementById('abilitiesSection');
            const container = document.getElementById('abilities');
            // Abilities section is hidden - bombs are now items
            container.innerHTML = '';
            section.style.display = 'none';
        }

        // Update bombs
        function updateBombs() {
            // Update ability cooldown
            if (game.player.abilities.bomb.cooldown > 0) {
                game.player.abilities.bomb.cooldown--;
            }

            for (let i = game.bombs.length - 1; i >= 0; i--) {
                const bomb = game.bombs[i];

                // Move bomb in arc
                if (bomb.progress < 1) {
                    bomb.progress += 0.05;
                    const t = bomb.progress;
                    // Parabolic arc
                    bomb.x = lerp(bomb.startX, bomb.targetX, t);
                    bomb.y = lerp(bomb.startY, bomb.targetY, t) - Math.sin(t * Math.PI) * 50;
                }

                bomb.fuseTime--;

                // Explosion
                if (bomb.fuseTime <= 0) {
                    explodeBomb(bomb);
                    game.bombs.splice(i, 1);
                }
            }
        }

        // Bomb explosion - damages through walls!
        function explodeBomb(bomb) {
            const explosionRadius = bomb.radius || 80;
            const bombDamage = bomb.damage || 40;
            game.screenShake = 15;
            sfx.bombExplode();  // Explosion sound

            // Create explosion particles
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 2;
                game.particles.push({
                    x: bomb.x,
                    y: bomb.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: Math.random() > 0.5 ? '#ff6600' : '#ffcc00',
                    life: 40,
                    size: Math.random() * 6 + 3
                });
            }

            // Damage monsters in radius (ignores walls!)
            for (let i = game.monsters.length - 1; i >= 0; i--) {
                const monster = game.monsters[i];
                const dist = Math.hypot(monster.x - bomb.x, monster.y - bomb.y);

                if (dist < explosionRadius) {
                    const damage = Math.floor(bombDamage * (1 - dist / explosionRadius));
                    monster.hp -= damage;
                    monster.flashTimer = 10;
                    addLog(`Explosion trifft ${monster.name} für ${damage} Schaden!`, 'combat');

                    if (monster.hp <= 0) {
                        addLog(`${monster.name} besiegt! +${monster.xp} XP, +${monster.gold} Gold`, 'loot');
                        game.player.xp += monster.xp;
                        game.player.gold += monster.gold;
                        game.monstersKilled++;
                        dropMonsterLoot(monster);

                        game.monsters.splice(i, 1);
                        monster.deathFrame = 0;
                        monster.isDying = true;
                        game.dyingMonsters.push(monster);

                        checkLevelUp();
                        updateMonsterCount();

                        if (game.monsters.length === 0) {
                            roomCleared();
                        }
                    }
                }
            }
        }

        function roomCleared() {
            game.roomsCleared++;

            // Check no-hit achievement for floor 1
            if (game.currentRoom === 1 && game.player.hp === game.player.maxHp) {
                unlockAchievement('noHit');
            }

            // Mark current section as cleared
            if (game.subRooms && game.subRooms[game.currentSubRoom]) {
                game.subRooms[game.currentSubRoom].cleared = true;
            }

            // In connected room system, exit door opens when ALL monsters are dead
            if (game.monsters.length === 0) {
                const exitDoor = game.doors.find(d => d.isExit);
                if (exitDoor) {
                    exitDoor.active = true;
                    exitDoor.openAnim = 0;
                }
                game.floorCleared = true;

                sfx.doorOpen();

                if (game.currentRoom % 10 === 0) {
                    addLog('🎉 BOSS BESIEGT! Weiter zum nächsten Abschnitt! 🎉', 'level');
                } else {
                    addLog('🎉 Etage gesäubert! Exit-Tür geöffnet! 🎉', 'level');
                }
            } else {
                addLog('Raum gesäubert! Tür geöffnet!', 'info');
            }
        }

        function nextRoom() {
            // Start room transition
            game.roomTransition = 30;
            game.doorCooldown = 30; // Prevent instant door re-trigger

            game.currentRoom++;

            // Clear dying monsters from previous room
            game.dyingMonsters = [];

            // generateFloor() sets player position to top of world
            generateRoom();

            // Reset camera to follow player
            updateCamera();

            // Activate spawn protection (5 sec for level 1, 3 sec otherwise)
            const protectionTime = game.currentRoom === 1 ? 300 : 180;
            game.player.spawnProtection = protectionTime;
            sfx.newRoom();  // New room sound
            addLog(`[SCHUTZ] Spawn-Schutz aktiv (${protectionTime / 60} Sek.)`, 'info');

            // Note: Monsters and items are spawned by generateFloor()

            if (game.currentRoom % 10 === 0) {
                addLog(`>>> LEVEL ${game.currentRoom} - BOSS ARENA <<<`, 'combat');
                game.screenShake = 15;  // Dramatic shake for boss room
            } else {
                addLog(`Level ${game.currentRoom} betreten!`, 'info');
            }
            document.getElementById('currentRoom').textContent = game.currentRoom;
        }

        function gameWon() {
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.querySelector('h2').textContent = '🎉 SIEG! 🎉';
            gameOverDiv.querySelector('h2').style.color = '#4ade80';
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('roomsCleared').textContent = game.roomsCleared;
            document.getElementById('monstersKilled').textContent = game.monstersKilled;
            document.getElementById('totalGold').textContent = game.player.gold;
            gameOverDiv.style.display = 'block';
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color,
                    life: 40,
                    size: Math.random() * 3 + 1
                });
            }
        }

        // Special particles for critical hits
        function createCritParticles(x, y) {
            // Larger golden/white particles
            for (let i = 0; i < 25; i++) {
                const angle = (i / 25) * Math.PI * 2;
                const speed = Math.random() * 8 + 4;
                game.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: i % 3 === 0 ? '#ffffff' : (i % 3 === 1 ? '#fde047' : '#f59e0b'),
                    life: 50,
                    size: Math.random() * 5 + 3
                });
            }
            // Add "KRIT" text particle
            game.particles.push({
                x, y: y - 20,
                vx: 0,
                vy: -2,
                color: '#fde047',
                life: 60,
                size: 0,
                isText: true,
                text: 'KRIT!'
            });
        }

        function updateParticles() {
            // Limit max particles to prevent lag
            const MAX_PARTICLES = 150;
            if (game.particles.length > MAX_PARTICLES) {
                // Remove oldest particles (from start of array)
                game.particles.splice(0, game.particles.length - MAX_PARTICLES);
            }

            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];

                // Apply velocity with smooth deceleration
                p.x += p.vx;
                p.y += p.vy;

                // Apply slight gravity
                p.vy += 0.1;

                // Smooth velocity decay (friction)
                p.vx *= 0.96;
                p.vy *= 0.96;

                // Shrink particle over time
                if (p.size > 0.5) {
                    p.size *= 0.98;
                }

                p.life--;

                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        // Apply status effect to target (monster or player)
        function applyStatusEffect(target, effectTemplate) {
            // Initialize statusEffects array if not exists
            if (!target.statusEffects) target.statusEffects = [];

            // Check if already has this effect type - refresh duration instead of stacking
            const existing = target.statusEffects.find(e => e.type === effectTemplate.type);
            if (existing) {
                existing.duration = effectTemplate.duration;
                return;
            }

            const effect = {
                type: effectTemplate.type,
                damage: effectTemplate.damage || 0,
                duration: effectTemplate.duration,
                tickTimer: 0,
                slowAmount: effectTemplate.slowAmount || 0
            };

            target.statusEffects.push(effect);

            // Log message
            const effectNames = { poison: 'Gift', burn: 'Brennen', freeze: 'Einfrieren' };
            const targetName = target === game.player ? 'Du wurdest' : target.name + ' wurde';
            addLog(`${targetName} mit ${effectNames[effect.type]} belegt!`, 'combat');

            // Apply slow for freeze
            if (effect.type === 'freeze' && effect.slowAmount > 0) {
                target.originalSpeed = target.originalSpeed || target.speed;
                target.speed = target.originalSpeed * effect.slowAmount;
            }
        }

        // Update all status effects
        function updateStatusEffects() {
            // Update player status effects
            updateTargetStatusEffects(game.player);

            // Update monster status effects
            for (const monster of game.monsters) {
                updateTargetStatusEffects(monster);
            }
        }

        function updateTargetStatusEffects(target) {
            if (!target.statusEffects || target.statusEffects.length === 0) return;

            for (let i = target.statusEffects.length - 1; i >= 0; i--) {
                const effect = target.statusEffects[i];

                // Apply damage every 30 frames (0.5 seconds)
                effect.tickTimer++;
                if (effect.tickTimer >= 30 && effect.damage > 0) {
                    effect.tickTimer = 0;

                    if (target === game.player) {
                        game.player.hp = Math.max(0, game.player.hp - effect.damage);
                        game.player.flashTimer = 5;
                        if (game.player.hp <= 0 && !game.player.isDying) {
                            startPlayerDeath();
                        }
                    } else {
                        target.hp -= effect.damage;
                        target.flashTimer = 5;

                        // Create effect particles
                        const colors = { poison: '#22c55e', burn: '#f97316', freeze: '#67e8f9' };
                        for (let p = 0; p < 5; p++) {
                            game.particles.push({
                                x: target.x + (Math.random() - 0.5) * 20,
                                y: target.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -Math.random() * 2,
                                color: colors[effect.type],
                                life: 20,
                                size: 3
                            });
                        }

                        // Check if monster died from DoT
                        if (target.hp <= 0 && !target.isDying) {
                            sfx.monsterDeath(target.style, target.isBoss);
                            addLog(`${target.name} stirbt an ${effect.type === 'poison' ? 'Gift' : 'Feuer'}!`, 'combat');
                            game.player.xp += target.xp;
                            game.player.gold += target.gold;
                            game.monstersKilled++;
                            dropMonsterLoot(target);

                            const index = game.monsters.indexOf(target);
                            if (index > -1) {
                                game.monsters.splice(index, 1);
                                target.deathFrame = 0;
                                target.isDying = true;
                                game.dyingMonsters.push(target);
                            }

                            checkLevelUp();
                            updateMonsterCount();
                            if (game.monsters.length === 0) roomCleared();
                            return; // Stop processing effects for dead monster
                        }
                    }
                }

                // Decrease duration
                effect.duration--;

                // Remove expired effects
                if (effect.duration <= 0) {
                    // Restore speed for freeze
                    if (effect.type === 'freeze' && target.originalSpeed) {
                        target.speed = target.originalSpeed;
                        delete target.originalSpeed;
                    }
                    target.statusEffects.splice(i, 1);
                }
            }
        }

        // ====== SKILL SYSTEM ======

        // Use a skill
        function useSkill(skillName) {
            const skill = game.skills[skillName];
            if (!skill || !skill.unlocked) return false;
            if (skill.cooldown > 0) return false;
            if (game.player.mana < skill.manaCost) {
                addLog(`[MANA] Nicht genug für ${skill.name}!`, 'warning');
                return false;
            }
            if (game.player.isDying) return false;

            // Consume mana and start cooldown
            game.player.mana -= skill.manaCost;
            skill.cooldown = skill.maxCooldown;
            game.skillsUsed++; // Track for daily challenge

            // Execute skill based on execute field (class-specific dispatch)
            const executeType = skill.execute || skillName;
            const skillExecutors = {
                'fireball': executeFireball,
                'heal': executeHeal,
                'shield': executeShield,
                'whirlwind': executeWhirlwind,
                'warcry': executeWarcry,
                'charge': executeCharge,
                'frostnova': executeFrostnova,
                'lightning': executeLightning,
                'knifethrow': executeKnifeThrow,
                'poisonblade': executePoisonBlade,
                'smokebomb': executeSmokeBomb,
                'shadowstep': executeShadowStep
            };
            if (skillExecutors[executeType]) {
                skillExecutors[executeType]();
            }
            return true;
        }

        // Fireball - ranged fire projectile
        function executeFireball() {
            // Find target or shoot in facing direction
            let target = null;
            let targetDist = 400;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < targetDist) {
                    target = monster;
                    targetDist = dist;
                }
            }

            let angle;
            if (target) {
                angle = Math.atan2(target.y - game.player.y, target.x - game.player.x);
            } else {
                angle = game.player.facingLeft ? Math.PI : 0;
            }

            // Calculate damage with mage bonus
            let skillDamage = game.skills.fireball.damage + Math.floor(game.player.level * 2);
            if (game.playerClass === 'mage') {
                skillDamage = Math.floor(skillDamage * 1.3); // +30% skill damage
            }

            // Create large fireball projectile
            game.projectiles.push({
                x: game.player.x,
                y: game.player.y,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                color: '#ff6600',
                damage: skillDamage,
                size: 18,
                life: 90,
                fromMonster: false,
                fromPlayer: true,
                isFireball: true,
                trail: []
            });

            // Fire burst effect
            for (let i = 0; i < 15; i++) {
                const pAngle = angle + (Math.random() - 0.5) * 1;
                game.particles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(pAngle) * (2 + Math.random() * 3),
                    vy: Math.sin(pAngle) * (2 + Math.random() * 3),
                    color: i % 2 === 0 ? '#ff6600' : '#fbbf24',
                    life: 25,
                    size: 4 + Math.random() * 4
                });
            }

            sfx.fireShoot();
            addLog('[SKILL] Feuerball!', 'skill');
        }

        // Heal - restore HP
        function executeHeal() {
            let healAmount = game.skills.heal.healAmount + Math.floor(game.player.level * 3);
            if (game.playerClass === 'mage') {
                healAmount = Math.floor(healAmount * 1.3); // +30% heal for mage
            }
            game.player.hp = Math.min(game.player.maxHp, game.player.hp + healAmount);

            // Healing particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 30;
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * dist,
                    y: game.player.y + Math.sin(angle) * dist,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -2 - Math.random() * 2,
                    color: i % 2 === 0 ? '#22c55e' : '#86efac',
                    life: 40,
                    size: 4 + Math.random() * 3
                });
            }

            // Healing ring effect
            game.skillEffects.push({
                type: 'healRing',
                x: game.player.x,
                y: game.player.y,
                radius: 0,
                maxRadius: 50,
                life: 30
            });

            sfx.heal();
            addLog(`[SKILL] Heilung! +${healAmount} HP`, 'skill');
        }

        // Shield - temporary defense boost
        function executeShield() {
            game.shieldActive = true;
            game.shieldTimer = game.skills.shield.duration;

            // Shield activation particles
            for (let i = 0; i < 25; i++) {
                const angle = (i / 25) * Math.PI * 2;
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * 35,
                    y: game.player.y + Math.sin(angle) * 35,
                    vx: Math.cos(angle) * 1.5,
                    vy: Math.sin(angle) * 1.5,
                    color: i % 2 === 0 ? '#60a5fa' : '#93c5fd',
                    life: 30,
                    size: 5
                });
            }

            sfx.powerUp();
            addLog('[SKILL] Schild aktiviert!', 'skill');
        }

        // Whirlwind - AoE damage around player
        function executeWhirlwind() {
            let damage = game.skills.whirlwind.damage + Math.floor(game.player.level * 1.5);
            if (game.playerClass === 'mage') {
                damage = Math.floor(damage * 1.3); // +30% skill damage for mage
            }
            const radius = game.skills.whirlwind.radius;

            // Damage all monsters in radius
            let hitCount = 0;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist <= radius) {
                    const actualDamage = Math.max(1, damage - (monster.defense || 0));
                    monster.hp -= actualDamage;
                    hitCount++;

                    // Push monsters back
                    const angle = Math.atan2(monster.y - game.player.y, monster.x - game.player.x);
                    monster.x += Math.cos(angle) * 30;
                    monster.y += Math.sin(angle) * 30;

                    // Hit effect
                    for (let i = 0; i < 5; i++) {
                        game.particles.push({
                            x: monster.x,
                            y: monster.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            color: '#fbbf24',
                            life: 20,
                            size: 3
                        });
                    }
                }
            }

            // Whirlwind visual effect
            game.skillEffects.push({
                type: 'whirlwind',
                x: game.player.x,
                y: game.player.y,
                radius: 0,
                maxRadius: radius,
                life: 20,
                rotation: 0
            });

            // Swirl particles
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const dist = 20 + (i / 30) * (radius - 20);
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * dist,
                    y: game.player.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle + Math.PI/2) * 3,
                    vy: Math.sin(angle + Math.PI/2) * 3,
                    color: i % 3 === 0 ? '#fbbf24' : (i % 3 === 1 ? '#f59e0b' : '#d97706'),
                    life: 25,
                    size: 4
                });
            }

            sfx.explosion();
            if (hitCount > 0) {
                addLog(`[SKILL] Wirbelwind! ${hitCount} Treffer!`, 'skill');
            } else {
                addLog('[SKILL] Wirbelwind!', 'skill');
            }
        }

        // ====== WARRIOR SKILLS ======

        // Warcry - boost attack for duration
        function executeWarcry() {
            const skill = game.skills.heal;
            const boost = skill.atkBoost || 8;
            const duration = skill.duration || 300;
            game.player.warcryBoost = boost;
            game.player.warcryTimer = duration;
            game.player.attack += boost;

            // Shout ring effect
            game.skillEffects.push({
                type: 'warcryRing',
                x: game.player.x,
                y: game.player.y,
                radius: 0,
                maxRadius: 80,
                life: 25
            });

            // Red rage particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * 20,
                    y: game.player.y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 2,
                    vy: -2 - Math.random() * 2,
                    color: i % 2 === 0 ? '#ef4444' : '#fbbf24',
                    life: 35,
                    size: 4 + Math.random() * 3
                });
            }

            sfx.powerUp();
            addLog(`[SKILL] Kampfschrei! +${boost} Angriff für ${Math.floor(duration/60)}s`, 'skill');
        }

        // Charge - dash forward and deal damage
        function executeCharge() {
            const skill = game.skills.whirlwind;
            let damage = (skill.damage || 40) + Math.floor(game.player.level * 2);
            const chargeDir = game.player.facingLeft ? -1 : 1;
            const chargeDist = 150;

            // Move player forward
            const startX = game.player.x;
            game.player.x += chargeDir * chargeDist;

            // Clamp to room bounds
            game.player.x = Math.max(50, Math.min(game.player.x, 850));

            // Damage monsters in charge path
            let hitCount = 0;
            for (const monster of game.monsters) {
                const inPath = chargeDir > 0 ?
                    (monster.x >= startX && monster.x <= game.player.x) :
                    (monster.x <= startX && monster.x >= game.player.x);
                const yClose = Math.abs(monster.y - game.player.y) < 40;
                if (inPath && yClose) {
                    const actualDamage = Math.max(1, damage - (monster.defense || 0));
                    monster.hp -= actualDamage;
                    monster.flashTimer = 8;
                    hitCount++;
                    // Knockback
                    monster.x += chargeDir * 40;
                    for (let i = 0; i < 5; i++) {
                        game.particles.push({
                            x: monster.x, y: monster.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            color: '#ef4444', life: 20, size: 3
                        });
                    }
                }
            }

            // Trail particles
            const trailLen = Math.abs(game.player.x - startX);
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x: startX + chargeDir * (Math.random() * trailLen),
                    y: game.player.y + (Math.random() - 0.5) * 20,
                    vx: -chargeDir * Math.random() * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: i % 2 === 0 ? '#fbbf24' : '#ef4444',
                    life: 20, size: 4
                });
            }

            sfx.explosion();
            addLog(`[SKILL] Ansturm! ${hitCount} Treffer!`, 'skill');
        }

        // ====== MAGE SKILLS ======

        // Frost Nova - AoE freeze around player
        function executeFrostnova() {
            const skill = game.skills.shield;
            let damage = (skill.damage || 15) + Math.floor(game.player.level * 1);
            if (game.playerClass === 'mage') damage = Math.floor(damage * 1.3);
            const radius = skill.radius || 130;
            const slowDur = skill.slowDuration || 180;

            let hitCount = 0;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist <= radius) {
                    const actualDamage = Math.max(1, damage - (monster.defense || 0));
                    monster.hp -= actualDamage;
                    monster.flashTimer = 8;
                    hitCount++;
                    // Freeze the monster
                    if (!monster.originalSpeed) monster.originalSpeed = monster.speed;
                    monster.speed = monster.originalSpeed * 0.3;
                    monster.frozenTimer = slowDur;
                    // Ice particles
                    for (let i = 0; i < 4; i++) {
                        game.particles.push({
                            x: monster.x, y: monster.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -1 - Math.random() * 2,
                            color: i % 2 === 0 ? '#93c5fd' : '#bfdbfe',
                            life: 30, size: 4
                        });
                    }
                }
            }

            // Frost nova ring effect
            game.skillEffects.push({
                type: 'frostnovaRing',
                x: game.player.x,
                y: game.player.y,
                radius: 0,
                maxRadius: radius,
                life: 25
            });

            // Ice crystal particles
            for (let i = 0; i < 25; i++) {
                const angle = (i / 25) * Math.PI * 2;
                const dist = 20 + Math.random() * (radius - 20);
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * dist,
                    y: game.player.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * 1,
                    vy: -1 - Math.random() * 1.5,
                    color: i % 3 === 0 ? '#60a5fa' : (i % 3 === 1 ? '#93c5fd' : '#dbeafe'),
                    life: 35, size: 3 + Math.random() * 3
                });
            }

            sfx.explosion();
            addLog(`[SKILL] Frostnova! ${hitCount} eingefroren!`, 'skill');
        }

        // Lightning - chain lightning that jumps between enemies
        function executeLightning() {
            const skill = game.skills.whirlwind;
            let damage = (skill.damage || 22) + Math.floor(game.player.level * 1.5);
            if (game.playerClass === 'mage') damage = Math.floor(damage * 1.3);
            const maxChains = skill.chains || 3;

            // Find nearest monster
            let target = null;
            let minDist = 300;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < minDist) {
                    target = monster;
                    minDist = dist;
                }
            }

            if (!target) {
                addLog('[SKILL] Kein Ziel für Blitzschlag!', 'warning');
                return;
            }

            const hitMonsters = [];
            let currentSource = { x: game.player.x, y: game.player.y };
            let currentTarget = target;
            let chainDamage = damage;

            for (let chain = 0; chain < maxChains && currentTarget; chain++) {
                const actualDamage = Math.max(1, chainDamage - (currentTarget.defense || 0));
                currentTarget.hp -= actualDamage;
                currentTarget.flashTimer = 8;
                hitMonsters.push(currentTarget);

                // Lightning bolt visual between source and target
                game.skillEffects.push({
                    type: 'lightningBolt',
                    x1: currentSource.x, y1: currentSource.y,
                    x2: currentTarget.x, y2: currentTarget.y,
                    life: 15
                });

                // Spark particles at hit point
                for (let i = 0; i < 6; i++) {
                    game.particles.push({
                        x: currentTarget.x, y: currentTarget.y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        color: i % 2 === 0 ? '#fbbf24' : '#60a5fa',
                        life: 15, size: 3
                    });
                }

                // Find next chain target
                currentSource = { x: currentTarget.x, y: currentTarget.y };
                chainDamage = Math.floor(chainDamage * 0.7);
                let nextTarget = null;
                let nextDist = 200;
                for (const monster of game.monsters) {
                    if (hitMonsters.includes(monster)) continue;
                    const dist = Math.hypot(monster.x - currentSource.x, monster.y - currentSource.y);
                    if (dist < nextDist) {
                        nextTarget = monster;
                        nextDist = dist;
                    }
                }
                currentTarget = nextTarget;
            }

            sfx.fireShoot();
            addLog(`[SKILL] Blitzschlag! ${hitMonsters.length} Treffer!`, 'skill');
        }

        // ====== ROGUE SKILLS ======

        // Knife Throw - fast projectile
        function executeKnifeThrow() {
            const skill = game.skills.fireball;
            let damage = (skill.damage || 18) + Math.floor(game.player.level * 1.5);

            // Aim at nearest monster or facing direction
            let target = null;
            let targetDist = 400;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < targetDist) {
                    target = monster;
                    targetDist = dist;
                }
            }

            let angle;
            if (target) {
                angle = Math.atan2(target.y - game.player.y, target.x - game.player.x);
            } else {
                angle = game.player.facingLeft ? Math.PI : 0;
            }

            // Throw 3 knives in a fan
            for (let i = -1; i <= 1; i++) {
                const knifeAngle = angle + i * 0.15;
                game.projectiles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(knifeAngle) * 12,
                    vy: Math.sin(knifeAngle) * 12,
                    color: '#94a3b8',
                    damage: damage,
                    size: 8,
                    life: 50,
                    fromMonster: false,
                    fromPlayer: true,
                    isKnife: true,
                    trail: []
                });
            }

            sfx.fireShoot();
            addLog('[SKILL] Messerwurf!', 'skill');
        }

        // Poison Blade - next attacks apply poison
        function executePoisonBlade() {
            const skill = game.skills.heal;
            const poisonDmg = skill.damage || 5;
            const duration = skill.duration || 240;

            game.player.poisonBladeTimer = duration;
            game.player.poisonBladeDamage = poisonDmg;

            // Poison drip particles on player
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x: game.player.x + (Math.random() - 0.5) * 20,
                    y: game.player.y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 1,
                    vy: 1 + Math.random() * 2,
                    color: i % 3 === 0 ? '#22c55e' : (i % 3 === 1 ? '#16a34a' : '#86efac'),
                    life: 30, size: 3 + Math.random() * 2
                });
            }

            sfx.powerUp();
            addLog(`[SKILL] Giftklinge aktiviert! ${Math.floor(duration/60)}s`, 'skill');
        }

        // Smoke Bomb - become invisible, enemies lose aggro
        function executeSmokeBomb() {
            const skill = game.skills.shield;
            const duration = skill.duration || 180;

            game.player.smokeTimer = duration;
            game.player.isInvisible = true;

            // Smoke cloud effect
            game.skillEffects.push({
                type: 'smokeCloud',
                x: game.player.x,
                y: game.player.y,
                radius: 0,
                maxRadius: 60,
                life: 40
            });

            // Smoke particles
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40;
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * dist,
                    y: game.player.y + Math.sin(angle) * dist,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -1 - Math.random() * 1.5,
                    color: i % 3 === 0 ? '#6b7280' : (i % 3 === 1 ? '#9ca3af' : '#d1d5db'),
                    life: 40, size: 6 + Math.random() * 5
                });
            }

            // Reset monster aggro
            for (const monster of game.monsters) {
                monster.targetPlayer = false;
                monster.chasing = false;
            }

            sfx.powerUp();
            addLog(`[SKILL] Rauchbombe! Unsichtbar für ${Math.floor(duration/60)}s`, 'skill');
        }

        // Shadow Step - teleport behind nearest enemy and backstab
        function executeShadowStep() {
            const skill = game.skills.whirlwind;
            let damage = (skill.damage || 30) + Math.floor(game.player.level * 2);

            // Find nearest monster
            let target = null;
            let minDist = 300;
            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < minDist) {
                    target = monster;
                    minDist = dist;
                }
            }

            if (!target) {
                addLog('[SKILL] Kein Ziel für Schattenschritt!', 'warning');
                return;
            }

            // Shadow trail from old position
            const oldX = game.player.x;
            const oldY = game.player.y;
            for (let i = 0; i < 10; i++) {
                game.particles.push({
                    x: oldX + (Math.random() - 0.5) * 20,
                    y: oldY + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: '#7c3aed',
                    life: 25, size: 5
                });
            }

            // Teleport behind target
            const behindX = target.x + (target.x > game.player.x ? 25 : -25);
            game.player.x = Math.max(50, Math.min(behindX, 850));
            game.player.y = target.y;

            // Deal backstab damage (crit guaranteed)
            const backstabDamage = Math.max(1, Math.floor(damage * 1.5) - (target.defense || 0));
            target.hp -= backstabDamage;
            target.flashTimer = 10;

            // Arrival particles
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                game.particles.push({
                    x: game.player.x + Math.cos(angle) * 15,
                    y: game.player.y + Math.sin(angle) * 15,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    color: i % 2 === 0 ? '#7c3aed' : '#a78bfa',
                    life: 20, size: 4
                });
            }

            sfx.explosion();
            addLog(`[SKILL] Schattenschritt! ${backstabDamage} Schaden!`, 'skill');
        }

        // Update skill cooldowns and effects
        function updateSkills() {
            // Update cooldowns
            for (const skillName in game.skills) {
                if (game.skills[skillName].cooldown > 0) {
                    game.skills[skillName].cooldown--;
                }
            }

            // Regenerate mana
            if (game.player.mana < game.player.maxMana) {
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + game.player.manaRegen);
            }

            // Update shield
            if (game.shieldActive) {
                game.shieldTimer--;
                if (game.shieldTimer <= 0) {
                    game.shieldActive = false;
                    addLog('[INFO] Schild deaktiviert', 'info');
                }
            }

            // Update warcry timer
            if (game.player.warcryTimer > 0) {
                game.player.warcryTimer--;
                if (game.player.warcryTimer <= 0) {
                    game.player.attack -= (game.player.warcryBoost || 0);
                    game.player.warcryBoost = 0;
                    addLog('[INFO] Kampfschrei beendet', 'info');
                }
            }

            // Update poison blade timer
            if (game.player.poisonBladeTimer > 0) {
                game.player.poisonBladeTimer--;
                if (game.player.poisonBladeTimer <= 0) {
                    game.player.poisonBladeDamage = 0;
                    addLog('[INFO] Giftklinge beendet', 'info');
                }
            }

            // Update smoke bomb / invisibility timer
            if (game.player.smokeTimer > 0) {
                game.player.smokeTimer--;
                if (game.player.smokeTimer <= 0) {
                    game.player.isInvisible = false;
                    addLog('[INFO] Unsichtbarkeit beendet', 'info');
                }
            }

            // Update skill effects
            for (let i = game.skillEffects.length - 1; i >= 0; i--) {
                const effect = game.skillEffects[i];
                effect.life--;

                if (effect.type === 'healRing') {
                    effect.radius += (effect.maxRadius - effect.radius) * 0.2;
                } else if (effect.type === 'whirlwind') {
                    effect.radius = effect.maxRadius * (1 - effect.life / 20);
                    effect.rotation += 0.3;
                } else if (effect.type === 'warcryRing' || effect.type === 'frostnovaRing') {
                    effect.radius = effect.maxRadius * (1 - effect.life / 25);
                } else if (effect.type === 'smokeCloud') {
                    effect.radius = effect.maxRadius * (1 - effect.life / 40);
                } else if (effect.type === 'lightningBolt') {
                    // Lightning fades naturally
                }

                if (effect.life <= 0) {
                    game.skillEffects.splice(i, 1);
                }
            }

            // Check skill key presses
            if (game.keys.q && !game.player.isDying) {
                useSkill('fireball');
                game.keys.q = false;
            }
            if (game.keys.r && !game.player.isDying) {
                useSkill('heal');
                game.keys.r = false;
            }
            if (game.keys.f && !game.player.isDying) {
                useSkill('shield');
                game.keys.f = false;
            }
            if (game.keys.c && !game.player.isDying) {
                useSkill('whirlwind');
                game.keys.c = false;
            }
        }

        // Execute dash ability (Shift key)
        function executeDash() {
            // Get movement direction
            let dx = 0, dy = 0;
            if (game.keys.w || game.keys.ArrowUp) dy -= 1;
            if (game.keys.s || game.keys.ArrowDown) dy += 1;
            if (game.keys.a || game.keys.ArrowLeft) dx -= 1;
            if (game.keys.d || game.keys.ArrowRight) dx += 1;

            // If no direction, dash in facing direction
            if (dx === 0 && dy === 0) {
                dx = game.player.facingLeft ? -1 : 1;
            }

            // Normalize
            const len = Math.hypot(dx, dy);
            if (len > 0) {
                dx /= len;
                dy /= len;
            }

            game.player.isDashing = true;
            game.player.dashTimer = 12; // 12 frames of dash
            game.player.dashDirection = { x: dx, y: dy };
            game.player.dashCooldown = game.player.dashMaxCooldown;
            game.player.spawnProtection = Math.max(game.player.spawnProtection, 12); // Invulnerable during dash
            sfx.dash(); // Dash whoosh sound

            // Initial burst particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                game.particles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(angle) * speed - dx * 2,
                    vy: Math.sin(angle) * speed - dy * 2,
                    color: i % 2 === 0 ? '#60a5fa' : '#93c5fd',
                    life: 25,
                    size: 3 + Math.random() * 3
                });
            }

            // Speed lines in dash direction
            for (let i = 0; i < 8; i++) {
                const offset = (Math.random() - 0.5) * 30;
                game.particles.push({
                    x: game.player.x - dx * 20 + dy * offset,
                    y: game.player.y - dy * 20 - dx * offset,
                    vx: -dx * 8,
                    vy: -dy * 8,
                    color: '#ffffff',
                    life: 8,
                    size: 2,
                    isSpeedLine: true
                });
            }

            addLog('[DASH] Ausweichen!', 'info');
        }

        // Update player abilities (cooldowns, dash movement)
        function updatePlayerAbilities() {
            // Decrease cooldowns
            if (game.player.dashCooldown > 0) game.player.dashCooldown--;

            // Handle dash movement
            if (game.player.isDashing && game.player.dashTimer > 0) {
                const dashSpeed = 12;
                const newX = game.player.x + game.player.dashDirection.x * dashSpeed;
                const newY = game.player.y + game.player.dashDirection.y * dashSpeed;

                // Create afterimage before moving
                if (game.player.dashTimer % 2 === 0) {
                    game.dashAfterimages.push({
                        x: game.player.x,
                        y: game.player.y,
                        facingLeft: game.player.facingLeft,
                        alpha: 0.7,
                        scale: 1.0
                    });
                }

                // Check wall collision
                let canMove = true;
                for (const wall of game.walls) {
                    if (newX - 10 < wall.x + wall.width && newX + 10 > wall.x &&
                        newY - 10 < wall.y + wall.height && newY + 10 > wall.y) {
                        canMove = false;
                        break;
                    }
                }

                if (canMove) {
                    game.player.x = Math.max(20, Math.min(game.worldWidth - 20, newX));
                    game.player.y = Math.max(20, Math.min(game.worldHeight - 20, newY));
                }

                game.player.dashTimer--;

                // Trail particles with varying sizes
                for (let i = 0; i < 3; i++) {
                    game.particles.push({
                        x: game.player.x + (Math.random() - 0.5) * 10,
                        y: game.player.y + (Math.random() - 0.5) * 10,
                        vx: -game.player.dashDirection.x * (1 + Math.random()),
                        vy: -game.player.dashDirection.y * (1 + Math.random()),
                        color: i === 0 ? '#60a5fa' : '#93c5fd',
                        life: 12 + Math.random() * 8,
                        size: 3 + Math.random() * 4
                    });
                }

                if (game.player.dashTimer <= 0) {
                    game.player.isDashing = false;
                    // End burst
                    for (let i = 0; i < 8; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        game.particles.push({
                            x: game.player.x,
                            y: game.player.y,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3,
                            color: '#60a5fa',
                            life: 15,
                            size: 4
                        });
                    }
                }
            }

            // Update dash afterimages
            for (let i = game.dashAfterimages.length - 1; i >= 0; i--) {
                const img = game.dashAfterimages[i];
                img.alpha -= 0.12;
                img.scale -= 0.02;
                if (img.alpha <= 0) {
                    game.dashAfterimages.splice(i, 1);
                }
            }

            // Combo system - decrease timer
            if (game.comboTimer > 0) {
                game.comboTimer--;
                if (game.comboTimer <= 0) {
                    game.comboCount = 0;  // Reset combo when timer expires
                }
            }

            // Berserk mode check and update
            const hpPercent = game.player.hp / game.player.maxHp;
            if (hpPercent <= 0.25 && !game.berserkActive) {
                // Activate berserk mode when HP drops below 25%
                game.berserkActive = true;
                game.berserkTimer = 600; // 10 seconds
                addLog('>>> BERSERK MODUS AKTIVIERT! <<<', 'level');
                game.screenShake = 15;
            }

            if (game.berserkActive) {
                game.berserkTimer--;
                if (game.berserkTimer <= 0 || hpPercent > 0.25) {
                    game.berserkActive = false;
                    if (hpPercent > 0.25) {
                        addLog('Berserk-Modus beendet', 'info');
                    }
                }
            }
        }

        // Update traps
        function updateTraps() {
            for (const trap of game.traps) {
                trap.timer++;

                // Check if player is on trap
                const playerOnTrap = Math.hypot(game.player.x - trap.x, game.player.y - trap.y) < trap.size;

                // Warning phase
                if (trap.timer >= trap.cooldown - trap.warningTime && trap.timer < trap.cooldown) {
                    trap.warning = true;
                }

                // Activation phase
                if (trap.timer >= trap.cooldown) {
                    // Aktiviere Falle und setze hitApplied zurück beim ersten Frame
                    if (!trap.active) {
                        trap.active = true;
                        trap.hitApplied = false; // Reset für neue Aktivierung
                    }
                    trap.warning = false;

                    // Schaden nur EINMAL pro Aktivierung anwenden
                    if (playerOnTrap && game.player.spawnProtection <= 0 && !trap.hitApplied) {
                        trap.hitApplied = true; // Verhindert mehrfachen Schaden

                        // Apply trap effect
                        switch (trap.type) {
                            case 'spikes':
                            case 'fire':
                                const trapShieldBonus = game.shieldActive ? 15 : 0;
                                const damage = Math.max(1, trap.damage - game.player.defense - trapShieldBonus);
                                game.player.hp -= damage;
                                game.player.flashTimer = 15;
                                game.screenShake = 5;
                                sfx.playerHit();
                                addLog(`[FALLE] ${trap.type === 'spikes' ? 'Stacheln' : 'Feuer'}! ${damage} Schaden!`, 'combat');
                                break;
                            case 'poison':
                                if (!game.player.statusEffects.find(e => e.type === 'poison')) {
                                    game.player.statusEffects.push({
                                        type: 'poison',
                                        damage: trap.damage,
                                        duration: trap.duration,
                                        tickTimer: 0
                                    });
                                    addLog('[GIFT] Vergiftet!', 'combat');
                                }
                                break;
                            case 'ice':
                                if (!game.player.statusEffects.find(e => e.type === 'freeze')) {
                                    game.player.statusEffects.push({
                                        type: 'freeze',
                                        slowAmount: trap.slowAmount,
                                        duration: trap.duration,
                                        tickTimer: 0
                                    });
                                    addLog('[FROST] Eingefroren!', 'combat');
                                }
                                break;
                        }
                        if (game.player.hp <= 0) startPlayerDeath();
                    }

                    // Monster-Schaden von Fallen
                    for (const monster of game.monsters) {
                        if (monster.isFalling || monster.hp <= 0) continue;
                        const monsterOnTrap = Math.hypot(monster.x - trap.x, monster.y - trap.y) < trap.size + (monster.size || 15);
                        if (monsterOnTrap && !trap['monsterHit_' + (monster.id || monster.name)]) {
                            trap['monsterHit_' + (monster.id || monster.name)] = true;
                            const trapDmg = trap.damage || 10;
                            const monsterDef = monster.defense || 0;
                            const dmg = Math.max(1, trapDmg - Math.floor(monsterDef / 2));
                            monster.hp -= dmg;
                            monster.flashTimer = 10;

                            // Eis verlangsamt Monster
                            if (trap.type === 'ice' && monster.speed) {
                                monster.originalSpeed = monster.originalSpeed || monster.speed;
                                monster.speed = monster.originalSpeed * 0.4;
                                monster.frozenTimer = (trap.duration || 120);
                            }
                            // Gift schadet über Zeit
                            if (trap.type === 'poison') {
                                monster.poisonTimer = trap.duration || 120;
                                monster.poisonDamage = trap.damage || 5;
                            }
                        }
                    }

                    // Deactivate after a short time
                    if (trap.timer >= trap.cooldown + 30) {
                        trap.timer = 0;
                        trap.active = false;
                        trap.hitApplied = false;
                        // Reset monster hit flags
                        for (const key of Object.keys(trap)) {
                            if (key.startsWith('monsterHit_')) delete trap[key];
                        }
                    }
                }
            }
        }

        // Update Void-Zonen (Abgrund an den Seiten)
        function updateVoid() {
            if (!game.voidZones || game.voidZones.length === 0) return;

            // Prüfe ob Spieler ins Void fällt
            for (const void_ of game.voidZones) {
                if (game.player.x > void_.x && game.player.x < void_.x + void_.width &&
                    game.player.y > void_.y && game.player.y < void_.y + void_.height) {

                    // Spieler fällt! Starte Fall-Animation wenn nicht bereits fallend
                    if (!game.player.isFalling) {
                        game.player.isFalling = true;
                        game.player.fallProgress = 0;
                        game.player.fallStartX = game.player.x;
                        game.player.fallStartY = game.player.y;
                        sfx.playerHit();
                        addLog('[ABGRUND] Du fällst!', 'combat');
                    }
                }
            }

            // Update Fall-Animation für Spieler
            if (game.player.isFalling) {
                game.player.fallProgress += 0.03; // 33 Frames bis zum Ende

                if (game.player.fallProgress >= 1) {
                    // Fall abgeschlossen - Schaden und Respawn
                    game.player.isFalling = false;
                    const fallDamage = Math.floor(game.player.maxHp * 0.15); // 15% Max HP
                    game.player.hp = Math.max(1, game.player.hp - fallDamage);
                    game.player.flashTimer = 30;
                    game.screenShake = 15;

                    // Respawn in sicherer Position (Mitte des aktuellen Raums)
                    const currentRoom = game.subRooms[game.currentSubRoom] || { y: 0, height: 500 };
                    game.player.x = game.worldWidth / 2;
                    game.player.y = currentRoom.y + currentRoom.height / 2;

                    addLog(`[ABGRUND] ${fallDamage} Schaden vom Fall!`, 'combat');
                    if (game.player.hp <= 0) startPlayerDeath();
                }
            }

            // Prüfe ob Items ins Void fallen
            for (let i = game.items.length - 1; i >= 0; i--) {
                const item = game.items[i];
                for (const void_ of game.voidZones) {
                    if (item.x > void_.x && item.x < void_.x + void_.width &&
                        item.y > void_.y && item.y < void_.y + void_.height) {

                        // Item fällt - starte Animation oder entferne
                        if (!item.isFalling) {
                            item.isFalling = true;
                            item.fallProgress = 0;
                        } else {
                            item.fallProgress += 0.05;
                            if (item.fallProgress >= 1) {
                                // Item ist weg
                                game.items.splice(i, 1);
                            }
                        }
                        break;
                    }
                }
            }

            // Prüfe ob Monster ins Void fallen (z.B. durch Knockback)
            for (const monster of game.monsters) {
                for (const void_ of game.voidZones) {
                    if (monster.x > void_.x && monster.x < void_.x + void_.width &&
                        monster.y > void_.y && monster.y < void_.y + void_.height) {

                        if (!monster.isFalling) {
                            monster.isFalling = true;
                            monster.fallProgress = 0;
                        } else {
                            monster.fallProgress += 0.04;
                            if (monster.fallProgress >= 1) {
                                // Monster stirbt
                                monster.hp = 0;
                            }
                        }
                    }
                }
            }
        }

        // Add combo hit
        function addComboHit() {
            game.comboCount++;
            game.comboTimer = game.maxComboTime;

            // Bonus damage message at milestones
            if (game.comboCount === 5) addLog('[COMBO] 5er Combo!', 'loot');
            if (game.comboCount === 10) addLog('[COMBO] 10er Combo!', 'level');
            if (game.comboCount === 20) addLog('>>> 20er MEGA-COMBO! <<<', 'level');
        }

        // Get combo damage multiplier
        function getComboMultiplier() {
            if (game.comboCount < 3) return 1.0;
            if (game.comboCount < 5) return 1.1;
            if (game.comboCount < 10) return 1.25;
            if (game.comboCount < 20) return 1.5;
            return 2.0;  // 20+ combo = double damage
        }

        // Get berserk damage multiplier
        function getBerserkMultiplier() {
            return game.berserkActive ? 1.75 : 1.0;
        }

        function addLog(message, type = 'info') {
            const log = document.getElementById('log');
            const msg = document.createElement('div');
            msg.className = `log-message log-${type}`;
            msg.textContent = '> ' + message;
            log.appendChild(msg);
            log.scrollTop = log.scrollHeight;

            // Keep only last 50 messages
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        function updateUI() {
            document.getElementById('playerLevel').textContent = game.player.level;
            document.getElementById('hpText').textContent = `${Math.max(0, Math.floor(game.player.hp))}/${game.player.maxHp}`;
            document.getElementById('hpBar').style.width = `${(game.player.hp / game.player.maxHp) * 100}%`;
            document.getElementById('xpText').textContent = `${game.player.xp}/${game.player.xpToNext}`;
            document.getElementById('xpBar').style.width = `${(game.player.xp / game.player.xpToNext) * 100}%`;
            document.getElementById('playerAttack').textContent = game.player.attack;
            document.getElementById('playerDefense').textContent = game.player.defense;
            document.getElementById('playerGold').textContent = game.player.gold;
        }

        function updateMonsterCount() {
            document.getElementById('monsterCount').textContent = game.monsters.length;
        }

        function updateInventory() {
            const inv = document.getElementById('inventory');
            inv.innerHTML = '';

            game.player.inventory.forEach((item, i) => {
                const div = document.createElement('div');
                div.className = `item ${item.type}`;
                div.textContent = `${i + 1}. ${item.name}`;
                div.onclick = () => useItem(i);
                inv.appendChild(div);
            });
        }

        function gameOver() {
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('roomsCleared').textContent = game.roomsCleared;
            document.getElementById('monstersKilled').textContent = game.monstersKilled;
            document.getElementById('totalGold').textContent = game.player.gold;

            // No souls earned on death - souls only from achievements & challenges
            const soulsEarned = 0;

            // Update permanent stats
            game.totalRuns = (game.totalRuns || 0) + 1;
            game.totalKills = (game.totalKills || 0) + game.monstersKilled;
            if (game.currentRoom > (game.bestRoom || 0)) {
                game.bestRoom = game.currentRoom;
            }
            savePermanentProgress();

            // Show souls info in game over screen
            let soulsDisplay = document.getElementById('soulsEarned');
            if (!soulsDisplay) {
                const statsDiv = document.querySelector('#gameOver .stats');
                if (statsDiv) {
                    const soulP = document.createElement('p');
                    soulP.innerHTML = 'Seelen verdient: <span id="soulsEarned"></span>';
                    statsDiv.appendChild(soulP);
                    const totalSoulP = document.createElement('p');
                    totalSoulP.innerHTML = 'Gesamte Seelen: <span id="totalSouls"></span>';
                    statsDiv.appendChild(totalSoulP);
                    soulsDisplay = document.getElementById('soulsEarned');
                }
            }
            if (soulsDisplay) {
                soulsDisplay.textContent = '0 (nur durch Erfolge)';
                document.getElementById('totalSouls').textContent = game.souls;
            }

            // Calculate score
            const score = calculateScore();
            document.getElementById('finalScore').textContent = score;
            game.finalScore = score;

            document.getElementById('gameOver').style.display = 'block';
        }

        // ==================== HIGHSCORE SYSTEM ====================
        function calculateScore() {
            return (game.currentRoom * 100) +
                   (game.monstersKilled * 10) +
                   (game.player.gold) +
                   (game.player.level * 50);
        }

        function getHighscores() {
            try {
                const data = localStorage.getItem('dungeonCrawlerHighscores');
                return data ? JSON.parse(data) : [];
            } catch (e) {
                return [];
            }
        }

        function saveHighscore() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim() || 'Anonym';
            const score = game.finalScore || calculateScore();

            const highscores = getHighscores();
            highscores.push({
                name: name,
                score: score,
                level: game.player.level,
                room: game.currentRoom,
                date: new Date().toLocaleDateString('de-DE')
            });

            // Sort by score descending and keep top 10
            highscores.sort((a, b) => b.score - a.score);
            highscores.splice(10);

            try {
                localStorage.setItem('dungeonCrawlerHighscores', JSON.stringify(highscores));
                document.getElementById('saveScoreSection').innerHTML = '<p style="color: #4ade80;">Highscore gespeichert!</p>';
                addLog(`[HIGHSCORE] ${score} Punkte gespeichert!`, 'loot');
            } catch (e) {
                addLog('Fehler beim Speichern!', 'combat');
            }
        }

        function showHighscoreMenu() {
            const highscores = getHighscores();
            const list = document.getElementById('highscoreList');

            if (highscores.length === 0) {
                list.innerHTML = '<p style="color: #888; text-align: center;">Noch keine Highscores!</p>';
            } else {
                list.innerHTML = highscores.map((hs, i) => `
                    <div class="highscore-entry">
                        <span class="highscore-rank">#${i + 1}</span>
                        <span class="highscore-name">${hs.name}</span>
                        <span class="highscore-score">${hs.score} (Lvl ${hs.level})</span>
                    </div>
                `).join('');
            }

            document.getElementById('highscoreMenu').style.display = 'block';
        }

        function closeHighscoreMenu() {
            document.getElementById('highscoreMenu').style.display = 'none';
        }

        function openUpgradeMenuFromGameOver() {
            document.getElementById('gameOver').style.display = 'none';
            game.showUpgradeMenu = true;
            game.upgradeMenuFromGameOver = true;
        }

        function closeUpgradeMenu() {
            game.showUpgradeMenu = false;
            if (game.upgradeMenuFromGameOver) {
                game.upgradeMenuFromGameOver = false;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function drawBrick(x, y, width, height) {
            const theme = getCurrentTheme();
            const brickW = 20;
            const brickH = 10;

            for (let by = 0; by < height; by += brickH) {
                for (let bx = 0; bx < width; bx += brickW) {
                    const offset = (Math.floor(by / brickH) % 2) * (brickW / 2);
                    const actualX = x + bx + offset;
                    const actualY = y + by;

                    if (actualX >= x + width || actualY >= y + height) continue;

                    // Stone brick base - use theme colors
                    ctx.fillStyle = theme.wallColor;
                    ctx.fillRect(actualX, actualY, Math.min(brickW - 1, x + width - actualX), Math.min(brickH - 1, y + height - actualY));

                    // Highlight
                    ctx.fillStyle = theme.wallAccent;
                    ctx.fillRect(actualX, actualY, Math.min(brickW - 1, x + width - actualX), 2);
                    ctx.fillRect(actualX, actualY, 2, Math.min(brickH - 1, y + height - actualY));

                    // Shadow
                    ctx.fillStyle = theme.floorColor;
                    ctx.fillRect(actualX + Math.min(brickW - 2, x + width - actualX - 2), actualY, 1, Math.min(brickH - 1, y + height - actualY));
                    ctx.fillRect(actualX, actualY + Math.min(brickH - 2, y + height - actualY - 2), Math.min(brickW - 1, x + width - actualX), 1);
                }
            }
        }

        // Draw class selection screen
        function drawClassSelection() {
            const time = Date.now() / 1000;

            // Animated gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(0.5, '#1a1a3a');
            gradient.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animated particles in background
            for (let i = 0; i < 30; i++) {
                const x = (i * 73 + time * 20) % canvas.width;
                const y = (i * 47 + Math.sin(time + i) * 30) % canvas.height;
                const alpha = 0.1 + Math.sin(time * 2 + i) * 0.05;
                ctx.fillStyle = `rgba(251, 191, 36, ${alpha})`;
                ctx.fillRect(x, y, 2, 2);
            }

            // Game title
            ctx.font = 'bold 36px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fbbf24';
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 10;
            ctx.fillText('DUNGEON CRAWLER', canvas.width / 2, 40);
            ctx.shadowBlur = 0;

            // Subtitle
            ctx.font = '14px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.fillText('Wahle deinen Helden', canvas.width / 2, 62);

            // Class cards
            const cardWidth = 250;
            const cardHeight = 370;
            const cardGap = 20;
            const totalWidth = 3 * cardWidth + 2 * cardGap;
            const startX = (canvas.width - totalWidth) / 2;
            const cardY = 85;

            const classNames = ['warrior', 'mage', 'rogue'];

            for (let i = 0; i < classNames.length; i++) {
                const className = classNames[i];
                const classData = playerClasses[className];
                const cardX = startX + i * (cardWidth + cardGap);

                // Card hover effect (subtle animation)
                const cardOffset = Math.sin(time * 2 + i * 0.5) * 2;

                // Card shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(cardX + 4, cardY + 4 + cardOffset, cardWidth, cardHeight);

                // Card background with gradient
                const cardGrad = ctx.createLinearGradient(cardX, cardY, cardX, cardY + cardHeight);
                cardGrad.addColorStop(0, '#252540');
                cardGrad.addColorStop(1, '#1a1a2e');
                ctx.fillStyle = cardGrad;
                ctx.fillRect(cardX, cardY + cardOffset, cardWidth, cardHeight);

                // Card inner glow
                ctx.strokeStyle = classData.color + '40';
                ctx.lineWidth = 8;
                ctx.strokeRect(cardX + 4, cardY + 4 + cardOffset, cardWidth - 8, cardHeight - 8);

                // Card border
                ctx.strokeStyle = classData.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(cardX, cardY + cardOffset, cardWidth, cardHeight);

                // Class icon using pixel art
                Icons.draw(classData.icon, cardX + cardWidth / 2, cardY + 55 + cardOffset, 48);

                // Class name
                ctx.font = 'bold 22px "Courier New"';
                ctx.fillStyle = classData.color;
                ctx.fillText(classData.name, cardX + cardWidth / 2, cardY + 100 + cardOffset);

                // Divider line
                ctx.strokeStyle = classData.color + '60';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cardX + 20, cardY + 110 + cardOffset);
                ctx.lineTo(cardX + cardWidth - 20, cardY + 110 + cardOffset);
                ctx.stroke();

                // Description
                ctx.font = '11px "Courier New"';
                ctx.fillStyle = '#bbb';
                const descWords = classData.description.split(' ');
                let line = '';
                let lineY = cardY + 130 + cardOffset;
                for (const word of descWords) {
                    const testLine = line + word + ' ';
                    if (ctx.measureText(testLine).width > cardWidth - 24) {
                        ctx.fillText(line.trim(), cardX + cardWidth / 2, lineY);
                        line = word + ' ';
                        lineY += 14;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line.trim(), cardX + cardWidth / 2, lineY);

                // Stats section
                ctx.font = '10px "Courier New"';
                ctx.textAlign = 'left';
                const statsY = cardY + 175 + cardOffset;
                const statsX = cardX + 20;

                const stats = [
                    { label: 'HP', value: classData.bonuses.maxHp, color: '#22c55e', icon: 'heart' },
                    { label: 'Mana', value: classData.bonuses.maxMana, color: '#3b82f6', icon: 'mana' },
                    { label: 'Angriff', value: classData.bonuses.attack, color: '#ef4444', icon: 'sword' },
                    { label: 'Verteidg.', value: classData.bonuses.defense, color: '#60a5fa', icon: 'shield' },
                    { label: 'Krit', value: Math.round(classData.bonuses.critChance * 100) + '%', color: '#fbbf24', icon: 'target' }
                ];

                for (let j = 0; j < stats.length; j++) {
                    const stat = stats[j];
                    const statY = statsY + j * 16;

                    // Stat icon
                    Icons.draw(stat.icon, statsX + 6, statY - 3, 12);

                    // Stat label
                    ctx.fillStyle = '#777';
                    ctx.fillText(stat.label, statsX + 18, statY);

                    // Stat value
                    const valueStr = typeof stat.value === 'string' ? stat.value :
                        (stat.value >= 0 ? '+' + stat.value : stat.value);
                    ctx.fillStyle = stat.value > 0 || (typeof stat.value === 'string' && stat.value !== '0%') ? stat.color : '#555';
                    ctx.fillText(valueStr, cardX + cardWidth - 45, statY);
                }

                // Skills section
                ctx.textAlign = 'center';
                ctx.font = 'bold 10px "Courier New"';
                ctx.fillStyle = classData.color;
                ctx.fillText('- Skills -', cardX + cardWidth / 2, cardY + 260 + cardOffset);

                if (classData.skillInfo) {
                    ctx.font = '9px "Courier New"';
                    ctx.fillStyle = '#ccc';
                    for (let s = 0; s < classData.skillInfo.length; s++) {
                        ctx.fillText(classData.skillInfo[s], cardX + cardWidth / 2, cardY + 276 + s * 13 + cardOffset);
                    }
                }

                // Passive ability line
                ctx.font = '8px "Courier New"';
                ctx.fillStyle = '#fbbf24';
                const passiveWords = classData.passive.split(' ');
                line = '';
                lineY = cardY + 335 + cardOffset;
                for (const word of passiveWords) {
                    const testLine = line + word + ' ';
                    if (ctx.measureText(testLine).width > cardWidth - 24) {
                        ctx.fillText(line.trim(), cardX + cardWidth / 2, lineY);
                        line = word + ' ';
                        lineY += 10;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line.trim(), cardX + cardWidth / 2, lineY);

                // Selection key button
                ctx.fillStyle = classData.color;
                ctx.fillRect(cardX + cardWidth / 2 - 20, cardY + cardHeight - 25 + cardOffset, 40, 20);
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillStyle = '#fff';
                ctx.fillText(`${i + 1}`, cardX + cardWidth / 2, cardY + cardHeight - 11 + cardOffset);
            }

            // Bottom panel
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, canvas.height - 60, canvas.width, 60);

            // Souls display with icon
            ctx.textAlign = 'center';
            Icons.draw('soul', canvas.width / 2 - 60, canvas.height - 38, 16);
            ctx.font = '14px "Courier New"';
            ctx.fillStyle = '#a855f7';
            ctx.fillText(`${game.souls}`, canvas.width / 2 - 35, canvas.height - 34);

            // Menu hints
            ctx.font = '11px "Courier New"';
            ctx.fillStyle = '#666';
            ctx.fillText('[U] Upgrades   [A] Erfolge   [B] Bestiarum   [K] Tasten', canvas.width / 2 + 60, canvas.height - 34);

            // Instructions
            ctx.fillStyle = '#888';
            ctx.fillText('Drucke 1, 2 oder 3 um eine Klasse zu wahlen', canvas.width / 2, canvas.height - 15);

            // Draw daily challenges panel
            drawDailyChallengesPanel();

            // Draw customization panel
            drawCustomizationPanel();
        }

        // Draw permanent upgrade menu
        function drawUpgradeMenu() {
            // Darken background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#a855f7';
            ctx.fillText('Permanente Upgrades', canvas.width / 2, 45);

            // Souls display
            ctx.font = '18px "Courier New"';
            ctx.fillStyle = '#fbbf24';
            // Souls display with icon
            Icons.draw('soul', canvas.width / 2 - 60, 72, 18);
            ctx.fillText(`Seelen: ${game.souls}`, canvas.width / 2 + 10, 75);

            // Stats display
            ctx.font = '11px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.fillText(`Runs: ${game.totalRuns || 0} | Beste Etage: ${game.bestRoom || 0} | Kills: ${game.totalKills || 0}`, canvas.width / 2, 95);

            // Upgrade cards
            const upgradeKeys = Object.keys(permanentUpgradesDef);
            const cols = 4;
            const rows = 2;
            const cardWidth = 170;
            const cardHeight = 140;
            const cardGap = 15;
            const totalWidth = cols * cardWidth + (cols - 1) * cardGap;
            const totalHeight = rows * cardHeight + (rows - 1) * cardGap;
            const startX = (canvas.width - totalWidth) / 2;
            const startY = (canvas.height - totalHeight) / 2 - 20;

            for (let i = 0; i < upgradeKeys.length; i++) {
                const key = upgradeKeys[i];
                const def = permanentUpgradesDef[key];
                const currentLevel = game.permanentUpgrades[key];
                const cost = getUpgradeCost(key);
                const isMaxed = currentLevel >= def.maxLevel;
                const canAfford = game.souls >= cost;

                const col = i % cols;
                const row = Math.floor(i / cols);
                const cardX = startX + col * (cardWidth + cardGap);
                const cardY = startY + row * (cardHeight + cardGap);

                // Card background
                ctx.fillStyle = isMaxed ? '#1a3a1a' : (canAfford ? '#1a1a3a' : '#1a1a1a');
                ctx.fillRect(cardX, cardY, cardWidth, cardHeight);

                // Card border
                ctx.strokeStyle = isMaxed ? '#22c55e' : (canAfford ? '#a855f7' : '#444');
                ctx.lineWidth = 2;
                ctx.strokeRect(cardX, cardY, cardWidth, cardHeight);

                // Icon - use pixel art
                Icons.draw(def.icon, cardX + cardWidth / 2, cardY + 30, 32);

                // Name
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillStyle = isMaxed ? '#22c55e' : '#fff';
                ctx.fillText(def.name, cardX + cardWidth / 2, cardY + 55);

                // Level
                ctx.font = '11px "Courier New"';
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`Lvl ${currentLevel}/${def.maxLevel}`, cardX + cardWidth / 2, cardY + 72);

                // Description
                ctx.font = '10px "Courier New"';
                ctx.fillStyle = '#aaa';
                ctx.fillText(def.description, cardX + cardWidth / 2, cardY + 90);

                // Cost or Maxed
                if (isMaxed) {
                    ctx.font = 'bold 11px "Courier New"';
                    ctx.fillStyle = '#22c55e';
                    ctx.fillText('MAXED', cardX + cardWidth / 2, cardY + 110);
                } else {
                    ctx.font = '11px "Courier New"';
                    ctx.fillStyle = canAfford ? '#a855f7' : '#666';
                    ctx.fillText(`Kosten: ${cost}`, cardX + cardWidth / 2 - 10, cardY + 110);
                    Icons.draw('soul', cardX + cardWidth / 2 + 35, cardY + 108, 14);
                }

                // Key hint
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillStyle = isMaxed ? '#444' : (canAfford ? '#fff' : '#555');
                ctx.fillText(`[${i + 1}]`, cardX + cardWidth / 2, cardY + cardHeight - 10);
            }

            // Instructions
            ctx.font = '12px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('Drücke 1-8 zum Kaufen  |  [ESC] Zurück', canvas.width / 2, canvas.height - 30);
        }

        function draw() {
            // Show key bindings menu if open
            if (game.showKeyBindings) {
                drawKeyBindingsMenu();
                return;
            }

            // Show bestiary menu if open
            if (game.showBestiary) {
                drawBestiaryMenu();
                return;
            }

            // Show achievements menu if open
            if (game.showAchievements) {
                drawAchievementsMenu();
                return;
            }

            // Show upgrade menu if open
            if (game.showUpgradeMenu) {
                drawUpgradeMenu();
                return;
            }

            // Show class selection if not selected
            if (!game.classSelected) {
                drawClassSelection();
                return;
            }

            // Apply screen shake
            ctx.save();
            if (game.screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * game.screenShake;
                const shakeY = (Math.random() - 0.5) * game.screenShake;
                ctx.translate(shakeX, shakeY);
                game.screenShake *= 0.9;
                if (game.screenShake < 0.5) game.screenShake = 0;
            }

            // Apply camera offset
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);

            // Background - dungeon stone floor (draw for visible area + margin)
            const theme = getCurrentTheme();
            const tileSize = 32;
            const startX = Math.floor(game.camera.x / tileSize) * tileSize;
            const startY = Math.floor(game.camera.y / tileSize) * tileSize;
            const endX = startX + canvas.width + tileSize;
            const endY = startY + canvas.height + tileSize;

            for (let y = startY; y < endY && y < game.worldHeight; y += tileSize) {
                for (let x = startX; x < endX && x < game.worldWidth; x += tileSize) {
                    const isLight = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = isLight ? theme.floorColor : theme.floorAccent;
                    ctx.fillRect(x, y, tileSize, tileSize);

                    // Stone texture details
                    ctx.fillStyle = isLight ? theme.floorAccent : theme.floorColor;
                    ctx.fillRect(x, y, tileSize, 2);
                    ctx.fillRect(x, y, 2, tileSize);
                }
            }

            // Apply ambient color overlay for atmosphere
            ctx.fillStyle = theme.ambientColor;
            ctx.fillRect(startX, startY, endX - startX, endY - startY);

            // Draw Void-Zonen (Abgrund)
            for (const void_ of game.voidZones) {
                // Dunkler Abgrund mit Gradient
                const gradient = ctx.createLinearGradient(
                    void_.side === 'left' ? void_.x : void_.x + void_.width,
                    void_.y,
                    void_.side === 'left' ? void_.x + void_.width : void_.x,
                    void_.y
                );
                gradient.addColorStop(0, '#000000');
                gradient.addColorStop(0.6, '#0a0a15');
                gradient.addColorStop(1, '#151525');
                ctx.fillStyle = gradient;
                ctx.fillRect(void_.x, void_.y, void_.width, void_.height);

                // Animierte Sterne/Partikel im Void
                ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
                const time = game.animCounter * 0.02;
                for (let i = 0; i < 5; i++) {
                    const sparkleY = void_.y + ((void_.y + i * 97 + time * 50) % void_.height);
                    const sparkleX = void_.x + 5 + Math.sin(time + i) * 10 + (void_.side === 'left' ? 0 : 15);
                    const sparkleSize = 1 + Math.sin(time * 2 + i) * 0.5;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Gefährlicher roter Rand am Übergang
                ctx.strokeStyle = 'rgba(200, 50, 50, 0.4)';
                ctx.lineWidth = 2;
                if (void_.side === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(void_.x + void_.width, void_.y);
                    ctx.lineTo(void_.x + void_.width, void_.y + void_.height);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(void_.x, void_.y);
                    ctx.lineTo(void_.x, void_.y + void_.height);
                    ctx.stroke();
                }
            }

            // Draw walls with stone texture
            for (const wall of game.walls) {
                drawBrick(wall.x, wall.y, wall.width, wall.height);
            }

            // Draw breakable secret walls
            for (const secretWall of game.secretWalls) {
                if (secretWall.hp <= 0) continue; // Wall is broken

                ctx.save();

                // Different color for damaged walls
                const damagePercent = secretWall.hp / secretWall.maxHp;
                if (damagePercent < 0.5) {
                    // Heavily damaged - show cracks
                    ctx.fillStyle = '#4a4a5a';
                    secretWall.cracked = true;
                } else if (damagePercent < 1) {
                    ctx.fillStyle = '#5a5a6a';
                } else {
                    ctx.fillStyle = '#6a6a7a';
                }

                ctx.fillRect(secretWall.x, secretWall.y, secretWall.width, secretWall.height);

                // Draw cracks when damaged
                if (secretWall.cracked || damagePercent < 1) {
                    ctx.strokeStyle = '#2a2a3a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    // Random crack lines
                    const cx = secretWall.x + secretWall.width / 2;
                    const cy = secretWall.y + secretWall.height / 2;
                    ctx.moveTo(cx - 5, cy - 20);
                    ctx.lineTo(cx + 3, cy);
                    ctx.lineTo(cx - 8, cy + 25);
                    ctx.moveTo(cx + 2, cy - 15);
                    ctx.lineTo(cx - 4, cy + 10);
                    ctx.stroke();

                    // Pulsing hint when very damaged
                    if (damagePercent < 0.3) {
                        const pulse = Math.sin(game.animCounter * 0.15) * 0.3 + 0.3;
                        ctx.fillStyle = `rgba(255, 200, 100, ${pulse})`;
                        ctx.fillRect(secretWall.x, secretWall.y, secretWall.width, secretWall.height);
                    }
                }

                // Subtle shimmer effect to hint at secret
                if (!secretWall.cracked && Math.random() < 0.02) {
                    game.particles.push({
                        x: secretWall.x + Math.random() * secretWall.width,
                        y: secretWall.y + Math.random() * secretWall.height,
                        vx: 0,
                        vy: -0.5,
                        color: '#fbbf24',
                        life: 20,
                        size: 2
                    });
                }

                ctx.restore();
            }

            // Draw doors - 3D animated double doors opening inward
            for (const door of game.doors) {
                // Initialize door animation
                if (door.openAnim === undefined) door.openAnim = 0;

                // Update door animation (smooth easing)
                if (door.active) {
                    door.openAnim = Math.min(door.openAnim + 1.5, 90); // Max 90 degrees
                }

                const isOpen = door.active;
                const openAngle = door.openAnim * (Math.PI / 180); // Convert to radians
                const doorHalfWidth = door.width / 2 - 2;
                const doorHeight = door.height;
                const centerX = door.x + door.width / 2;

                // Glow effect for active door
                if (isOpen) {
                    ctx.shadowBlur = 15 + Math.sin(game.animCounter * 0.1) * 5;
                    ctx.shadowColor = '#00FF00';

                    // Particle sparkles
                    if (Math.random() < 0.08) {
                        game.particles.push({
                            x: door.x + Math.random() * door.width,
                            y: door.y + Math.random() * door.height,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * -2 - 1,
                            color: Math.random() > 0.5 ? '#00FF00' : '#88FF88',
                            life: 25,
                            size: 2 + Math.random() * 2
                        });
                    }
                }

                // Door frame (stone archway)
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(door.x - 8, door.y - 12, door.width + 16, 12); // Top frame
                ctx.fillRect(door.x - 8, door.y, 8, doorHeight); // Left frame
                ctx.fillRect(door.x + door.width, door.y, 8, doorHeight); // Right frame

                // Frame 3D effect
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(door.x - 6, door.y - 10, door.width + 12, 4);
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(door.x - 8, door.y - 12, door.width + 16, 3);

                // Archway decorations
                ctx.fillStyle = isOpen ? '#00AA00' : '#555';
                ctx.beginPath();
                ctx.arc(centerX, door.y - 6, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = isOpen ? '#00FF00' : '#666';
                ctx.beginPath();
                ctx.arc(centerX, door.y - 6, 5, 0, Math.PI * 2);
                ctx.fill();

                // Dark opening behind doors
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(door.x, door.y, door.width, doorHeight);

                // Draw left door (opens inward to the left)
                ctx.save();
                ctx.translate(door.x, door.y);

                // Calculate 3D perspective for left door
                const leftDoorWidth = Math.cos(openAngle) * doorHalfWidth;
                const leftDoorSkew = Math.sin(openAngle) * 8;

                // Left door shadow (depth)
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(leftDoorWidth, leftDoorSkew);
                ctx.lineTo(leftDoorWidth, doorHeight - leftDoorSkew);
                ctx.lineTo(0, doorHeight);
                ctx.closePath();
                ctx.fill();

                // Left door main
                const leftColor = isOpen ? '#228B22' : '#654321';
                ctx.fillStyle = leftColor;
                ctx.beginPath();
                ctx.moveTo(2, 2);
                ctx.lineTo(leftDoorWidth - 2, leftDoorSkew + 2);
                ctx.lineTo(leftDoorWidth - 2, doorHeight - leftDoorSkew - 2);
                ctx.lineTo(2, doorHeight - 2);
                ctx.closePath();
                ctx.fill();

                // Left door wood grain / panels
                ctx.fillStyle = isOpen ? '#1a6b1a' : '#543210';
                for (let p = 0; p < 3; p++) {
                    const py = 6 + p * (doorHeight / 3 - 4);
                    const panelSkew = leftDoorSkew * (py / doorHeight);
                    ctx.fillRect(6, py + panelSkew * 0.5, leftDoorWidth - 14, doorHeight / 3 - 10);
                }

                // Door handle (left)
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(leftDoorWidth - 10, doorHeight / 2, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Draw right door (opens inward to the right)
                ctx.save();
                ctx.translate(door.x + door.width, door.y);

                // Calculate 3D perspective for right door (mirrored)
                const rightDoorWidth = Math.cos(openAngle) * doorHalfWidth;
                const rightDoorSkew = Math.sin(openAngle) * 8;

                // Right door shadow
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-rightDoorWidth, rightDoorSkew);
                ctx.lineTo(-rightDoorWidth, doorHeight - rightDoorSkew);
                ctx.lineTo(0, doorHeight);
                ctx.closePath();
                ctx.fill();

                // Right door main
                const rightColor = isOpen ? '#228B22' : '#654321';
                ctx.fillStyle = rightColor;
                ctx.beginPath();
                ctx.moveTo(-2, 2);
                ctx.lineTo(-rightDoorWidth + 2, rightDoorSkew + 2);
                ctx.lineTo(-rightDoorWidth + 2, doorHeight - rightDoorSkew - 2);
                ctx.lineTo(-2, doorHeight - 2);
                ctx.closePath();
                ctx.fill();

                // Right door panels
                ctx.fillStyle = isOpen ? '#1a6b1a' : '#543210';
                for (let p = 0; p < 3; p++) {
                    const py = 6 + p * (doorHeight / 3 - 4);
                    const panelSkew = rightDoorSkew * (py / doorHeight);
                    ctx.fillRect(-rightDoorWidth + 8, py + panelSkew * 0.5, rightDoorWidth - 14, doorHeight / 3 - 10);
                }

                // Door handle (right)
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(-rightDoorWidth + 10, doorHeight / 2, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // "EXIT" text when open
                if (isOpen && door.openAnim > 45) {
                    ctx.fillStyle = '#00FF00';
                    ctx.font = 'bold 12px "Courier New"';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXIT', centerX, door.y + doorHeight / 2 + 4);
                }

                ctx.shadowBlur = 0;
            }

            // Draw traps with animations
            for (const trap of game.traps) {
                ctx.save();
                const trapX = trap.x - trap.size / 2;
                const trapY = trap.y - trap.size / 2;

                // Update animation timer
                trap.animTimer += 0.1;

                // Warning glow with pulsing
                if (trap.warning) {
                    const pulse = 0.3 + Math.sin(trap.animTimer * 3) * 0.15;
                    ctx.fillStyle = `rgba(255, 200, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.arc(trap.x, trap.y, trap.size + 10 + Math.sin(trap.animTimer * 5) * 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (trap.type === 'spikes') {
                    // Spike trap - spikes shoot up when active
                    const targetHeight = trap.active ? 25 : 0;
                    trap.spikeHeight += (targetHeight - trap.spikeHeight) * 0.3;

                    // Base plate with holes
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(trapX, trapY, trap.size, trap.size);
                    ctx.fillStyle = '#2a2a2a';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            ctx.beginPath();
                            ctx.arc(trapX + 8 + i * 12, trapY + 8 + j * 12, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Animated spikes shooting up
                    if (trap.spikeHeight > 1) {
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                const sx = trapX + 8 + i * 12;
                                const sy = trapY + 8 + j * 12;
                                const h = trap.spikeHeight;

                                // Spike shadow
                                ctx.fillStyle = '#555';
                                ctx.beginPath();
                                ctx.moveTo(sx - 4, sy);
                                ctx.lineTo(sx, sy - h);
                                ctx.lineTo(sx + 4, sy);
                                ctx.closePath();
                                ctx.fill();

                                // Spike
                                const gradient = ctx.createLinearGradient(sx, sy, sx, sy - h);
                                gradient.addColorStop(0, '#888');
                                gradient.addColorStop(0.5, '#ccc');
                                gradient.addColorStop(1, '#fff');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.moveTo(sx - 3, sy);
                                ctx.lineTo(sx, sy - h);
                                ctx.lineTo(sx + 3, sy);
                                ctx.closePath();
                                ctx.fill();
                            }
                        }
                    }
                } else if (trap.type === 'fire') {
                    // Fire fountain trap
                    // Base grate
                    ctx.fillStyle = '#333';
                    ctx.fillRect(trapX, trapY, trap.size, trap.size);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trapX + i * 12, trapY);
                        ctx.lineTo(trapX + i * 12, trapY + trap.size);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(trapX, trapY + i * 12);
                        ctx.lineTo(trapX + trap.size, trapY + i * 12);
                        ctx.stroke();
                    }

                    // Fire fountain when active
                    if (trap.active) {
                        const fountainHeight = 60;
                        // Spawn fountain particles
                        if (Math.random() < 0.5) {
                            trap.fountainParticles.push({
                                x: trap.x + (Math.random() - 0.5) * 15,
                                y: trap.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -8 - Math.random() * 6,
                                life: 30,
                                size: 4 + Math.random() * 4
                            });
                        }

                        // Update and draw fountain particles
                        for (let i = trap.fountainParticles.length - 1; i >= 0; i--) {
                            const p = trap.fountainParticles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += 0.3; // gravity
                            p.life--;
                            p.size *= 0.97;

                            if (p.life <= 0) {
                                trap.fountainParticles.splice(i, 1);
                                continue;
                            }

                            const alpha = p.life / 30;
                            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                            gradient.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
                            gradient.addColorStop(0.5, `rgba(255, 150, 0, ${alpha})`);
                            gradient.addColorStop(1, `rgba(255, 50, 0, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Core flame
                        const coreGradient = ctx.createRadialGradient(trap.x, trap.y - 10, 0, trap.x, trap.y - 10, 20);
                        coreGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                        coreGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.7)');
                        coreGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.arc(trap.x, trap.y - 10, 20, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Embers when inactive
                        ctx.fillStyle = '#ff4400';
                        ctx.globalAlpha = 0.3 + Math.sin(trap.animTimer) * 0.2;
                        ctx.beginPath();
                        ctx.arc(trap.x, trap.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                } else if (trap.type === 'poison') {
                    // Poison pool with bubbling
                    // Pool base
                    const poolGradient = ctx.createRadialGradient(trap.x, trap.y, 0, trap.x, trap.y, 22);
                    poolGradient.addColorStop(0, trap.active ? '#4ade80' : '#166534');
                    poolGradient.addColorStop(0.7, trap.active ? '#22c55e' : '#0f3d0f');
                    poolGradient.addColorStop(1, trap.active ? '#15803d' : '#052e05');
                    ctx.fillStyle = poolGradient;
                    ctx.beginPath();
                    ctx.ellipse(trap.x, trap.y, 22, 18, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Bubbling effect
                    if (trap.active || trap.warning) {
                        const bubbleCount = trap.active ? 4 : 2;
                        for (let i = 0; i < bubbleCount; i++) {
                            const angle = trap.animTimer + i * (Math.PI / 2);
                            const dist = 8 + Math.sin(angle * 2) * 5;
                            const bx = trap.x + Math.cos(angle) * dist;
                            const by = trap.y + Math.sin(angle * 0.5) * 8;
                            const bsize = 2 + Math.sin(angle * 3) * 1.5;

                            ctx.fillStyle = 'rgba(134, 239, 172, 0.7)';
                            ctx.beginPath();
                            ctx.arc(bx, by - Math.abs(Math.sin(trap.animTimer * 2 + i)) * 10, Math.max(0.5, bsize), 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Rising vapor
                        if (trap.active) {
                            for (let i = 0; i < 3; i++) {
                                const vx = trap.x + Math.sin(trap.animTimer + i * 2) * 10;
                                const vy = trap.y - 10 - (trap.animTimer * 3 + i * 10) % 30;
                                const valpha = 1 - ((trap.animTimer * 3 + i * 10) % 30) / 30;
                                ctx.fillStyle = `rgba(74, 222, 128, ${valpha * 0.4})`;
                                ctx.beginPath();
                                ctx.arc(vx, vy, 4, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                } else if (trap.type === 'ice') {
                    // Ice trap with crystal formations
                    // Frozen ground
                    ctx.fillStyle = trap.active ? '#bfdbfe' : '#1e3a5f';
                    ctx.fillRect(trapX + 2, trapY + 2, trap.size - 4, trap.size - 4);

                    // Ice pattern
                    ctx.strokeStyle = trap.active ? '#93c5fd' : '#334155';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + trap.animTimer * 0.2;
                        ctx.beginPath();
                        ctx.moveTo(trap.x, trap.y);
                        ctx.lineTo(trap.x + Math.cos(angle) * 18, trap.y + Math.sin(angle) * 18);
                        ctx.stroke();
                    }

                    // Ice crystals when active
                    if (trap.active) {
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const dist = 12;
                            const cx = trap.x + Math.cos(angle) * dist;
                            const cy = trap.y + Math.sin(angle) * dist;
                            const crystalHeight = 15 + Math.sin(trap.animTimer + i) * 5;

                            // Crystal
                            ctx.fillStyle = 'rgba(147, 197, 253, 0.8)';
                            ctx.beginPath();
                            ctx.moveTo(cx - 3, cy);
                            ctx.lineTo(cx, cy - crystalHeight);
                            ctx.lineTo(cx + 3, cy);
                            ctx.closePath();
                            ctx.fill();

                            // Crystal highlight
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.moveTo(cx - 1, cy);
                            ctx.lineTo(cx, cy - crystalHeight + 3);
                            ctx.lineTo(cx + 1, cy - 5);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Frost particles
                        if (Math.random() < 0.2) {
                            game.particles.push({
                                x: trap.x + (Math.random() - 0.5) * trap.size,
                                y: trap.y + (Math.random() - 0.5) * trap.size,
                                vx: (Math.random() - 0.5) * 1,
                                vy: -Math.random() * 2,
                                color: '#93c5fd',
                                life: 20,
                                size: 2
                            });
                        }
                    }
                }
                ctx.restore();
            }

            // Draw treasure chests
            for (const chest of game.treasureChests) {
                ctx.save();
                const cx = chest.x;
                const cy = chest.y;
                const s = chest.size;

                if (!chest.opened) {
                    // Closed chest
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - s/2, cy - s/4, s, s/2);
                    // Lid
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(cx - s/2 - 2, cy - s/2, s + 4, s/4);
                    // Gold trim
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(cx - 4, cy - s/4, 8, s/2);
                    ctx.fillRect(cx - s/2, cy - s/4 - 2, s, 4);
                    // Lock
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Sparkle
                    if (Math.random() < 0.05) {
                        game.particles.push({
                            x: cx + (Math.random() - 0.5) * s,
                            y: cy + (Math.random() - 0.5) * s/2,
                            vx: 0, vy: -1,
                            color: '#fbbf24',
                            life: 20, size: 2
                        });
                    }
                } else {
                    // Opened chest
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(cx - s/2, cy - s/4, s, s/2);
                    // Open lid (tilted back)
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - s/2 - 2, cy - s/2 - 10, s + 4, s/4);
                }
                ctx.restore();
            }

            // Draw items - pixel art style with drop animation
            for (const item of game.items) {
                // Update drop animation
                if (item.dropAnim && item.dropAnim > 0) {
                    item.dropAnim--;
                    item.dropVy += 0.5;  // Gravity
                    item.y += item.dropVy;
                }

                const bounce = Math.sin(game.animCounter * 0.05 + item.animOffset) * 3;
                let itemY = item.y + bounce;

                // Draw item shadow - very visible
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                ctx.beginPath();
                ctx.ellipse(item.x, item.y + 14, 10, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Scale effect for newly dropped items
                let scale = 1;
                if (item.dropAnim && item.dropAnim > 10) {
                    scale = 1 + (item.dropAnim - 10) / 20;
                }

                // Fall-Animation: Item schrumpft wenn es ins Void fällt
                let itemAlpha = 1;
                if (item.isFalling) {
                    scale *= (1 - item.fallProgress * 0.95); // Schrumpft fast auf 0
                    itemAlpha = 1 - item.fallProgress;
                }

                ctx.save();
                ctx.globalAlpha = itemAlpha;
                ctx.translate(item.x, itemY);
                ctx.scale(scale, scale);
                ctx.translate(-item.x, -itemY);

                ctx.shadowBlur = 0;

                const style = item.style || '';

                // Draw items matching inventory graphics
                if (item.type === 'weapon') {
                    if (style === 'flame') {
                        // Flammschwert auf Boden - passend zum Hand-Design
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff6600';
                        // Klinge
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 18);
                        ctx.fillStyle = '#e0e0e0';
                        ctx.fillRect(item.x - 1, itemY - 10, 2, 16);
                        // Flammen an der Klinge
                        ctx.fillStyle = '#ff6600';
                        ctx.fillRect(item.x - 4, itemY - 6, 2, 6);
                        ctx.fillRect(item.x + 2, itemY - 8, 2, 8);
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(item.x - 3, itemY - 4, 1, 4);
                        ctx.fillRect(item.x + 2, itemY - 6, 1, 5);
                        ctx.shadowBlur = 0;
                        // Schwertspitze (Dreieck)
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.moveTo(item.x, itemY - 16);
                        ctx.lineTo(item.x - 2, itemY - 12);
                        ctx.lineTo(item.x + 2, itemY - 12);
                        ctx.closePath();
                        ctx.fill();
                        // Goldene Parierstange
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(item.x - 5, itemY + 6, 10, 3);
                        // Griff
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 5);
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(item.x - 1, itemY + 10, 2, 3);
                    } else if (style === 'fire_staff') {
                        // Feuerstab auf Boden
                        ctx.shadowBlur = 6;
                        ctx.shadowColor = '#ff6600';
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(item.x - 2, itemY - 10, 4, 16);
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(item.x - 1, itemY - 8, 2, 10);
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 3, itemY + 6, 6, 4);
                    } else if (style === 'dagger' || style === 'poison_dagger') {
                        ctx.fillStyle = style === 'poison_dagger' ? '#22c55e' : '#c0c0c0';
                        ctx.fillRect(item.x - 1, itemY - 7, 3, 10);
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 2, itemY + 3, 5, 5);
                    } else if (style === 'axe' || style === 'battleaxe') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 9, 3, 16);
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(item.x - 5, itemY - 8, 8, 6);
                    } else if (style === 'hammer') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 6, 3, 14);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(item.x - 4, itemY - 8, 9, 7);
                    } else if (style === 'mace') {
                        // Streitkolben auf Boden - passend zum Inventar-Design
                        // Holzgriff
                        ctx.fillStyle = '#5C4033';
                        ctx.fillRect(item.x - 1, itemY - 4, 3, 14);
                        // Metallkopf (Kugel)
                        ctx.fillStyle = '#606060';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY - 7, 5, 0, Math.PI * 2);
                        ctx.fill();
                        // Glanzlicht auf Kugel
                        ctx.fillStyle = '#808080';
                        ctx.beginPath();
                        ctx.arc(item.x - 1, itemY - 8, 2, 0, Math.PI * 2);
                        ctx.fill();
                        // Zacken/Flanken
                        ctx.fillStyle = '#505050';
                        ctx.fillRect(item.x - 6, itemY - 8, 3, 2);
                        ctx.fillRect(item.x + 3, itemY - 8, 3, 2);
                        ctx.fillRect(item.x - 1, itemY - 12, 2, 3);
                    } else if (style === 'spear' || style === 'halberd') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 8, 2, 18);
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.moveTo(item.x, itemY - 12);
                        ctx.lineTo(item.x - 3, itemY - 6);
                        ctx.lineTo(item.x + 3, itemY - 6);
                        ctx.closePath();
                        ctx.fill();
                    } else if (style === 'staff') {
                        ctx.fillStyle = '#5c3d2e';
                        ctx.fillRect(item.x - 1, itemY - 8, 3, 18);
                        ctx.fillStyle = '#c084fc';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#c084fc';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY - 10, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (style === 'claw') {
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(item.x - 4, itemY, 8, 6);
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(item.x - 5, itemY - 8, 2, 10);
                        ctx.fillRect(item.x - 1, itemY - 10, 2, 12);
                        ctx.fillRect(item.x + 3, itemY - 8, 2, 10);
                    } else if (style === 'bone') {
                        ctx.fillStyle = '#e2e8f0';
                        ctx.fillRect(item.x - 2, itemY - 9, 4, 14);
                        ctx.fillRect(item.x - 4, itemY - 6, 2, 4);
                        ctx.fillRect(item.x + 2, itemY - 6, 2, 4);
                    } else if (style === 'rusty_sword') {
                        // Rusty sword on ground
                        // Rusty blade
                        ctx.fillStyle = '#8B7355';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        // Rust patches
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(item.x - 2, itemY - 10, 2, 3);
                        ctx.fillRect(item.x, itemY - 4, 2, 4);
                        ctx.fillRect(item.x - 2, itemY, 3, 2);
                        // Dark rust/pitting
                        ctx.fillStyle = '#6B4423';
                        ctx.fillRect(item.x - 1, itemY - 6, 1, 2);
                        ctx.fillRect(item.x + 1, itemY - 2, 1, 2);
                        // Dull edge
                        ctx.fillStyle = '#9B8B7B';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 10);
                        // Worn crossguard
                        ctx.fillStyle = '#5C4033';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Worn grip
                        ctx.fillStyle = '#3a2718';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#4a3020';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Dented pommel
                        ctx.fillStyle = '#5C4033';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (style === 'iron_sword') {
                        // Iron sword on ground
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#B8C0CC';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        ctx.fillStyle = '#6B7280';
                        ctx.fillRect(item.x - 1, itemY - 10, 1, 12);
                        // Iron crossguard
                        ctx.fillStyle = '#4B5563';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Leather grip
                        ctx.fillStyle = '#5C4033';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#6B5043';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Iron pommel
                        ctx.fillStyle = '#4B5563';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (style === 'steel_sword') {
                        // Steel sword on ground - bright and polished
                        ctx.fillStyle = '#E5E7EB';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#F3F4F6';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 1, itemY - 10, 1, 12);
                        // Steel crossguard
                        ctx.fillStyle = '#6B7280';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 4, itemY + 4, 8, 1);
                        // Blue leather grip
                        ctx.fillStyle = '#1E3A5F';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#2B4A6F';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Steel pommel with gem
                        ctx.fillStyle = '#6B7280';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3B82F6';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 1, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Realistic sword on ground
                        // Klinge
                        ctx.fillStyle = '#D8D8D8';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#A8A8A8';
                        ctx.fillRect(item.x - 1, itemY - 11, 1, 14);
                        ctx.fillStyle = '#F0F0F0';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        // Parierstange
                        ctx.fillStyle = '#B8860B';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Griff
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#5c4033';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Knauf
                        ctx.fillStyle = '#B8860B';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (item.type === 'armor') {
                    // Shield - matching inventory style
                    const armorStyle = item.style || 'leather';
                    const armorColors = { leather: '#8B4513', chain: '#808080', plate: '#c0c0c0', dragon: '#ef4444' };
                    ctx.fillStyle = armorColors[armorStyle] || '#4169E1';
                    ctx.beginPath();
                    ctx.moveTo(item.x, itemY - 10);
                    ctx.lineTo(item.x - 8, itemY - 6);
                    ctx.lineTo(item.x - 8, itemY + 4);
                    ctx.lineTo(item.x, itemY + 10);
                    ctx.lineTo(item.x + 8, itemY + 4);
                    ctx.lineTo(item.x + 8, itemY - 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(item.x - 3, itemY - 3, 6, 6);
                } else if (item.type === 'bomb') {
                    // Bomb - matching inventory style
                    const isBig = (item.damage || 40) >= 60;
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(item.x, itemY + 2, isBig ? 9 : 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(item.x - 2, itemY, isBig ? 4 : 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(item.x, itemY - 6);
                    ctx.quadraticCurveTo(item.x + 3, itemY - 10, item.x + 5, itemY - 8);
                    ctx.stroke();
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(item.x + 5, itemY - 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (item.type === 'potion') {
                    // Potion - matching inventory style
                    ctx.fillStyle = '#333';
                    ctx.fillRect(item.x - 2, itemY - 10, 4, 4);
                    const potionColor = (item.heal || 30) >= 100 ? '#ff0066' : (item.heal || 30) >= 50 ? '#ff1493' : '#ff69b4';
                    ctx.fillStyle = potionColor;
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = potionColor;
                    ctx.fillRect(item.x - 5, itemY - 6, 10, 12);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fillRect(item.x - 4, itemY - 5, 3, 8);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(item.x - 2, itemY - 10, 4, 3);
                }

                ctx.restore();
            }

            // Draw bombs
            for (const bomb of game.bombs) {
                // Shadow on ground
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(bomb.targetX, bomb.targetY + 5, 12, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bomb body
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, bomb.size, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.fillStyle = '#555555';
                ctx.beginPath();
                ctx.arc(bomb.x - 3, bomb.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();

                // Fuse
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bomb.x, bomb.y - bomb.size);
                ctx.lineTo(bomb.x + 4, bomb.y - bomb.size - 6);
                ctx.stroke();

                // Spark on fuse
                if (bomb.fuseTime % 10 < 5) {
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 4, bomb.y - bomb.size - 6, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw projectiles with trails
            for (const proj of game.projectiles) {
                // Draw shadow for falling projectiles (arrows, meteors)
                if (proj.vy > 2 && proj.fromMonster) {
                    const groundY = canvas.height - 20;
                    const heightAboveGround = groundY - proj.y;
                    const shadowAlpha = Math.max(0.1, 0.4 - heightAboveGround / 600);
                    const shadowSize = Math.max(5, 15 - heightAboveGround / 50);

                    ctx.save();
                    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
                    ctx.beginPath();
                    ctx.ellipse(proj.x, groundY, shadowSize, shadowSize * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Warning ring for impact zone
                    if (heightAboveGround < 150) {
                        const warningAlpha = (1 - heightAboveGround / 150) * 0.5;
                        ctx.strokeStyle = `rgba(255, 50, 50, ${warningAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(proj.x, groundY, shadowSize * 1.5, shadowSize * 0.6, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                // Draw trail
                for (let i = 0; i < proj.trail.length; i++) {
                    const t = proj.trail[i];
                    const alpha = (i / proj.trail.length) * 0.5;
                    const size = (i / proj.trail.length) * proj.size * 0.8;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Draw main projectile with glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = proj.color;
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Inner bright core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Draw monster shadows first (so they appear below monsters)
            for (const monster of game.monsters) {
                const s = monster.size;

                // Boss jump attack shadow - grows as boss descends
                if (monster.isBoss && monster.isJumping && monster.jumpTarget) {
                    const t = monster.jumpProgress;
                    const heightFactor = Math.sin(t * Math.PI); // 0 -> 1 -> 0
                    const shadowSize = s * (0.6 + t * 1.2); // Shadow grows as boss falls
                    const shadowAlphaJump = 0.4 + (1 - heightFactor) * 0.5; // Much more opaque

                    // Draw shadow at landing position - darker and bigger
                    ctx.save();
                    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlphaJump})`;
                    ctx.beginPath();
                    ctx.ellipse(monster.jumpTarget.x, monster.jumpTarget.y + s/2, shadowSize, shadowSize * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Pulsing warning ring
                    if (t > 0.5) {
                        const pulseAlpha = (t - 0.5) * 2 * 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 0, ${pulseAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(monster.jumpTarget.x, monster.jumpTarget.y + s/2, shadowSize * 1.5, shadowSize * 0.6, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else {
                    // Normal monster shadow - very visible
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(monster.x, monster.y + s/2 + 4, s * 0.8, s * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Draw monsters - unique designs per type
            for (const monster of game.monsters) {
                // Draw reassembling skeleton with bone fragments
                if (monster.isReassembling && monster.boneFragments) {
                    ctx.save();

                    // Draw scattered bone fragments flying back
                    for (const bone of monster.boneFragments) {
                        ctx.save();
                        ctx.translate(bone.x, bone.y);
                        ctx.rotate(bone.rotation);

                        // Bone shape
                        ctx.fillStyle = '#e2e8f0';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, bone.size, bone.size / 3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Bone ends
                        ctx.beginPath();
                        ctx.arc(-bone.size + 2, 0, bone.size / 2.5, 0, Math.PI * 2);
                        ctx.arc(bone.size - 2, 0, bone.size / 2.5, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }

                    // Draw ghostly skeleton outline at center
                    const alpha = 0.3 + Math.sin(game.animCounter * 0.2) * 0.2;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#94a3b8';
                    ctx.beginPath();
                    ctx.arc(monster.x, monster.y, monster.size / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Glowing effect
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(monster.x, monster.y, monster.size / 2 + 5 + Math.sin(game.animCounter * 0.3) * 3, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                    continue; // Skip normal rendering
                }

                const bounce = Math.sin(monster.animFrame) * 2;
                const flash = monster.flashTimer > 0;
                const isBoss = monster.isBoss || false;
                const isAttacking = monster.isAttacking || false;
                const style = monster.style || 'goblin';
                let monsterY = monster.y + bounce;

                // Smooth attack animation with easing
                let attackScale = 1;
                if (isAttacking) {
                    const attackProgress = monster.attackFrame / 15;
                    attackScale = 1 + easing.easeOutQuad(Math.sin(attackProgress * Math.PI)) * 0.25;
                }

                // Fall-Animation: Monster schrumpft wenn es ins Void fällt
                let monsterAlpha = 1;
                let fallScale = 1;
                if (monster.isFalling) {
                    fallScale = 1 - monster.fallProgress * 0.9;
                    monsterAlpha = 1 - monster.fallProgress * 0.8;
                }

                ctx.shadowBlur = 0;
                const bodyColor = flash ? '#FFFFFF' : monster.color;
                const darkColor = flash ? '#CCCCCC' : (monster.colorDark || monster.color);

                ctx.save();
                ctx.globalAlpha = monsterAlpha;
                ctx.translate(monster.x, monsterY);
                ctx.scale(attackScale * fallScale, attackScale * fallScale);
                ctx.translate(-monster.x, -monsterY);

                const s = monster.size;
                const x = monster.x;
                const y = monsterY;

                if (isBoss) {
                    // BOSS - Dungeon Lord
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Horns
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x - s/2 - 4, y - s/2 - 8, 6, 10);
                    ctx.fillRect(x + s/2 - 2, y - s/2 - 8, 6, 10);

                    // Crown
                    ctx.fillRect(x - 12, y - s/2 - 10, 24, 4);
                    ctx.fillRect(x - 10, y - s/2 - 14, 4, 4);
                    ctx.fillRect(x - 2, y - s/2 - 16, 4, 6);
                    ctx.fillRect(x + 6, y - s/2 - 14, 4, 4);

                    // Eyes - glowing
                    ctx.fillStyle = isAttacking ? '#FFFF00' : '#FF0000';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.fillRect(x - 10, y - 6, 6, 6);
                    ctx.fillRect(x + 4, y - 6, 6, 6);
                    ctx.shadowBlur = 0;

                    // Mouth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 8, y + 6, 16, isAttacking ? 8 : 4);

                } else if (style === 'goblin') {
                    // GOBLIN - Small, green, pointy ears, dagger
                    const footAnim = Math.sin(monster.animFrame * 2) * 2;

                    // Body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Pointy ears
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x - s/2 - 2, y - 2);
                    ctx.lineTo(x - s/2 - 6, y - 8);
                    ctx.lineTo(x - s/2, y - 4);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + s/2 + 2, y - 2);
                    ctx.lineTo(x + s/2 + 6, y - 8);
                    ctx.lineTo(x + s/2, y - 4);
                    ctx.fill();

                    // Eyes - beady
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(x - 4, y - 3, 3, 3);
                    ctx.fillRect(x + 1, y - 3, 3, 3);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 3, y - 2, 2, 2);
                    ctx.fillRect(x + 2, y - 2, 2, 2);

                    // Snout/nose
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - 2, y + 1, 4, 3);

                    // Draw equipped weapon
                    const gobWeapon = monster.equippedWeapon;
                    if (gobWeapon) {
                        const wStyle = gobWeapon.style;
                        const weaponSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 30 : 0;
                        ctx.save();
                        ctx.translate(x + s/2, y);
                        ctx.rotate((weaponSwing * Math.PI) / 180);
                        if (wStyle === 'dagger' || wStyle === 'poison_dagger') {
                            ctx.fillStyle = wStyle === 'poison_dagger' ? '#22c55e' : '#C0C0C0';
                            ctx.fillRect(2, -2, 8, 3);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -2, 3, 3);
                        } else if (wStyle === 'rusty_sword' || wStyle === 'sword') {
                            ctx.fillStyle = wStyle === 'rusty_sword' ? '#8B7355' : '#C0C0C0';
                            ctx.fillRect(2, -3, 12, 3);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -4, 3, 5);
                        }
                        ctx.restore();
                    }

                    // Feet
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 - 1 + footAnim, y + s/2, 4, 3);
                    ctx.fillRect(x + s/2 - 3 - footAnim, y + s/2, 4, 3);

                } else if (style === 'skeleton') {
                    // SKELETON - Boney, skull head, sword
                    const footAnim = Math.sin(monster.animFrame * 1.5) * 2;

                    // Ribcage body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2 + 2, s, s - 4);
                    // Ribs
                    ctx.fillStyle = darkColor;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(x - s/2 + 2, y - s/2 + 4 + i * 4, s - 4, 2);
                    }

                    // Skull
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2 - 1, y - s/2 - 6, s + 2, 8);

                    // Eye sockets
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 5, y - s/2 - 3, 4, 4);
                    ctx.fillRect(x + 1, y - s/2 - 3, 4, 4);

                    // Jaw
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - 4, y - s/2 + 1, 8, 2);

                    // Draw equipped weapon
                    const skelWeapon = monster.equippedWeapon;
                    const skelSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 40 : 0;
                    ctx.save();
                    ctx.translate(x + s/2 + 1, y);
                    ctx.rotate((skelSwing * Math.PI) / 180);
                    if (skelWeapon) {
                        const wStyle = skelWeapon.style;
                        if (wStyle === 'bone') {
                            ctx.fillStyle = '#e2e8f0';
                            ctx.fillRect(0, -8, 3, 16);
                            ctx.fillStyle = '#94a3b8';
                            ctx.fillRect(-2, -2, 7, 3);
                        } else if (wStyle === 'rusty_sword' || wStyle === 'sword') {
                            ctx.fillStyle = wStyle === 'rusty_sword' ? '#8B7355' : '#A0A0A0';
                            ctx.fillRect(0, -8, 3, 16);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-2, -2, 7, 3);
                        } else if (wStyle === 'spear') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -12, 2, 20);
                            ctx.fillStyle = '#A0A0A0';
                            ctx.beginPath();
                            ctx.moveTo(1, -16);
                            ctx.lineTo(-2, -10);
                            ctx.lineTo(4, -10);
                            ctx.fill();
                        }
                    } else {
                        // Default sword if no weapon
                        ctx.fillStyle = '#A0A0A0';
                        ctx.fillRect(0, -8, 3, 16);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(-2, -2, 7, 3);
                    }
                    ctx.restore();

                    // Boney legs
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - 4 + footAnim, y + s/2 - 2, 3, 8);
                    ctx.fillRect(x + 1 - footAnim, y + s/2 - 2, 3, 8);

                } else if (style === 'orc') {
                    // ORC - Big, muscular, green, axe
                    const footAnim = Math.sin(monster.animFrame * 1.2) * 3;

                    // Large body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Muscular shoulders
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 - 4, y - s/2 + 2, 5, 8);
                    ctx.fillRect(x + s/2 - 1, y - s/2 + 2, 5, 8);

                    // Head (smaller than body)
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - 6, y - s/2 - 8, 12, 10);

                    // Tusks
                    ctx.fillStyle = '#FFFACD';
                    ctx.fillRect(x - 6, y - s/2 - 2, 3, 6);
                    ctx.fillRect(x + 3, y - s/2 - 2, 3, 6);

                    // Angry eyes
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(x - 4, y - s/2 - 5, 3, 2);
                    ctx.fillRect(x + 1, y - s/2 - 5, 3, 2);

                    // Draw equipped weapon
                    const orcWeapon = monster.equippedWeapon;
                    const orcSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 50 : 0;
                    ctx.save();
                    ctx.translate(x + s/2 + 3, y);
                    ctx.rotate((orcSwing * Math.PI) / 180);
                    if (orcWeapon) {
                        const wStyle = orcWeapon.style;
                        if (wStyle === 'axe' || wStyle === 'battleaxe') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -10, 4, 20);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-2, -12, 10, 6);
                            ctx.fillRect(-2, 6, 10, 6);
                        } else if (wStyle === 'hammer') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(1, -8, 3, 18);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-3, -12, 11, 8);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-3, -12, 11, 2);
                        }
                    } else {
                        // Default axe
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(0, -10, 4, 20);
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-2, -12, 10, 6);
                        ctx.fillRect(-2, 6, 10, 6);
                    }
                    ctx.restore();

                    // Feet
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 + footAnim, y + s/2, 6, 4);
                    ctx.fillRect(x + s/2 - 6 - footAnim, y + s/2, 6, 4);

                } else if (style === 'mage') {
                    // DARK MAGE - Robed wizard with staff
                    const floatOffset = Math.sin(monster.animFrame * 0.8) * 2;

                    // Magical aura (when attacking)
                    if (isAttacking) {
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = monster.projectileColor || '#c084fc';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = monster.projectileColor || '#c084fc';
                        ctx.beginPath();
                        ctx.arc(x, y - floatOffset, s + 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }

                    // Robe body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2 + 2 - floatOffset, s, s + 4);

                    // Robe bottom (wider)
                    ctx.fillRect(x - s/2 - 2, y + s/2 - 2 - floatOffset, s + 4, 6);

                    // Robe trim
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x - s/2, y - floatOffset, s, 2);

                    // Hood/Head
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 + 2, y - s/2 - 6 - floatOffset, s - 4, 10);

                    // Hood point
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y - s/2 - 6 - floatOffset);
                    ctx.lineTo(x, y - s/2 - 12 - floatOffset);
                    ctx.lineTo(x + 4, y - s/2 - 6 - floatOffset);
                    ctx.fill();

                    // Face shadow
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(x - 4, y - s/2 - 2 - floatOffset, 8, 6);

                    // Glowing eyes
                    ctx.fillStyle = '#00FFFF';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#00FFFF';
                    ctx.fillRect(x - 4, y - s/2 - floatOffset, 3, 2);
                    ctx.fillRect(x + 1, y - s/2 - floatOffset, 3, 2);
                    ctx.shadowBlur = 0;

                    // Arms
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2 - 3, y - 2 - floatOffset, 4, 8);
                    ctx.fillRect(x + s/2 - 1, y - 2 - floatOffset, 4, 8);

                    // Hands
                    ctx.fillStyle = '#2a2a4a';
                    ctx.fillRect(x - s/2 - 3, y + 5 - floatOffset, 4, 3);
                    ctx.fillRect(x + s/2 - 1, y + 5 - floatOffset, 4, 3);

                    // Staff
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(x + s/2 + 4, y - s/2 - 8 - floatOffset, 3, s + 20);

                    // Staff orb with glow
                    const orbPulse = Math.sin(monster.animFrame * 2) * 2;
                    ctx.fillStyle = monster.projectileColor || '#c084fc';
                    ctx.shadowBlur = 12 + orbPulse;
                    ctx.shadowColor = monster.projectileColor || '#c084fc';
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5, y - s/2 - 12 - floatOffset, 6 + orbPulse/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5, y - s/2 - 12 - floatOffset, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                } else if (style === 'demon') {
                    // DEMON - Red, wings, horns, claws
                    const wingFlap = Math.sin(monster.animFrame * 3) * 0.3;

                    // Wings
                    ctx.fillStyle = darkColor;
                    ctx.save();
                    ctx.translate(x - s/2 - 2, y);
                    ctx.rotate(-0.3 - wingFlap);
                    ctx.fillRect(-12, -8, 14, 16);
                    ctx.restore();
                    ctx.save();
                    ctx.translate(x + s/2 + 2, y);
                    ctx.rotate(0.3 + wingFlap);
                    ctx.fillRect(-2, -8, 14, 16);
                    ctx.restore();

                    // Body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Horns
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(x - s/2, y - s/2);
                    ctx.lineTo(x - s/2 - 4, y - s/2 - 10);
                    ctx.lineTo(x - s/2 + 4, y - s/2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y - s/2);
                    ctx.lineTo(x + s/2 + 4, y - s/2 - 10);
                    ctx.lineTo(x + s/2 - 4, y - s/2);
                    ctx.fill();

                    // Glowing eyes
                    ctx.fillStyle = '#FFFF00';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#FF6600';
                    ctx.fillRect(x - 6, y - 4, 5, 4);
                    ctx.fillRect(x + 1, y - 4, 5, 4);
                    ctx.shadowBlur = 0;

                    // Fanged mouth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 5, y + 3, 10, 4);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x - 4, y + 3, 2, 3);
                    ctx.fillRect(x + 2, y + 3, 2, 3);

                    // Claws
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x - s/2 - 4, y + s/2 - 2, 3, 6);
                    ctx.fillRect(x + s/2 + 1, y + s/2 - 2, 3, 6);
                }

                ctx.restore();

                // HP bar
                const barWidth = isBoss ? 60 : 35;
                const barHeight = isBoss ? 8 : 5;
                const barY = monster.y - monster.size - (isBoss ? 30 : 20);

                ctx.fillStyle = '#000000';
                ctx.fillRect(monster.x - barWidth/2 - 1, barY - 1, barWidth + 2, barHeight + 2);

                const hpPercent = monster.hp / monster.maxHp;
                const hpColor = hpPercent > 0.5 ? '#00D000' : hpPercent > 0.25 ? '#FFA500' : '#FF0000';
                ctx.fillStyle = hpColor;
                ctx.fillRect(monster.x - barWidth/2, barY, hpPercent * barWidth, barHeight);

                // HP Zahlen-Anzeige
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = isBoss ? 'bold 11px "Courier New"' : 'bold 9px "Courier New"';
                ctx.textAlign = 'center';
                const hpText = `${Math.ceil(monster.hp)}/${monster.maxHp}`;
                ctx.strokeText(hpText, monster.x, barY + barHeight + 10);
                ctx.fillText(hpText, monster.x, barY + barHeight + 10);

                if (isBoss) {
                    ctx.font = 'bold 12px "Courier New"';
                    ctx.lineWidth = 3;
                    ctx.strokeText(monster.name, monster.x, barY - 8);
                    ctx.fillText(monster.name, monster.x, barY - 8);
                }
            }

            // Draw dying monsters with smooth death animation
            for (const monster of game.dyingMonsters) {
                const rawProgress = monster.deathFrame / 45;
                const deathProgress = easing.easeOutQuad(Math.min(rawProgress, 1));

                // Smooth scale with slight bounce at start
                const scaleProgress = easing.easeInQuad(rawProgress);
                const scale = Math.max(0, 1.2 - scaleProgress * 1.2);

                // Smooth alpha fade
                const alpha = Math.max(0, 1 - easing.easeInQuad(rawProgress));

                // Smooth rotation with easing
                const rotation = easing.easeOutQuad(rawProgress) * Math.PI * 1.5;

                // Float upward as dying
                const floatY = monster.y - easing.easeOutQuad(rawProgress) * 20;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(monster.x, floatY);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Draw dying monster with flash effect
                const flashIntensity = Math.sin(monster.deathFrame * 0.5) * 0.3 + 0.7;
                ctx.fillStyle = monster.color;
                ctx.globalAlpha = alpha * flashIntensity;
                ctx.fillRect(-monster.size/2, -monster.size/2, monster.size, monster.size);

                ctx.restore();
            }

            // Draw player - generic adventurer with animations
            // Fall-Animation: Spieler wird kleiner wenn er fällt
            let playerScale = 1;
            let playerAlpha = 1;
            if (game.player.isFalling) {
                playerScale = 1 - game.player.fallProgress * 0.9; // Schrumpft auf 10%
                playerAlpha = 1 - game.player.fallProgress * 0.8; // Wird transparent
            }

            // Smoke bomb invisibility effect
            if (game.player.isInvisible) {
                playerAlpha = Math.min(playerAlpha, 0.35);
            }

            const playerY = game.player.y;
            const isMoving = game.player.isMoving;
            const walkFrame = game.player.walkFrame;
            const facingLeft = game.player.facingLeft;
            const isAttacking = game.player.isAttacking;
            const isDying = game.player.isDying;

            // Update attack animation with smoother timing
            if (isAttacking) {
                game.player.attackFrame++;
                if (game.player.attackFrame > 25) {
                    game.player.isAttacking = false;
                }
            }

            // Update player flash timer
            if (game.player.flashTimer > 0) {
                game.player.flashTimer--;
            }

            // Update level up animation
            if (game.player.levelUpAnim > 0) {
                game.player.levelUpAnim--;
            }

            // Draw dash afterimages (ghost trail)
            for (const afterimage of game.dashAfterimages) {
                ctx.save();
                ctx.globalAlpha = afterimage.alpha;
                ctx.translate(afterimage.x, afterimage.y);
                if (afterimage.facingLeft) {
                    ctx.scale(-1, 1);
                }
                ctx.scale(afterimage.scale, afterimage.scale);

                // Simple ghost silhouette
                ctx.fillStyle = '#60a5fa';
                ctx.shadowColor = '#60a5fa';
                ctx.shadowBlur = 10;
                // Head
                ctx.fillRect(-5, -10, 10, 10);
                // Body
                ctx.fillRect(-7, 1, 14, 12);
                // Legs
                ctx.fillRect(-5, 13, 4, 8);
                ctx.fillRect(1, 13, 4, 8);

                ctx.restore();
            }

            // Draw player shadow - very visible
            if (!isDying) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.beginPath();
                ctx.ellipse(game.player.x, playerY + 24, 16, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.save();

            // Fall-Animation anwenden (Spieler schrumpft und wird transparent)
            if (game.player.isFalling) {
                ctx.globalAlpha = playerAlpha;
                ctx.translate(game.player.x, playerY);
                ctx.scale(playerScale, playerScale);
                ctx.translate(-game.player.x, -playerY);
            }

            // Death animation with smooth easing
            if (isDying) {
                const rawProgress = game.player.deathFrame / 60;
                const deathProgress = easing.easeInQuad(rawProgress);
                const alphaProgress = easing.easeOutQuad(rawProgress);

                ctx.globalAlpha = Math.max(0, 1 - alphaProgress);
                ctx.translate(game.player.x, playerY);
                ctx.rotate(easing.easeInOutQuad(rawProgress) * Math.PI * 2);
                const scale = Math.max(0.1, 1 - deathProgress * 0.8);
                ctx.scale(scale, scale);
                ctx.translate(-game.player.x, -playerY);
            }

            // Smooth flash effect when taking damage (sine wave for smooth pulsing)
            if (game.player.flashTimer > 0) {
                const flashProgress = game.player.flashTimer / 15;
                const flashAlpha = 0.4 + Math.sin(game.player.flashTimer * 0.8) * 0.3;
                ctx.globalAlpha *= flashAlpha;
            }

            // Flip horizontally if facing left
            if (facingLeft) {
                ctx.translate(game.player.x, 0);
                ctx.scale(-1, 1);
                ctx.translate(-game.player.x, 0);
            }

            // Smooth walking bob using sine with easing
            const walkCycle = easing.easeInOutSine((Math.sin(walkFrame * 1.8) + 1) / 2);
            const walkBob = isMoving ? (walkCycle - 0.5) * 3 : 0;
            const adjustedY = playerY + walkBob;

            // Smooth leg animation using eased sine waves
            const legCycle = Math.sin(walkFrame * 1.5);
            const leftLegOffset = isMoving ? easing.easeInOutSine((legCycle + 1) / 2) * 5 - 2.5 : 0;
            const rightLegOffset = isMoving ? easing.easeInOutSine((-legCycle + 1) / 2) * 5 - 2.5 : 0;

            // Smooth attack arm swing with easing - TOP TO BOTTOM slash
            let attackSwing = 0;
            let attackArmRaise = 0;
            if (isAttacking) {
                const attackProgress = game.player.attackFrame / 25;
                // Wind-up (raise arm), then slash down
                if (attackProgress < 0.15) {
                    // Wind-up: raise arm
                    const windUp = easing.easeOutQuad(attackProgress / 0.15);
                    attackSwing = -30 * windUp;  // Rotate arm back/up
                    attackArmRaise = -8 * windUp;  // Raise arm position
                } else if (attackProgress < 0.4) {
                    // Slash down: fast swing from top to bottom
                    const slash = easing.easeOutQuad((attackProgress - 0.15) / 0.25);
                    attackSwing = -30 + 90 * slash;  // Swing from -30 to +60
                    attackArmRaise = -8 + 12 * slash;  // Move arm down
                } else {
                    // Recovery: return to neutral
                    const recovery = easing.easeInOutQuad((attackProgress - 0.4) / 0.6);
                    attackSwing = 60 * (1 - recovery);
                    attackArmRaise = 4 * (1 - recovery);
                }
            }

            // Head
            ctx.fillStyle = '#FFDBAC';
            ctx.fillRect(game.player.x - 5, adjustedY - 10, 10, 10);

            // Hair
            ctx.fillStyle = '#4a2c2a';
            ctx.fillRect(game.player.x - 6, adjustedY - 12, 12, 3);

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(game.player.x - 3, adjustedY - 6, 2, 2);
            ctx.fillRect(game.player.x + 1, adjustedY - 6, 2, 2);

            // Armor chest - silver/gray
            ctx.fillStyle = '#a8a8a8';
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 14, 10);

            // Armor highlight
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 14, 2);
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 2, 10);

            // Belt
            ctx.fillStyle = '#654321';
            ctx.fillRect(game.player.x - 7, adjustedY + 10, 14, 3);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(game.player.x - 2, adjustedY + 10, 4, 3);

            // Get weapon info for animation decisions
            const weapon = game.player.equippedWeapon;
            const weaponStyle = weapon ? weapon.style : null;
            const isShooting = game.player.isShooting;
            const isStaffWeapon = weaponStyle === 'staff' || weaponStyle === 'fire_staff';

            // Back arm (behind body) - both arms raised when shooting
            ctx.fillStyle = '#7a7a7a';
            if (isShooting && isStaffWeapon) {
                // Back arm raised for casting
                ctx.save();
                ctx.translate(game.player.x - 8, adjustedY + 4);
                const castProgress = game.player.shootFrame / 30;
                const armRaise = Math.sin(castProgress * Math.PI) * 40;
                ctx.rotate((armRaise * Math.PI) / 180);
                ctx.fillRect(-1, -4, 3, 8);
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(-1, 4, 3, 3);
                ctx.restore();
            } else {
                ctx.fillRect(game.player.x - 10, adjustedY + 2, 3, 8);
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(game.player.x - 10, adjustedY + 10, 3, 3);
            }

            // Front arm with attack/shooting animation
            ctx.save();
            if (isShooting && isStaffWeapon) {
                // Shooting pose - arm extended forward
                const shootProgress = game.player.shootFrame / 30;
                const recoil = shootProgress < 0.2 ? easing.easeOutQuad(shootProgress / 0.2) * 15 :
                              easing.easeInQuad(1 - (shootProgress - 0.2) / 0.8) * 15;
                ctx.translate(game.player.x + 8 + recoil, adjustedY + 2);
                ctx.rotate((-70 * Math.PI) / 180);  // Arm pointing forward
            } else {
                // Top-to-bottom slash: arm raises up then swings down
                ctx.translate(game.player.x + 8, adjustedY + 6 + attackArmRaise);
                ctx.rotate((-attackSwing * Math.PI) / 180);
            }
            ctx.fillStyle = '#8a8a8a';
            ctx.fillRect(-1, -4, 3, 8);
            ctx.fillStyle = '#FFDBAC';
            ctx.fillRect(-1, 4, 3, 3);

            const showWeapon = isAttacking || isShooting || game.player.attackCooldown > 20 || weapon;

            if (showWeapon) {
                if (!weaponStyle) {
                    // REALISTIC BOXING ANIMATION - Jab/Cross with wind-up
                    const punchProgress = game.player.attackFrame / 25;

                    // Calculate punch direction toward enemy
                    const punchAngle = game.player.facingAngle || (facingLeft ? Math.PI : 0);
                    const localAngle = punchAngle - (facingLeft ? Math.PI : 0);

                    // Animation phases: wind-up (0-0.15), punch (0.15-0.4), hold (0.4-0.6), return (0.6-1.0)
                    let armExtend = 0;
                    let armAngleOffset = 0;
                    let fistRotation = 0;
                    let shoulderPull = 0;

                    // Max Extension = 8 Pixel (passend zur 28px Faust-Reichweite)
                    const maxExtend = 8;

                    if (isAttacking) {
                        if (punchProgress < 0.15) {
                            // Wind-up: Arm zieht zurück, Schulter dreht
                            const windUp = easing.easeOutQuad(punchProgress / 0.15);
                            armExtend = -3 * windUp;
                            armAngleOffset = -0.3 * windUp;
                            shoulderPull = 2 * windUp;
                        } else if (punchProgress < 0.4) {
                            // Punch: Schnelle Streckung mit Körperdrehung
                            const punch = easing.easeOutQuad((punchProgress - 0.15) / 0.25);
                            armExtend = -3 + (maxExtend + 3) * punch;
                            armAngleOffset = -0.3 + 0.4 * punch;
                            fistRotation = 0.2 * punch;
                            shoulderPull = 2 - 3 * punch;
                        } else if (punchProgress < 0.6) {
                            // Hold: Volle Streckung (nur bis Reichweitengrenze)
                            armExtend = maxExtend;
                            armAngleOffset = 0.1;
                            fistRotation = 0.2;
                            shoulderPull = -1;
                        } else {
                            // Return: Arm zurück in Grundstellung
                            const ret = easing.easeInQuad((punchProgress - 0.6) / 0.4);
                            armExtend = maxExtend * (1 - ret);
                            armAngleOffset = 0.1 * (1 - ret);
                            fistRotation = 0.2 * (1 - ret);
                            shoulderPull = -1 * (1 - ret);
                        }
                    }

                    ctx.save();
                    // Schulter-Position mit Bewegung
                    ctx.translate(2 + shoulderPull, 4);
                    ctx.rotate(localAngle + armAngleOffset);

                    // Oberarm
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-2, 0, 4, 6);

                    // Ellbogen-Gelenk
                    ctx.fillStyle = '#E8C8A0';
                    ctx.beginPath();
                    ctx.arc(0, 6, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Unterarm (streckt sich)
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-2, 5, 4, 6 + armExtend);

                    // Faust am Ende mit Rotation
                    ctx.save();
                    ctx.translate(0, 10 + armExtend);
                    ctx.rotate(fistRotation);

                    // Faust-Körper
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-4, 0, 8, 7);

                    // Knöchel (oben)
                    ctx.fillStyle = '#E8C8A0';
                    ctx.fillRect(-4, 0, 8, 2);

                    // Finger-Linien
                    ctx.fillStyle = '#D4B090';
                    ctx.fillRect(-2, 2, 1, 4);
                    ctx.fillRect(0, 2, 1, 4);
                    ctx.fillRect(2, 2, 1, 4);

                    // Daumen (seitlich)
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-5, 2, 2, 4);

                    ctx.restore();

                    // Impact-Effekt beim Treffen
                    if (isAttacking && punchProgress > 0.2 && punchProgress < 0.5) {
                        const impactIntensity = 1 - Math.abs(punchProgress - 0.35) / 0.15;
                        ctx.globalAlpha = impactIntensity * 0.8;

                        // Schockwellen
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            const waveRadius = 8 + i * 6 + armExtend;
                            ctx.beginPath();
                            ctx.arc(0, 12 + armExtend, waveRadius * impactIntensity, -0.5, 0.5);
                            ctx.stroke();
                        }

                        // Bewegungsunschärfe
                        ctx.fillStyle = 'rgba(255, 219, 172, 0.4)';
                        for (let i = 1; i <= 3; i++) {
                            ctx.globalAlpha = (0.3 / i) * impactIntensity;
                            ctx.fillRect(-3, 5 - i * 4, 6, 4);
                        }
                        ctx.globalAlpha = 1;
                    }

                    ctx.restore();
                } else if (weaponStyle === 'fire_staff') {
                    // Fire Staff - shoots fire projectiles
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(1, 3, 2, 22);

                    // Fire orb with shooting effect
                    const shootProgress = isShooting ? game.player.shootFrame / 30 : 0;
                    const orbPulse = isShooting ? 1 + Math.sin(shootProgress * Math.PI * 4) * 0.4 : 1;
                    const orbSize = 6 * orbPulse;

                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = isShooting ? 20 + shootProgress * 15 : 10;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner flame
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // Shooting burst effect
                    if (isShooting && shootProgress < 0.5) {
                        ctx.globalAlpha = 1 - shootProgress * 1.5;
                        // Fire rings expanding
                        for (let ring = 0; ring < 4; ring++) {
                            const ringProgress = shootProgress * 3 - ring * 0.08;
                            if (ringProgress > 0 && ringProgress < 1) {
                                const ringSize = 6 + ringProgress * 30;
                                ctx.strokeStyle = ring % 2 === 0 ? '#ff6600' : '#fbbf24';
                                ctx.lineWidth = 3 - ringProgress * 2;
                                ctx.beginPath();
                                ctx.arc(2, 26, ringSize, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        // Fire particles
                        for (let i = 0; i < 8; i++) {
                            const sparkAngle = (i / 8) * Math.PI * 2 + shootProgress * 8;
                            const sparkDist = 10 + shootProgress * 25;
                            ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ef4444';
                            ctx.beginPath();
                            ctx.arc(2 + Math.cos(sparkAngle) * sparkDist,
                                   26 + Math.sin(sparkAngle) * sparkDist,
                                   3 - shootProgress * 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    ctx.shadowBlur = 0;
                } else if (weaponStyle === 'flame') {
                    // Flammschwert - Detailed sword with fire effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff6600';
                    // Blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fillRect(0, 6, 4, 18);
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fillRect(1, 6, 2, 16);
                    // Flames on blade
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(-2, 10, 2, 6);
                    ctx.fillRect(4, 8, 2, 8);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(-1, 12, 1, 4);
                    ctx.fillRect(4, 10, 1, 5);
                    ctx.shadowBlur = 0;
                    // Sword tip
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(2, 24);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(4, 20);
                    ctx.closePath();
                    ctx.fill();
                    // Guard (golden)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-3, 4, 10, 3);
                    // Handle
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 0, 4, 5);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(1, 1, 2, 3);
                } else if (weaponStyle === 'dagger' || weaponStyle === 'poison_dagger') {
                    // Dagger
                    const color = weaponStyle === 'poison_dagger' ? '#22c55e' : '#C0C0C0';
                    ctx.fillStyle = color;
                    ctx.fillRect(1, 6, 2, 10);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 3, 4, 4);
                } else if (weaponStyle === 'axe' || weaponStyle === 'battleaxe') {
                    // Axe - Klinge am Ende des Schafts
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 18);  // Schaft
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(-3, 16, 8, 6);  // Axtkopf am Ende
                    ctx.fillRect(-4, 17, 2, 4);  // Axtklinge Erweiterung
                    // Glanzlicht
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(-3, 16, 8, 2);
                } else if (weaponStyle === 'hammer') {
                    // War Hammer - Kopf am Ende des Schafts
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 18);  // Schaft
                    ctx.fillStyle = '#606060';
                    ctx.fillRect(-3, 18, 10, 8);  // Hammerkopf am Ende
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(-3, 18, 10, 2);  // Glanzlicht
                } else if (weaponStyle === 'mace') {
                    // Streitkolben - Kugel am Ende des Schafts
                    // Holzgriff
                    ctx.fillStyle = '#5C4033';
                    ctx.fillRect(1, 4, 2, 16);  // Schaft
                    // Metallkopf (Kugel) am Ende
                    ctx.fillStyle = '#606060';
                    ctx.beginPath();
                    ctx.arc(2, 23, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // Glanzlicht auf Kugel
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.arc(0, 21, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Zacken/Flanken
                    ctx.fillStyle = '#505050';
                    ctx.fillRect(-5, 21, 4, 3);
                    ctx.fillRect(5, 21, 4, 3);
                    ctx.fillRect(0, 28, 3, 4);
                } else if (weaponStyle === 'spear' || weaponStyle === 'halberd') {
                    // Spear / Halberd - tip at end
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 24);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(2, 28);  // Tip at end of shaft
                    ctx.lineTo(-1, 22);
                    ctx.lineTo(5, 22);
                    ctx.closePath();
                    ctx.fill();
                    if (weaponStyle === 'halberd') {
                        ctx.fillRect(-3, 20, 8, 3);
                    }
                } else if (weaponStyle === 'staff') {
                    // Magic Staff - orb at end
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(1, 3, 2, 22);

                    // Staff orb with shooting effect
                    const shootProgress = isShooting ? game.player.shootFrame / 30 : 0;
                    const orbPulse = isShooting ? 1 + Math.sin(shootProgress * Math.PI * 4) * 0.3 : 1;
                    const orbSize = 5 * orbPulse;

                    ctx.fillStyle = '#c084fc';
                    ctx.shadowBlur = isShooting ? 15 + shootProgress * 10 : 6;
                    ctx.shadowColor = '#c084fc';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Shooting burst effect
                    if (isShooting && shootProgress < 0.4) {
                        ctx.globalAlpha = 1 - shootProgress * 2;
                        // Magic rings expanding
                        for (let ring = 0; ring < 3; ring++) {
                            const ringProgress = shootProgress * 3 - ring * 0.1;
                            if (ringProgress > 0 && ringProgress < 1) {
                                const ringSize = 5 + ringProgress * 25;
                                ctx.strokeStyle = '#c084fc';
                                ctx.lineWidth = 2 - ringProgress;
                                ctx.beginPath();
                                ctx.arc(2, 26, ringSize, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        // Sparkles
                        for (let i = 0; i < 6; i++) {
                            const sparkAngle = (i / 6) * Math.PI * 2 + shootProgress * 5;
                            const sparkDist = 8 + shootProgress * 20;
                            ctx.fillStyle = '#e9d5ff';
                            ctx.beginPath();
                            ctx.arc(2 + Math.cos(sparkAngle) * sparkDist,
                                   26 + Math.sin(sparkAngle) * sparkDist,
                                   2 - shootProgress * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    ctx.shadowBlur = 0;
                } else if (weaponStyle === 'claw') {
                    // Demon Claw - claws extend outward
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-1, 5, 6, 5);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-2, 10, 2, 10);
                    ctx.fillRect(1, 10, 2, 12);
                    ctx.fillRect(4, 10, 2, 10);
                } else if (weaponStyle === 'bone') {
                    // Bone Sword
                    ctx.fillStyle = '#e2e8f0';
                    ctx.fillRect(0, 6, 3, 16);
                    ctx.fillRect(-2, 6, 2, 4);
                    ctx.fillRect(3, 6, 2, 4);
                    ctx.fillStyle = '#94a3b8';
                    ctx.fillRect(0, 3, 3, 4);
                } else if (weaponStyle === 'rusty_sword') {
                    // Rusty Sword - corroded and worn
                    // Blade with rust spots
                    ctx.fillStyle = '#8B7355';  // Rusty brown-gray
                    ctx.fillRect(-1, 6, 4, 20);
                    // Rust patches
                    ctx.fillStyle = '#A0522D';  // Sienna (rust color)
                    ctx.fillRect(-1, 8, 2, 3);
                    ctx.fillRect(1, 14, 2, 4);
                    ctx.fillRect(-1, 20, 3, 2);
                    // Dark rust/pitting
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(0, 10, 1, 2);
                    ctx.fillRect(2, 17, 1, 2);
                    ctx.fillRect(-1, 22, 1, 2);
                    // Worn tip
                    ctx.fillStyle = '#8B7355';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 28);  // Shorter, chipped tip
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Dull edge highlight
                    ctx.fillStyle = '#9B8B7B';
                    ctx.fillRect(-1, 8, 1, 12);
                    // Old worn crossguard
                    ctx.fillStyle = '#5C4033';  // Tarnished
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#6B5033';
                    ctx.fillRect(-3, 4, 8, 1);
                    // Worn leather grip
                    ctx.fillStyle = '#3a2718';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#4a3020';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Dented pommel
                    ctx.fillStyle = '#5C4033';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (weaponStyle === 'iron_sword') {
                    // Iron Sword - solid iron blade
                    // Blade with slight gray tone
                    ctx.fillStyle = '#9CA3AF';  // Iron gray
                    ctx.fillRect(-1, 6, 4, 20);
                    // Edge highlight
                    ctx.fillStyle = '#B8C0CC';
                    ctx.fillRect(-1, 8, 1, 16);
                    // Fuller (blood groove)
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(0, 8, 1, 14);
                    // Tip
                    ctx.fillStyle = '#9CA3AF';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 30);
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Simple iron crossguard
                    ctx.fillStyle = '#4B5563';
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(-3, 4, 8, 1);
                    // Leather wrapped grip
                    ctx.fillStyle = '#5C4033';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#6B5043';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Iron pommel
                    ctx.fillStyle = '#4B5563';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (weaponStyle === 'steel_sword') {
                    // Steel Sword - polished steel blade
                    // Bright polished blade
                    ctx.fillStyle = '#E5E7EB';  // Bright steel
                    ctx.fillRect(-1, 6, 4, 20);
                    // Bright edge highlight
                    ctx.fillStyle = '#F3F4F6';
                    ctx.fillRect(-1, 8, 1, 16);
                    // Fuller with shine
                    ctx.fillStyle = '#9CA3AF';
                    ctx.fillRect(0, 8, 1, 14);
                    // Sharp tip
                    ctx.fillStyle = '#E5E7EB';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 31);  // Longer tip
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Decorative steel crossguard
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(-5, 4, 12, 3);
                    ctx.fillStyle = '#9CA3AF';
                    ctx.fillRect(-4, 4, 10, 1);
                    // Blue leather grip
                    ctx.fillStyle = '#1E3A5F';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#2B4A6F';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Steel pommel with gem
                    ctx.fillStyle = '#6B7280';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#3B82F6';  // Blue gem
                    ctx.beginPath();
                    ctx.arc(1, -1, 1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Realistic Sword Design
                    // Klinge (Blade) mit Hohlkehle
                    ctx.fillStyle = '#D8D8D8';  // Helle Klingenseite
                    ctx.fillRect(-1, 6, 4, 20);
                    ctx.fillStyle = '#A8A8A8';  // Dunkle Klingenseite (Tiefe)
                    ctx.fillRect(0, 7, 1, 18);
                    // Klingenspitze
                    ctx.fillStyle = '#D8D8D8';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 30);
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Schneide Glanz
                    ctx.fillStyle = '#F0F0F0';
                    ctx.fillRect(-1, 8, 1, 16);

                    // Parierstange (Crossguard)
                    ctx.fillStyle = '#B8860B';  // Dunkles Gold
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#DAA520';  // Glanz
                    ctx.fillRect(-3, 4, 8, 1);

                    // Griff (Handle) mit Wicklung
                    ctx.fillStyle = '#4a3728';  // Dunkles Leder
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#5c4033';  // Leder Streifen
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);

                    // Knauf (Pommel)
                    ctx.fillStyle = '#B8860B';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#DAA520';
                    ctx.beginPath();
                    ctx.arc(0.5, -1.5, 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // WEAPON SWING TRAIL EFFECT (for all weapons when attacking)
                if (isAttacking && weaponStyle) {
                    const swingProgress = game.player.attackFrame / 25;
                    if (swingProgress < 0.5) {
                        // Determine trail color based on weapon
                        let trailColor = 'rgba(200, 200, 200, ';  // Default silver
                        if (weaponStyle === 'flame' || weaponStyle === 'fire_staff') {
                            trailColor = 'rgba(255, 100, 0, ';
                        } else if (weaponStyle === 'poison_dagger') {
                            trailColor = 'rgba(34, 197, 94, ';
                        } else if (weaponStyle === 'staff') {
                            trailColor = 'rgba(192, 132, 252, ';
                        } else if (weaponStyle === 'claw') {
                            trailColor = 'rgba(239, 68, 68, ';
                        }

                        // Draw swing arc trail
                        ctx.globalAlpha = 0.6 - swingProgress;
                        for (let i = 0; i < 5; i++) {
                            const trailAlpha = (1 - i / 5) * (0.4 - swingProgress * 0.6);
                            ctx.fillStyle = trailColor + trailAlpha + ')';
                            const trailAngle = (swingProgress * 0.6 - i * 0.08) * Math.PI;
                            const trailDist = 15 + (weaponStyle === 'spear' || weaponStyle === 'halberd' ? 10 : 0);
                            ctx.beginPath();
                            ctx.arc(1, 10, trailDist + i * 2, -Math.PI/4, Math.PI/4);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            }
            ctx.restore();

            // Legs with walking animation
            ctx.fillStyle = '#2c2c2c';
            ctx.fillRect(game.player.x - 5, adjustedY + 13 + leftLegOffset, 4, 8);
            ctx.fillRect(game.player.x + 1, adjustedY + 13 + rightLegOffset, 4, 8);

            // Boots
            ctx.fillStyle = '#654321';
            ctx.fillRect(game.player.x - 6, adjustedY + 21 + leftLegOffset, 5, 4);
            ctx.fillRect(game.player.x + 1, adjustedY + 21 + rightLegOffset, 5, 4);

            ctx.restore();

            // Level-up aura effect with smooth easing
            if (game.player.levelUpAnim > 0) {
                const rawProgress = 1 - (game.player.levelUpAnim / 60);
                const auraProgress = easing.easeOutQuad(rawProgress);
                const auraRadius = 20 + easing.easeOutBack(Math.min(rawProgress * 1.2, 1)) * 50;
                const auraAlpha = easing.easeInQuad(1 - rawProgress);

                ctx.save();

                // Multiple expanding rings
                for (let ring = 0; ring < 3; ring++) {
                    const ringDelay = ring * 0.15;
                    const ringProgress = Math.max(0, auraProgress - ringDelay);
                    const ringRadius = 20 + easing.easeOutQuad(ringProgress) * (40 + ring * 15);
                    const ringAlpha = easing.easeInQuad(Math.max(0, 1 - ringProgress * 1.3));

                    ctx.globalAlpha = ringAlpha * 0.4;
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 4 - ring;
                    ctx.beginPath();
                    ctx.arc(game.player.x, playerY + 5, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Inner glow pulse
                ctx.globalAlpha = auraAlpha * 0.4;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, auraRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // Drinking animation
            if (game.player.isDrinking && !game.player.isDying) {
                const drinkProgress = game.player.drinkFrame / 45;
                const potionColor = game.player.drinkColor || '#ff1493';

                ctx.save();
                ctx.translate(game.player.x, playerY);

                // Animation Phasen: Flasche heben (0-0.3), trinken (0.3-0.7), absetzen (0.7-1.0)
                let bottleX = 12;
                let bottleY = 0;
                let bottleRotation = 0;
                let bottleScale = 1;
                let liquidLevel = 1;

                if (drinkProgress < 0.3) {
                    // Flasche zum Mund heben
                    const lift = easing.easeOutQuad(drinkProgress / 0.3);
                    bottleX = 12 - 8 * lift;
                    bottleY = -5 * lift;
                    bottleRotation = -0.3 * lift;
                } else if (drinkProgress < 0.7) {
                    // Trinken - Flasche kippen
                    const drink = (drinkProgress - 0.3) / 0.4;
                    bottleX = 4;
                    bottleY = -5 - 3 * Math.sin(drink * Math.PI);
                    bottleRotation = -0.3 - 0.8 * easing.easeInOutQuad(drink);
                    liquidLevel = 1 - drink;
                } else {
                    // Flasche absetzen und verschwinden
                    const put = easing.easeInQuad((drinkProgress - 0.7) / 0.3);
                    bottleX = 4 + 8 * put;
                    bottleY = -5 + 10 * put;
                    bottleRotation = -1.1 + 0.5 * put;
                    bottleScale = 1 - put * 0.8;
                    liquidLevel = 0;
                }

                // Flasche zeichnen
                ctx.save();
                ctx.translate(bottleX, bottleY);
                ctx.rotate(bottleRotation);
                ctx.scale(bottleScale, bottleScale);

                // Flaschenhals
                ctx.fillStyle = '#333';
                ctx.fillRect(-2, -12, 4, 5);

                // Flaschenkörper
                ctx.fillStyle = '#222';
                ctx.fillRect(-5, -7, 10, 14);

                // Flüssigkeit
                if (liquidLevel > 0) {
                    ctx.fillStyle = potionColor;
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = potionColor;
                    const liquidHeight = 10 * liquidLevel;
                    ctx.fillRect(-4, 7 - liquidHeight, 8, liquidHeight);
                    ctx.shadowBlur = 0;
                }

                // Glanzeffekt
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(-4, -6, 3, 10);

                ctx.restore();

                // Heilungs-Partikel während des Trinkens
                if (drinkProgress > 0.3 && drinkProgress < 0.7 && Math.random() < 0.3) {
                    game.particles.push({
                        x: game.player.x + (Math.random() - 0.5) * 20,
                        y: playerY + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -1 - Math.random() * 2,
                        color: potionColor,
                        life: 25,
                        size: 3 + Math.random() * 2
                    });
                }

                // Heilungs-Aura
                if (drinkProgress > 0.3 && drinkProgress < 0.8) {
                    const auraIntensity = Math.sin((drinkProgress - 0.3) / 0.5 * Math.PI);
                    ctx.globalAlpha = auraIntensity * 0.3;
                    ctx.fillStyle = potionColor;
                    ctx.beginPath();
                    ctx.arc(0, 5, 25 + auraIntensity * 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // +HP Anzeige
                if (drinkProgress > 0.4 && drinkProgress < 0.9) {
                    const textAlpha = drinkProgress < 0.65 ? 1 : 1 - (drinkProgress - 0.65) / 0.25;
                    const textRise = (drinkProgress - 0.4) * 40;
                    ctx.globalAlpha = textAlpha;
                    ctx.fillStyle = '#22c55e';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 14px Courier New';
                    ctx.textAlign = 'center';
                    ctx.strokeText(`+${game.player.drinkHeal || 50}`, 0, -25 - textRise);
                    ctx.fillText(`+${game.player.drinkHeal || 50}`, 0, -25 - textRise);
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }

            // Player HP bar (über dem Spieler)
            if (!game.player.isDying) {
                const playerBarWidth = 50;
                const playerBarHeight = 6;
                const playerBarY = playerY - 35;

                // Schwarzer Hintergrund
                ctx.fillStyle = '#000000';
                ctx.fillRect(game.player.x - playerBarWidth/2 - 1, playerBarY - 1, playerBarWidth + 2, playerBarHeight + 2);

                // HP Leiste
                const playerHpPercent = game.player.hp / game.player.maxHp;
                const playerHpColor = playerHpPercent > 0.5 ? '#22c55e' : playerHpPercent > 0.25 ? '#f59e0b' : '#ef4444';
                ctx.fillStyle = playerHpColor;
                ctx.fillRect(game.player.x - playerBarWidth/2, playerBarY, playerHpPercent * playerBarWidth, playerBarHeight);

                // HP Zahlen
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px "Courier New"';
                ctx.textAlign = 'center';
                const playerHpText = `${Math.ceil(game.player.hp)}/${game.player.maxHp}`;
                ctx.strokeText(playerHpText, game.player.x, playerBarY - 4);
                ctx.fillText(playerHpText, game.player.x, playerBarY - 4);
            }

            // Spawn protection shield effect
            if (game.player.spawnProtection > 0) {
                ctx.save();
                const shieldPulse = Math.sin(game.animCounter * 0.15) * 0.3 + 0.7;
                const shieldRadius = 30 + Math.sin(game.animCounter * 0.1) * 3;

                // Outer shield ring
                ctx.globalAlpha = shieldPulse * 0.6;
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner glow
                ctx.globalAlpha = shieldPulse * 0.2;
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, shieldRadius - 5, 0, Math.PI * 2);
                ctx.fill();

                // Timer display (seconds remaining) - positioned above HP bar
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#60a5fa';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(game.player.spawnProtection / 60);
                Icons.draw('shield', game.player.x - 20, playerY - 56, 14);
                ctx.fillText(`${secondsLeft}s`, game.player.x + 5, playerY - 52);

                ctx.restore();
            }

            // Attack range indicator (replaces spinning effect)
            if (game.player.attackCooldown > 0) {
                const weapon = game.player.equippedWeapon;
                const weaponSpeed = weapon ? (weapon.speed || 1) : 1;
                const maxCooldown = Math.floor(30 * weaponSpeed);
                const progress = Math.max(0, Math.min(1, 1 - (game.player.attackCooldown / maxCooldown)));
                const weaponRange = weapon ? (weapon.range || 80) : 28; // Faust = 28 (realistisch kurz)
                const weaponStyle = weapon ? weapon.style : 'fist';

                // Farbe basierend auf Waffentyp
                let rangeColor = '#fbbf24'; // Standard gold
                if (weaponStyle === 'flame' || weaponStyle === 'fire_staff') {
                    rangeColor = '#ff6b35';
                } else if (weaponStyle === 'frost_sword' || weaponStyle === 'ice_staff') {
                    rangeColor = '#60a5fa';
                } else if (weaponStyle === 'lightning_sword' || weaponStyle === 'lightning_staff') {
                    rangeColor = '#fbbf24';
                } else if (weaponStyle === 'soul_sword' || weaponStyle === 'necro_staff' || weaponStyle === 'vampire_blade') {
                    rangeColor = '#a855f7';
                } else if (weaponStyle === 'staff') {
                    rangeColor = '#c084fc';
                } else if (weaponStyle === 'poison_dagger' || weaponStyle === 'shadow_dagger' || weaponStyle === 'assassin_blade') {
                    rangeColor = '#22c55e';
                } else if (weaponStyle === 'dagger' || weaponStyle === 'claw') {
                    rangeColor = '#94a3b8';
                } else if (weaponStyle === 'spear' || weaponStyle === 'halberd' || weaponStyle === 'dragon_lance') {
                    rangeColor = '#60a5fa';
                } else if (weaponStyle === 'hammer' || weaponStyle === 'axe' || weaponStyle === 'battleaxe' || weaponStyle === 'executioner_axe' || weaponStyle === 'greataxe' || weaponStyle === 'titan_hammer' || weaponStyle === 'thunder_hammer' || weaponStyle === 'berserker_axe') {
                    rangeColor = '#f97316';
                } else if (weaponStyle === 'mace' || weaponStyle === 'morning_star' || weaponStyle === 'flail' || weaponStyle === 'holy_hammer') {
                    rangeColor = '#fcd34d';
                } else if (weaponStyle === 'katana' || weaponStyle === 'muramasa') {
                    rangeColor = '#ef4444';
                } else if (weaponStyle === 'fist') {
                    rangeColor = '#fcd34d';
                }

                ctx.save();
                ctx.translate(game.player.x, game.player.y);

                // Reichweiten-Kreis mit Fülleffekt
                const alpha = 0.3 - progress * 0.25;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = rangeColor;
                ctx.beginPath();
                ctx.arc(0, 0, weaponRange * progress, 0, Math.PI * 2);
                ctx.fill();

                // Äußerer Reichweiten-Ring
                ctx.globalAlpha = 0.6 - progress * 0.4;
                ctx.strokeStyle = rangeColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, weaponRange, 0, Math.PI * 2);
                ctx.stroke();

                // Angriffsrichtungs-Indikator (Bogen in Blickrichtung)
                const facingAngle = game.player.facingAngle || 0;
                ctx.globalAlpha = 0.5 - progress * 0.3;
                ctx.fillStyle = rangeColor;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, weaponRange * 0.8, facingAngle - Math.PI/4, facingAngle + Math.PI/4);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Draw skill effects
            for (const effect of game.skillEffects) {
                ctx.save();
                if (effect.type === 'healRing') {
                    const alpha = effect.life / 30;
                    ctx.strokeStyle = `rgba(34, 197, 94, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (effect.type === 'whirlwind') {
                    const alpha = effect.life / 20;
                    ctx.strokeStyle = `rgba(251, 191, 36, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#fbbf24';
                    // Draw spiral
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const startAngle = effect.rotation + (i * Math.PI * 2 / 3);
                        ctx.arc(effect.x, effect.y, effect.radius, startAngle, startAngle + Math.PI * 0.5);
                    }
                    ctx.stroke();
                } else if (effect.type === 'warcryRing') {
                    const alpha = effect.life / 25;
                    ctx.strokeStyle = `rgba(239, 68, 68, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ef4444';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    // Inner ring
                    ctx.strokeStyle = `rgba(251, 191, 36, ${alpha * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (effect.type === 'frostnovaRing') {
                    const alpha = effect.life / 25;
                    ctx.strokeStyle = `rgba(96, 165, 250, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#60a5fa';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    // Frost fill
                    ctx.fillStyle = `rgba(147, 197, 253, ${alpha * 0.15})`;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (effect.type === 'lightningBolt') {
                    const alpha = effect.life / 15;
                    ctx.strokeStyle = `rgba(251, 191, 36, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#fbbf24';
                    // Draw jagged lightning line
                    ctx.beginPath();
                    ctx.moveTo(effect.x1, effect.y1);
                    const segments = 6;
                    for (let i = 1; i < segments; i++) {
                        const t = i / segments;
                        const x = effect.x1 + (effect.x2 - effect.x1) * t + (Math.random() - 0.5) * 20;
                        const y = effect.y1 + (effect.y2 - effect.y1) * t + (Math.random() - 0.5) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(effect.x2, effect.y2);
                    ctx.stroke();
                    // Glow line
                    ctx.strokeStyle = `rgba(219, 234, 254, ${alpha * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (effect.type === 'smokeCloud') {
                    const alpha = effect.life / 40;
                    ctx.fillStyle = `rgba(107, 114, 128, ${alpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `rgba(156, 163, 175, ${alpha * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw particles with varied sizes
            for (const p of game.particles) {
                const alpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;

                if (p.isText) {
                    // Draw text particles (like "KRIT!")
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(p.text, p.x, p.y);
                    ctx.fillText(p.text, p.x, p.y);
                } else {
                    const size = p.size || 3;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = p.color;
                    ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
                }
            }

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // End camera transform
            ctx.restore();

            // End screen shake transform
            ctx.restore();

            // Room transition overlay with smooth easing
            if (game.roomTransition > 0) {
                const rawProgress = game.roomTransition / 30;
                const fadeAlpha = easing.easeInOutQuad(rawProgress);
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                game.roomTransition--;
            }

            // Decrement door cooldown
            if (game.doorCooldown > 0) {
                game.doorCooldown--;
            }

            // Dark level overlay - draw BEFORE HUD so HUD stays visible
            if (game.isDarkLevel) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';

                // Create radial gradient for light around player
                const gradient = ctx.createRadialGradient(
                    game.player.x - game.camera.x, game.player.y - game.camera.y, 0,
                    game.player.x - game.camera.x, game.player.y - game.camera.y, game.lightRadius
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');

                // Draw darkness overlay
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.restore();
            }

            // Draw in-game HUD (Minecraft style) - always on top
            drawHUD();
        }

        function drawHUD() {
            const padding = 8;
            const barWidth = 140;
            const barHeight = 14;

            ctx.save();

            // Semi-transparent background for top-left stats (more compact)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(padding - 4, padding - 4, 155, 85);

            // HP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(padding, padding, barWidth, barHeight);
            const hpPercent = game.player.hp / game.player.maxHp;
            const hpColor = hpPercent > 0.5 ? '#22c55e' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
            ctx.fillStyle = hpColor;
            ctx.fillRect(padding + 2, padding + 2, (barWidth - 4) * hpPercent, barHeight - 4);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText(`HP ${Math.floor(game.player.hp)}/${game.player.maxHp}`, padding + barWidth / 2, padding + 11);

            // Mana Bar
            const manaBarY = padding + barHeight + 3;
            ctx.fillStyle = '#333';
            ctx.fillRect(padding, manaBarY, barWidth, barHeight - 2);
            const manaPercent = game.player.mana / game.player.maxMana;
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(padding + 2, manaBarY + 2, (barWidth - 4) * manaPercent, barHeight - 6);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px "Courier New"';
            ctx.fillText(`MP ${Math.floor(game.player.mana)}/${game.player.maxMana}`, padding + barWidth / 2, manaBarY + 9);

            // XP Bar (smaller)
            const xpBarY = manaBarY + barHeight;
            ctx.fillStyle = '#333';
            ctx.fillRect(padding, xpBarY, barWidth, barHeight - 2);
            const xpPercent = game.player.xp / game.player.xpToNext;
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(padding + 2, xpBarY + 2, (barWidth - 4) * xpPercent, barHeight - 6);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px "Courier New"';
            ctx.fillText(`LVL ${game.player.level}`, padding + barWidth / 2, xpBarY + 9);

            // Stats in a single row
            const statsY = xpBarY + barHeight + 6;
            ctx.font = '10px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`${game.player.gold}G`, padding, statsY);
            ctx.fillStyle = '#ef4444';
            ctx.fillText(`${game.player.attack}A`, padding + 50, statsY);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText(`${game.player.defense}D`, padding + 95, statsY);

            // Room indicator (top-right) - expanded for subroom info
            const hasSubRooms = game.subRooms && game.subRooms.length > 1;
            const topRightHeight = hasSubRooms ? 65 : 50;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width - padding - 95, padding - 4, 100, topRightHeight);
            ctx.font = 'bold 11px "Courier New"';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#fff';
            ctx.fillText(`Level ${game.currentRoom}`, canvas.width - padding, padding + 10);
            ctx.fillStyle = '#e94560';
            ctx.font = '10px "Courier New"';
            ctx.fillText(`Monster: ${game.monsters.length}`, canvas.width - padding, padding + 24);
            // Boss indicator
            if (game.currentRoom % 10 === 0 && game.monsters.length > 0) {
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('[BOSS!]', canvas.width - padding, padding + 38);
            }

            // Environment theme indicator
            const currentTheme = getCurrentTheme();
            ctx.font = '9px "Courier New"';
            ctx.fillStyle = '#888';
            ctx.fillText(currentTheme.name, canvas.width - padding, padding + 50);

            // Boss health bar (large, centered at top)
            const boss = game.monsters.find(m => m.isBoss);
            if (boss) {
                const bossBarWidth = 400;
                const bossBarHeight = 24;
                const bossBarX = (canvas.width - bossBarWidth) / 2;
                const bossBarY = 50;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bossBarX - 10, bossBarY - 25, bossBarWidth + 20, bossBarHeight + 35);
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.strokeRect(bossBarX - 10, bossBarY - 25, bossBarWidth + 20, bossBarHeight + 35);

                // Boss name with skull icons
                ctx.font = 'bold 14px "Courier New"';
                ctx.fillStyle = '#fbbf24';
                ctx.textAlign = 'center';
                Icons.draw('skull', canvas.width / 2 - ctx.measureText(boss.name).width / 2 - 18, bossBarY - 12, 14);
                ctx.fillText(boss.name, canvas.width / 2, bossBarY - 8);
                Icons.draw('skull', canvas.width / 2 + ctx.measureText(boss.name).width / 2 + 4, bossBarY - 12, 14);

                // Health bar background
                ctx.fillStyle = '#1a1a2a';
                ctx.fillRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);

                // Health bar fill
                const bossHpPercent = Math.max(0, boss.hp / boss.maxHp);
                const gradient = ctx.createLinearGradient(bossBarX, bossBarY, bossBarX + bossBarWidth, bossBarY);
                gradient.addColorStop(0, '#dc2626');
                gradient.addColorStop(0.5, '#ef4444');
                gradient.addColorStop(1, '#f87171');
                ctx.fillStyle = gradient;
                ctx.fillRect(bossBarX + 2, bossBarY + 2, (bossBarWidth - 4) * bossHpPercent, bossBarHeight - 4);

                // Health text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillText(`${Math.max(0, Math.floor(boss.hp))} / ${boss.maxHp}`, canvas.width / 2, bossBarY + 16);

                // Boss phase indicator
                if (boss.phase) {
                    const phaseColors = ['#22c55e', '#fbbf24', '#ef4444'];
                    ctx.font = 'bold 11px "Courier New"';
                    ctx.fillStyle = phaseColors[boss.phase - 1] || '#fff';
                    ctx.fillText(`PHASE ${boss.phase}`, bossBarX + 50, bossBarY + 45);
                }

                // Boss shield indicator
                if (boss.shieldActive) {
                    ctx.fillStyle = '#60a5fa';
                    Icons.draw('shield', canvas.width / 2 + 65, bossBarY + 42, 12);
                    ctx.fillText('SHIELD', canvas.width / 2 + 95, bossBarY + 45);
                }
            }

            // Ability cooldowns display (bottom-right corner) - moved higher
            const abilitiesX = canvas.width - 85;
            const abilitiesY = canvas.height - 100;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(abilitiesX - 5, abilitiesY - 5, 85, 45);

            ctx.font = 'bold 9px "Courier New"';
            ctx.textAlign = 'left';

            // Dash ability (Shift)
            const dashReady = game.player.dashCooldown <= 0;
            ctx.fillStyle = dashReady ? '#60a5fa' : '#555';
            Icons.draw('lightning', abilitiesX - 2, abilitiesY + 7, 10);
            ctx.fillText('Dash [Shift]', abilitiesX + 12, abilitiesY + 10);
            if (!dashReady) {
                const dashCooldownSec = (game.player.dashCooldown / 60).toFixed(1);
                ctx.fillStyle = '#888';
                ctx.fillText(`   ${dashCooldownSec}s`, abilitiesX, abilitiesY + 22);
            }

            // Status effects on player
            if (game.player.statusEffects && game.player.statusEffects.length > 0) {
                ctx.fillStyle = '#fff';
                ctx.fillText('Status:', abilitiesX, abilitiesY + 35);
                let statusX = abilitiesX + 45;
                const statusIcons = { poison: 'skull', burn: 'fire', freeze: 'gem' };
                for (const effect of game.player.statusEffects) {
                    const iconName = statusIcons[effect.type];
                    if (iconName) {
                        Icons.draw(iconName, statusX, abilitiesY + 32, 12);
                    }
                    statusX += 15;
                }
            }

            // Equipped items info (bottom-left) - moved higher and more compact
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(padding - 4, canvas.height - 95, 130, 40);
            ctx.font = '9px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ff6b6b';
            const weaponName = game.player.equippedWeapon ? game.player.equippedWeapon.name : 'Fäuste';
            Icons.draw('sword', padding - 2, canvas.height - 83, 10);
            ctx.fillText(weaponName, padding + 12, canvas.height - 80);
            ctx.fillStyle = '#4ecdc4';
            const armorName = game.player.equippedArmor ? game.player.equippedArmor.name : 'Keine';
            Icons.draw('shield', padding - 2, canvas.height - 69, 10);
            ctx.fillText(armorName, padding + 12, canvas.height - 66);

            // Inventory quick bar (bottom center) - improved design
            const slotSize = 30;
            const slotGap = 3;
            const numSlots = Math.max(5, Math.min(9, game.player.inventory.length || 5));
            const invBarWidth = numSlots * (slotSize + slotGap) + slotGap;
            const invBarX = canvas.width / 2 - invBarWidth / 2;
            const invBarY = canvas.height - 48;

            // Bar background with gradient effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(invBarX - 2, invBarY - 2, invBarWidth + 4, slotSize + 14);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.strokeRect(invBarX - 2, invBarY - 2, invBarWidth + 4, slotSize + 14);

            // Draw inventory slots
            for (let i = 0; i < numSlots; i++) {
                const slotX = invBarX + slotGap + i * (slotSize + slotGap);
                const slotY = invBarY + 2;
                const item = game.player.inventory[i];

                // Slot background with border
                const hasItem = item !== undefined;
                ctx.fillStyle = hasItem ? '#2a2a3a' : '#1a1a2a';
                ctx.fillRect(slotX, slotY, slotSize, slotSize);

                // Slot border (highlighted if has item)
                ctx.strokeStyle = hasItem ? '#555' : '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(slotX, slotY, slotSize, slotSize);

                // Inner highlight
                if (hasItem) {
                    ctx.strokeStyle = '#3a3a4a';
                    ctx.strokeRect(slotX + 1, slotY + 1, slotSize - 2, slotSize - 2);
                }

                if (item) {
                    const cx = slotX + slotSize / 2;
                    const cy = slotY + slotSize / 2;
                    const style = item.style || '';

                    // Draw detailed item icons based on type and style
                    if (item.type === 'weapon') {
                        ctx.save();
                        ctx.translate(cx, cy);

                        if (style === 'flame') {
                            // Flammschwert - Fiery sword with flames
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#ff6600';
                            // Sword blade
                            ctx.fillStyle = '#c0c0c0';
                            ctx.fillRect(-2, -10, 4, 14);
                            // Blade edge
                            ctx.fillStyle = '#e0e0e0';
                            ctx.fillRect(-1, -10, 2, 12);
                            // Flames on blade
                            ctx.fillStyle = '#ff6600';
                            ctx.fillRect(-3, -9, 2, 4);
                            ctx.fillRect(1, -7, 2, 5);
                            ctx.fillStyle = '#fbbf24';
                            ctx.fillRect(-2, -8, 1, 3);
                            ctx.fillRect(1, -6, 1, 3);
                            ctx.shadowBlur = 0;
                            // Guard
                            ctx.fillStyle = '#fbbf24';
                            ctx.fillRect(-4, 4, 8, 2);
                            // Handle
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-2, 6, 4, 5);
                        } else if (style === 'fire_staff') {
                            // Feuerstab - Staff with flame orb on top
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#ff6600';
                            // Wooden staff
                            ctx.fillStyle = '#4a3728';
                            ctx.fillRect(-1, -4, 3, 16);
                            // Staff decorations
                            ctx.fillStyle = '#6b4423';
                            ctx.fillRect(-2, -4, 5, 2);
                            ctx.fillRect(-2, 10, 5, 2);
                            // Fire orb on top
                            ctx.fillStyle = '#ff6600';
                            ctx.beginPath();
                            ctx.arc(0, -7, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#fbbf24';
                            ctx.beginPath();
                            ctx.arc(0, -7, 3, 0, Math.PI * 2);
                            ctx.fill();
                            // Flame tips
                            ctx.fillStyle = '#ff6600';
                            ctx.fillRect(-1, -13, 2, 4);
                            ctx.fillRect(-3, -11, 2, 3);
                            ctx.fillRect(1, -11, 2, 3);
                            ctx.shadowBlur = 0;
                        } else if (style === 'dagger' || style === 'poison_dagger') {
                            // Dagger
                            ctx.fillStyle = style === 'poison_dagger' ? '#22c55e' : '#c0c0c0';
                            ctx.fillRect(-1, -7, 3, 10);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-2, 3, 5, 5);
                        } else if (style === 'axe' || style === 'battleaxe') {
                            // Axe
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -9, 3, 16);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-5, -8, 8, 6);
                        } else if (style === 'hammer') {
                            // Hammer
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -6, 3, 14);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-4, -8, 9, 7);
                        } else if (style === 'spear' || style === 'halberd') {
                            // Spear
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -8, 2, 18);
                            ctx.fillStyle = '#c0c0c0';
                            ctx.beginPath();
                            ctx.moveTo(0, -12);
                            ctx.lineTo(-3, -6);
                            ctx.lineTo(3, -6);
                            ctx.closePath();
                            ctx.fill();
                        } else if (style === 'staff') {
                            // Magic staff
                            ctx.fillStyle = '#5c3d2e';
                            ctx.fillRect(-1, -8, 3, 18);
                            ctx.fillStyle = '#c084fc';
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = '#c084fc';
                            ctx.beginPath();
                            ctx.arc(0, -10, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        } else if (style === 'claw') {
                            // Demon claw
                            ctx.fillStyle = '#ef4444';
                            ctx.fillRect(-4, 0, 8, 6);
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(-5, -8, 2, 10);
                            ctx.fillRect(-1, -10, 2, 12);
                            ctx.fillRect(3, -8, 2, 10);
                        } else if (style === 'bone') {
                            // Bone sword
                            ctx.fillStyle = '#e2e8f0';
                            ctx.fillRect(-2, -9, 4, 14);
                            ctx.fillRect(-4, -6, 2, 4);
                            ctx.fillRect(2, -6, 2, 4);
                        } else if (style === 'rusty_sword') {
                            // Rusty sword in inventory
                            // Rusty blade
                            ctx.fillStyle = '#8B7355';
                            ctx.fillRect(-2, -12, 4, 16);
                            // Rust patches
                            ctx.fillStyle = '#A0522D';
                            ctx.fillRect(-2, -10, 2, 3);
                            ctx.fillRect(0, -4, 2, 4);
                            ctx.fillRect(-2, 0, 3, 2);
                            // Dark rust/pitting
                            ctx.fillStyle = '#6B4423';
                            ctx.fillRect(-1, -6, 1, 2);
                            ctx.fillRect(1, -2, 1, 2);
                            // Dull edge
                            ctx.fillStyle = '#9B8B7B';
                            ctx.fillRect(-2, -10, 1, 10);
                            // Worn crossguard
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Worn grip
                            ctx.fillStyle = '#3a2718';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#4a3020';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Dented pommel
                            ctx.fillStyle = '#5C4033';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'iron_sword') {
                            // Iron sword in inventory
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#B8C0CC';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#6B7280';
                            ctx.fillRect(-1, -10, 1, 12);
                            // Iron crossguard
                            ctx.fillStyle = '#4B5563';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Leather grip
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#6B5043';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Iron pommel
                            ctx.fillStyle = '#4B5563';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'steel_sword') {
                            // Steel sword in inventory - polished
                            ctx.fillStyle = '#E5E7EB';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#F3F4F6';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-1, -10, 1, 12);
                            // Steel crossguard
                            ctx.fillStyle = '#6B7280';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-4, 4, 8, 1);
                            // Blue leather grip
                            ctx.fillStyle = '#1E3A5F';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#2B4A6F';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Steel pommel with gem
                            ctx.fillStyle = '#6B7280';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#3B82F6';
                            ctx.beginPath();
                            ctx.arc(0, 12, 1, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'silver_sword') {
                            // Silver sword - bright and elegant
                            ctx.fillStyle = '#E8E8E8';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(1, -10, 1, 12);
                            ctx.fillStyle = '#D4AF37';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#1E1E2E';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#D4AF37';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'broadsword') {
                            // Breitschwert - wide blade
                            ctx.fillStyle = '#A0A0A0';
                            ctx.fillRect(-3, -12, 6, 16);
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(-3, -10, 2, 12);
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-6, 4, 12, 3);
                            ctx.fillStyle = '#3a2718';
                            ctx.fillRect(-2, 7, 4, 5);
                            ctx.fillStyle = '#5C4033';
                            ctx.beginPath();
                            ctx.arc(0, 13, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'frost_sword') {
                            // Frostschwert - ice blue with frost effect
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#60a5fa';
                            ctx.fillStyle = '#93C5FD';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#BFDBFE';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#60A5FA';
                            ctx.fillRect(-3, -9, 2, 3);
                            ctx.fillRect(1, -6, 2, 4);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#3B82F6';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#1E3A5F';
                            ctx.fillRect(-2, 6, 4, 5);
                        } else if (style === 'lightning_sword') {
                            // Blitzschwert - electric yellow
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#fbbf24';
                            ctx.fillStyle = '#FDE68A';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#FBBF24';
                            ctx.fillRect(-3, -10, 2, 4);
                            ctx.fillRect(1, -7, 2, 5);
                            ctx.fillStyle = '#FEF3C7';
                            ctx.fillRect(-1, -9, 2, 10);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#B45309';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#451A03';
                            ctx.fillRect(-2, 6, 4, 5);
                        } else if (style === 'soul_sword') {
                            // Seelenschneider - purple ethereal
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#a855f7';
                            ctx.fillStyle = '#C084FC';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#E9D5FF';
                            ctx.fillRect(-1, -10, 2, 12);
                            ctx.fillStyle = '#7C3AED';
                            ctx.fillRect(-3, -8, 2, 3);
                            ctx.fillRect(1, -5, 2, 4);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#4C1D95';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#1E1B4B';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#A855F7';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'shadow_dagger' || style === 'assassin_blade') {
                            // Shadow/Assassin dagger - dark and deadly
                            ctx.shadowBlur = style === 'assassin_blade' ? 6 : 4;
                            ctx.shadowColor = '#22c55e';
                            ctx.fillStyle = '#1a1a2e';
                            ctx.fillRect(-1, -8, 3, 11);
                            ctx.fillStyle = '#22c55e';
                            ctx.fillRect(-1, -7, 1, 8);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#0f0f1a';
                            ctx.fillRect(-2, 3, 5, 5);
                            ctx.fillStyle = '#22c55e';
                            ctx.fillRect(-1, 5, 3, 1);
                        } else if (style === 'executioner_axe' || style === 'greataxe') {
                            // Large axes
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-1, -8, 3, 18);
                            ctx.fillStyle = style === 'greataxe' ? '#404040' : '#606060';
                            ctx.fillRect(-7, -9, 10, 8);
                            ctx.fillStyle = style === 'greataxe' ? '#505050' : '#707070';
                            ctx.fillRect(-6, -8, 8, 6);
                            if (style === 'greataxe') {
                                ctx.fillRect(1, -9, 6, 8);
                            }
                        } else if (style === 'titan_hammer' || style === 'thunder_hammer') {
                            // Massive hammers
                            ctx.fillStyle = '#4a3728';
                            ctx.fillRect(-1, -4, 3, 16);
                            ctx.fillStyle = style === 'thunder_hammer' ? '#FDE68A' : '#505050';
                            if (style === 'thunder_hammer') {
                                ctx.shadowBlur = 6;
                                ctx.shadowColor = '#fbbf24';
                            }
                            ctx.fillRect(-6, -10, 12, 9);
                            ctx.fillStyle = style === 'thunder_hammer' ? '#FBBF24' : '#606060';
                            ctx.fillRect(-5, -9, 10, 7);
                            ctx.shadowBlur = 0;
                        } else if (style === 'dragon_lance') {
                            // Dragon lance - ornate spear
                            ctx.fillStyle = '#8B0000';
                            ctx.fillRect(-1, -6, 2, 18);
                            ctx.fillStyle = '#D4AF37';
                            ctx.fillRect(-2, 2, 4, 2);
                            ctx.fillStyle = '#ef4444';
                            ctx.beginPath();
                            ctx.moveTo(0, -14);
                            ctx.lineTo(-4, -4);
                            ctx.lineTo(4, -4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = '#fbbf24';
                            ctx.fillRect(-1, -10, 2, 6);
                        } else if (style === 'mace') {
                            // Streitkolben
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-1, -4, 3, 14);
                            ctx.fillStyle = '#606060';
                            ctx.beginPath();
                            ctx.arc(0, -7, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#505050';
                            ctx.fillRect(-6, -8, 3, 2);
                            ctx.fillRect(3, -8, 3, 2);
                            ctx.fillRect(-1, -12, 2, 3);
                        } else if (style === 'morning_star') {
                            // Morgenstern with spikes
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-1, -2, 3, 14);
                            ctx.fillStyle = '#404040';
                            ctx.beginPath();
                            ctx.arc(0, -6, 6, 0, Math.PI * 2);
                            ctx.fill();
                            // Spikes
                            ctx.fillStyle = '#606060';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                ctx.fillRect(Math.cos(angle) * 5 - 1, -6 + Math.sin(angle) * 5 - 1, 3, 3);
                            }
                        } else if (style === 'flail') {
                            // Flegel with chain
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-1, 2, 3, 10);
                            ctx.strokeStyle = '#808080';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(0, 2);
                            ctx.lineTo(0, -4);
                            ctx.stroke();
                            ctx.fillStyle = '#404040';
                            ctx.beginPath();
                            ctx.arc(0, -8, 5, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'katana' || style === 'muramasa') {
                            // Katana - curved elegant blade
                            ctx.fillStyle = style === 'muramasa' ? '#DC2626' : '#E5E7EB';
                            if (style === 'muramasa') {
                                ctx.shadowBlur = 6;
                                ctx.shadowColor = '#ef4444';
                            }
                            // Curved blade
                            ctx.beginPath();
                            ctx.moveTo(-1, -12);
                            ctx.quadraticCurveTo(3, -6, 2, 4);
                            ctx.lineTo(-1, 4);
                            ctx.quadraticCurveTo(0, -6, -1, -12);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            // Tsuba (guard)
                            ctx.fillStyle = '#D4AF37';
                            ctx.beginPath();
                            ctx.ellipse(0, 5, 4, 2, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // Handle wrap
                            ctx.fillStyle = style === 'muramasa' ? '#1a0505' : '#1E1E2E';
                            ctx.fillRect(-2, 6, 4, 6);
                            ctx.fillStyle = '#D4AF37';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            ctx.fillRect(-2, 11, 4, 1);
                        } else if (style === 'ice_staff') {
                            // Eisstab - ice crystal on top
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#60a5fa';
                            ctx.fillStyle = '#93C5FD';
                            ctx.fillRect(-1, -4, 3, 16);
                            // Ice crystal
                            ctx.fillStyle = '#BFDBFE';
                            ctx.beginPath();
                            ctx.moveTo(0, -12);
                            ctx.lineTo(-4, -6);
                            ctx.lineTo(0, -2);
                            ctx.lineTo(4, -6);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = '#60A5FA';
                            ctx.beginPath();
                            ctx.moveTo(0, -10);
                            ctx.lineTo(-2, -6);
                            ctx.lineTo(0, -4);
                            ctx.lineTo(2, -6);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        } else if (style === 'lightning_staff') {
                            // Blitzstab - electric orb
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#fbbf24';
                            ctx.fillStyle = '#78350f';
                            ctx.fillRect(-1, -4, 3, 16);
                            ctx.fillStyle = '#FDE68A';
                            ctx.beginPath();
                            ctx.arc(0, -8, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#FBBF24';
                            ctx.beginPath();
                            ctx.arc(0, -8, 3, 0, Math.PI * 2);
                            ctx.fill();
                            // Lightning bolts
                            ctx.strokeStyle = '#FEF3C7';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-2, -11);
                            ctx.lineTo(0, -8);
                            ctx.lineTo(2, -11);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        } else if (style === 'necro_staff') {
                            // Nekromantenstab - skull on top
                            ctx.fillStyle = '#1a1a2e';
                            ctx.fillRect(-1, -4, 3, 16);
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#a855f7';
                            // Skull
                            ctx.fillStyle = '#E2E8F0';
                            ctx.beginPath();
                            ctx.arc(0, -8, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#A855F7';
                            ctx.fillRect(-3, -9, 2, 2);
                            ctx.fillRect(1, -9, 2, 2);
                            ctx.fillStyle = '#1a1a2e';
                            ctx.fillRect(-1, -6, 2, 2);
                            ctx.shadowBlur = 0;
                        } else if (style === 'vampire_blade') {
                            // Vampirklinge - blood red
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#DC2626';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#7F1D1D';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#450A0A';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#DC2626';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'berserker_axe') {
                            // Berserker-Axt - red glow
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#ef4444';
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-1, -8, 3, 18);
                            ctx.fillStyle = '#7F1D1D';
                            ctx.fillRect(-7, -9, 10, 8);
                            ctx.fillStyle = '#DC2626';
                            ctx.fillRect(-6, -8, 8, 6);
                            ctx.shadowBlur = 0;
                        } else if (style === 'holy_hammer') {
                            // Heiliger Hammer - golden glow
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#fbbf24';
                            ctx.fillStyle = '#D4AF37';
                            ctx.fillRect(-1, -4, 3, 14);
                            ctx.fillStyle = '#FDE68A';
                            ctx.fillRect(-5, -10, 11, 9);
                            ctx.fillStyle = '#FBBF24';
                            ctx.fillRect(-4, -9, 9, 7);
                            // Cross symbol
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(-1, -8, 2, 5);
                            ctx.fillRect(-2, -6, 4, 2);
                            ctx.shadowBlur = 0;
                        } else {
                            // Realistic sword in inventory
                            // Klinge
                            ctx.fillStyle = '#D8D8D8';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#A8A8A8';
                            ctx.fillRect(-1, -11, 1, 14);
                            ctx.fillStyle = '#F0F0F0';
                            ctx.fillRect(-2, -10, 1, 12);
                            // Parierstange
                            ctx.fillStyle = '#B8860B';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Griff
                            ctx.fillStyle = '#4a3728';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#5c4033';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Knauf
                            ctx.fillStyle = '#B8860B';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    } else if (item.type === 'armor') {
                        // Armor - shield icon
                        ctx.save();
                        ctx.translate(cx, cy);
                        const armorStyle = item.style || 'leather';
                        const armorColors = {
                            leather: '#8B4513',
                            chain: '#808080',
                            plate: '#c0c0c0',
                            dragon: '#ef4444'
                        };
                        ctx.fillStyle = armorColors[armorStyle] || '#4169E1';
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-8, -6);
                        ctx.lineTo(-8, 4);
                        ctx.lineTo(0, 10);
                        ctx.lineTo(8, 4);
                        ctx.lineTo(8, -6);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Emblem
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(-3, -3, 6, 6);
                        ctx.restore();
                    } else if (item.type === 'potion') {
                        // Potion bottle
                        ctx.save();
                        ctx.translate(cx, cy);
                        // Bottle
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-2, -10, 4, 4);
                        // Liquid color based on potion type
                        const potionColor = item.heal >= 100 ? '#ff0066' : item.heal >= 50 ? '#ff1493' : '#ff69b4';
                        ctx.fillStyle = potionColor;
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = potionColor;
                        ctx.fillRect(-5, -6, 10, 12);
                        ctx.shadowBlur = 0;
                        // Highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.fillRect(-4, -5, 3, 8);
                        // Cork
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-2, -10, 4, 3);
                        ctx.restore();
                    } else if (item.type === 'bomb') {
                        // Bomb
                        ctx.save();
                        ctx.translate(cx, cy);
                        const isBig = (item.damage || 40) >= 60;
                        // Main bomb body
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(0, 2, isBig ? 9 : 7, 0, Math.PI * 2);
                        ctx.fill();
                        // Highlight
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(-2, 0, isBig ? 4 : 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Fuse
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -6);
                        ctx.quadraticCurveTo(3, -10, 5, -8);
                        ctx.stroke();
                        // Spark
                        ctx.fillStyle = '#ff6600';
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(5, -8, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }

                    // Stack count (bottom right corner)
                    const count = item.count || 1;
                    if (count > 1) {
                        ctx.font = 'bold 10px "Courier New"';
                        ctx.textAlign = 'right';
                        ctx.fillStyle = '#000';
                        ctx.fillText(count, slotX + slotSize - 1, slotY + slotSize - 2);
                        ctx.fillStyle = '#fff';
                        ctx.fillText(count, slotX + slotSize - 2, slotY + slotSize - 3);
                    }
                }

                // Slot number (top left)
                ctx.font = 'bold 9px "Courier New"';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#666';
                ctx.fillText(i + 1, slotX + 2, slotY + 10);
            }

            // Instructions below inventory
            ctx.font = '8px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#666';
            ctx.fillText('1-9: Benutzen | X+1-9: Fallenlassen', canvas.width / 2, canvas.height - 6);

            // Combo display (top-center)
            if (game.comboCount >= 3) {
                ctx.font = 'bold 16px "Courier New"';
                ctx.textAlign = 'center';
                const comboAlpha = Math.min(1, game.comboTimer / 30);
                ctx.fillStyle = `rgba(255, ${game.comboCount >= 10 ? 100 : 200}, 0, ${comboAlpha})`;
                ctx.save();
                ctx.globalAlpha = comboAlpha;
                Icons.draw('fire', canvas.width / 2 - 50, 76, 16);
                ctx.restore();
                ctx.fillText(`${game.comboCount}x COMBO!`, canvas.width / 2 + 10, 80);
                if (game.comboCount >= 10) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${comboAlpha * 0.5})`;
                    ctx.fillText(`+${Math.floor((getComboMultiplier() - 1) * 100)}% Schaden`, canvas.width / 2, 98);
                }
            }

            // Skill bar (left of inventory)
            const skillBarX = invBarX - 160;
            const skillBarY = canvas.height - 50;
            const skillSlotSize = 34;
            const skillGap = 4;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(skillBarX - 4, skillBarY - 4, 4 * (skillSlotSize + skillGap) + 4, skillSlotSize + 18);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.strokeRect(skillBarX - 4, skillBarY - 4, 4 * (skillSlotSize + skillGap) + 4, skillSlotSize + 18);

            const skillOrder = ['fireball', 'heal', 'shield', 'whirlwind'];
            const skillColors = {
                fireball: '#ff6600',
                heal: '#22c55e',
                shield: '#60a5fa',
                whirlwind: '#fbbf24'
            };
            const skillIcons = {
                fireball: 'fire',
                heal: 'heart',
                shield: 'shield',
                whirlwind: 'lightning'
            };

            for (let i = 0; i < skillOrder.length; i++) {
                const skillName = skillOrder[i];
                const skill = game.skills[skillName];
                const slotX = skillBarX + i * (skillSlotSize + skillGap);
                const slotY = skillBarY;

                // Slot background
                const onCooldown = skill.cooldown > 0;
                const noMana = game.player.mana < skill.manaCost;
                ctx.fillStyle = onCooldown || noMana ? '#1a1a2a' : '#2a2a4a';
                ctx.fillRect(slotX, slotY, skillSlotSize, skillSlotSize);

                // Colored border based on skill
                ctx.strokeStyle = skillColors[skillName];
                ctx.lineWidth = 2;
                ctx.strokeRect(slotX, slotY, skillSlotSize, skillSlotSize);

                // Skill icon - pixel art
                ctx.save();
                ctx.globalAlpha = onCooldown ? 0.4 : 1;
                Icons.draw(skillIcons[skillName], slotX + skillSlotSize / 2, slotY + 18, 20);
                ctx.restore();

                // Cooldown overlay
                if (onCooldown) {
                    const cdPercent = skill.cooldown / skill.maxCooldown;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(slotX, slotY, skillSlotSize, skillSlotSize * cdPercent);

                    // Cooldown text
                    ctx.font = 'bold 10px "Courier New"';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(Math.ceil(skill.cooldown / 60) + 's', slotX + skillSlotSize / 2, slotY + skillSlotSize - 4);
                }

                // Key binding
                ctx.font = 'bold 8px "Courier New"';
                ctx.fillStyle = '#888';
                ctx.fillText(skill.key.toUpperCase(), slotX + skillSlotSize / 2, slotY + skillSlotSize + 10);

                // Not enough mana indicator
                if (!onCooldown && noMana) {
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                    ctx.fillRect(slotX, slotY, skillSlotSize, skillSlotSize);
                }
            }

            // Shield active indicator
            if (game.shieldActive) {
                const shieldAlpha = 0.3 + Math.sin(game.animCounter * 0.15) * 0.2;
                ctx.strokeStyle = `rgba(96, 165, 250, ${shieldAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 60, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Berserk mode indicator - edge-only red pulse
            if (game.berserkActive) {
                const berserkPulse = Math.sin(game.animCounter * 0.2) * 0.5 + 0.5;
                const edgeWidth = 60 + berserkPulse * 30;
                const edgeAlpha = 0.4 + berserkPulse * 0.3;

                // Top edge gradient
                let gradient = ctx.createLinearGradient(0, 0, 0, edgeWidth);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${edgeAlpha})`);
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, edgeWidth);

                // Bottom edge gradient
                gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - edgeWidth);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${edgeAlpha})`);
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, canvas.height - edgeWidth, canvas.width, edgeWidth);

                // Left edge gradient
                gradient = ctx.createLinearGradient(0, 0, edgeWidth, 0);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${edgeAlpha})`);
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, edgeWidth, canvas.height);

                // Right edge gradient
                gradient = ctx.createLinearGradient(canvas.width, 0, canvas.width - edgeWidth, 0);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${edgeAlpha})`);
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(canvas.width - edgeWidth, 0, edgeWidth, canvas.height);

                // Berserk text (moved to safe area)
                ctx.font = 'bold 16px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(255, ${Math.floor(100 + berserkPulse * 155)}, 0, 1)`;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                Icons.draw('fire', canvas.width / 2 - 60, 121, 14);
                ctx.fillText('BERSERK', canvas.width / 2, 125);
                Icons.draw('fire', canvas.width / 2 + 46, 121, 14);
                ctx.shadowBlur = 0;

                const timeLeft = (game.berserkTimer / 60).toFixed(1);
                ctx.font = '11px "Courier New"';
                ctx.fillStyle = '#ff8888';
                ctx.fillText(`${timeLeft}s | +75% DMG | +15% CRIT`, canvas.width / 2, 140);
            }

            // Room indicator (integrated with top-right)
            if (game.subRooms && game.subRooms.length > 1) {
                ctx.font = '9px "Courier New"';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#888';
                const roomType = game.subRooms[game.currentSubRoom]?.type || 'normal';
                const roomText = `Raum ${game.currentSubRoom + 1}/${game.subRooms.length}`;
                ctx.fillText(roomText, canvas.width - padding, padding + 58);
                // Draw room type icon before text
                const iconMap = { treasure: 'gem', trap: 'trident', miniboss: 'sword', normal: null };
                if (iconMap[roomType]) {
                    Icons.draw(iconMap[roomType], canvas.width - padding - ctx.measureText(roomText).width - 14, padding + 54, 10);
                }
            }

            // Debug info display
            if (game.debugMode) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(canvas.width / 2 - 100, 5, 200, 70);
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 1;
                ctx.strokeRect(canvas.width / 2 - 100, 5, 200, 70);

                ctx.font = 'bold 10px "Courier New"';
                ctx.textAlign = 'left';
                const fpsColor = game.fps >= 50 ? '#0f0' : game.fps >= 30 ? '#ff0' : '#f00';
                ctx.fillStyle = fpsColor;
                ctx.fillText(`FPS: ${game.fps}`, canvas.width / 2 - 90, 20);

                ctx.fillStyle = '#fff';
                ctx.fillText(`Monsters: ${game.monsters.length}`, canvas.width / 2 - 90, 32);
                ctx.fillText(`Particles: ${game.particles.length}`, canvas.width / 2 - 90, 44);
                ctx.fillText(`Projectiles: ${game.projectiles.length}`, canvas.width / 2 - 90, 56);
                ctx.fillText(`Items: ${game.items.length}`, canvas.width / 2 - 90, 68);

                ctx.fillText(`Dying: ${game.dyingMonsters.length}`, canvas.width / 2 + 10, 32);
                ctx.fillText(`Walls: ${game.walls.length}`, canvas.width / 2 + 10, 44);
                ctx.fillText(`Traps: ${game.traps.length}`, canvas.width / 2 + 10, 56);
                ctx.fillText(`Afterimg: ${game.dashAfterimages.length}`, canvas.width / 2 + 10, 68);
            }

            // Draw achievement notifications
            drawAchievementNotifications();

            ctx.restore();
        }

        // Pause-Menü zeichnen
        function drawPauseMenu() {
            // Dunkler Overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pause-Box
            const boxWidth = 320;
            const boxHeight = 280;
            const boxX = (canvas.width - boxWidth) / 2;
            const boxY = (canvas.height - boxHeight) / 2;

            // Box-Hintergrund
            ctx.fillStyle = '#16213e';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            // Titel
            ctx.fillStyle = '#e94560';
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSIERT', canvas.width / 2, boxY + 45);

            // Trennlinie
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(boxX + 20, boxY + 60);
            ctx.lineTo(boxX + boxWidth - 20, boxY + 60);
            ctx.stroke();

            // Menü-Optionen
            const options = [
                { text: 'Fortsetzen', key: 'ESC' },
                { text: 'Steuerung', key: 'K' },
                { text: 'Neustart', key: 'R' },
                { text: 'Hauptmenü', key: 'Q' }
            ];

            ctx.font = 'bold 16px "Courier New"';
            const optionStartY = boxY + 95;
            const optionHeight = 40;

            for (let i = 0; i < options.length; i++) {
                const optY = optionStartY + i * optionHeight;
                const isSelected = game.pauseMenuSelection === i;

                // Highlight für ausgewählte Option
                if (isSelected) {
                    ctx.fillStyle = 'rgba(233, 69, 96, 0.3)';
                    ctx.fillRect(boxX + 15, optY - 15, boxWidth - 30, 35);
                    ctx.fillStyle = '#e94560';
                    ctx.fillText('▶', boxX + 30, optY + 6);
                }

                // Option Text
                ctx.fillStyle = isSelected ? '#fff' : '#aaa';
                ctx.textAlign = 'left';
                ctx.fillText(options[i].text, boxX + 50, optY + 6);

                // Taste
                ctx.fillStyle = '#666';
                ctx.textAlign = 'right';
                ctx.fillText(`[${options[i].key}]`, boxX + boxWidth - 25, optY + 6);
            }

            // Steuerungshinweis
            ctx.fillStyle = '#666';
            ctx.font = '12px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('↑↓ Auswählen  |  ENTER Bestätigen', canvas.width / 2, boxY + boxHeight - 20);
        }

        function gameLoop() {
            // FPS tracking
            const now = performance.now();
            game.frameCount++;
            if (now - game.fpsUpdateTime >= 1000) {
                game.fps = game.frameCount;
                game.frameCount = 0;
                game.fpsUpdateTime = now;
            }
            game.lastFrameTime = now;

            // Wenn pausiert, nur Pause-Menü zeichnen
            if (game.paused) {
                drawWorld();
                drawPauseMenu();
                requestAnimationFrame(gameLoop);
                return;
            }

            game.animCounter++;
            game.player.animFrame += 0.1;

            movePlayer();
            updateMonsters();
            updateDyingMonsters();
            updatePlayerDeath();
            updateProjectiles();
            updateBombs();
            updateParticles();
            updateStatusEffects();
            updateSkills();
            updatePlayerAbilities();
            updateTraps();
            updateVoid();
            updateTreasureChests();
            updateAbilitiesUI();

            if (game.keys.e && !game.player.isDying) {
                pickupItem();
                openTreasureChest();
                game.keys.e = false;
            }

            if (game.player.attackCooldown > 0) {
                game.player.attackCooldown--;
            }

            // Countdown spawn protection
            if (game.player.spawnProtection > 0) {
                game.player.spawnProtection--;
            }

            // Update shooting animation
            if (game.player.isShooting) {
                game.player.shootFrame++;
                if (game.player.shootFrame > 30) {
                    game.player.isShooting = false;
                }
            }

            // Update drinking animation
            if (game.player.isDrinking) {
                game.player.drinkFrame++;
                if (game.player.drinkFrame > 45) {
                    game.player.isDrinking = false;
                }
            }

            // Check achievements and daily challenges every 60 frames (once per second)
            if (game.animCounter % 60 === 0 && game.classSelected) {
                checkAchievements();
                checkDailyChallenges();

                // Check speedrun achievement
                const timeElapsed = (Date.now() - game.gameStartTime) / 1000 / 60; // minutes
                if (game.currentRoom >= 5 && timeElapsed < 3) {
                    unlockAchievement('speedRunner');
                }

                // Track low HP survives for daily challenge
                if (game.player.hp > 0 && game.player.hp < game.player.maxHp * 0.2) {
                    game.lowHpSurvives++;
                }

                // Track max combo reached
                if (game.comboCount > game.maxComboReached) {
                    game.maxComboReached = game.comboCount;
                }
            }

            draw();
            updateUI();
            if (typeof updateFullHealButton === 'function') updateFullHealButton();

            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        document.addEventListener('keydown', e => {
            // Pause-Menü Steuerung
            if (game.paused) {
                if (e.key === 'Escape') {
                    game.paused = false;
                    sfx.menuBack();
                    e.preventDefault();
                    return;
                }
                if (e.key === 'ArrowUp') {
                    game.pauseMenuSelection = (game.pauseMenuSelection - 1 + 4) % 4;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                if (e.key === 'ArrowDown') {
                    game.pauseMenuSelection = (game.pauseMenuSelection + 1) % 4;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                if (e.key === 'Enter' || e.key === ' ') {
                    sfx.menuConfirm();
                    switch (game.pauseMenuSelection) {
                        case 0: // Fortsetzen
                            game.paused = false;
                            break;
                        case 1: // Steuerung
                            game.paused = false;
                            game.showKeyBindings = true;
                            break;
                        case 2: // Neustart
                            game.paused = false;
                            location.reload();
                            break;
                        case 3: // Hauptmenü (Spiel beenden)
                            game.paused = false;
                            game.gameOver = true;
                            game.player.hp = 0;
                            startPlayerDeath();
                            break;
                    }
                    e.preventDefault();
                    return;
                }
                // Direkt-Tasten im Pause-Menü
                if (e.key.toLowerCase() === 'k') {
                    game.paused = false;
                    game.showKeyBindings = true;
                    sfx.menuConfirm();
                    e.preventDefault();
                    return;
                }
                if (e.key.toLowerCase() === 'r') {
                    game.paused = false;
                    location.reload();
                    return;
                }
                if (e.key.toLowerCase() === 'q') {
                    game.paused = false;
                    game.gameOver = true;
                    game.player.hp = 0;
                    startPlayerDeath();
                    e.preventDefault();
                    return;
                }
                return; // Keine anderen Tasten während Pause
            }

            // ESC zum Pausieren (wenn kein anderes Menü offen)
            if (e.key === 'Escape' && !game.showKeyBindings && !game.showBestiary &&
                !game.showAchievements && !game.showUpgradeMenu && !game.showClassSelection &&
                !game.player.isDying && game.gameStarted) {
                game.paused = true;
                game.pauseMenuSelection = 0;
                sfx.menuSelect();
                e.preventDefault();
                return;
            }

            // Key bindings menu controls
            if (game.showKeyBindings) {
                if (game.rebindingKey) {
                    // Capture the new key
                    if (e.key === 'Escape') {
                        game.rebindingKey = null;
                    } else {
                        game.keyBindings[game.rebindingKey] = e.key;
                        saveKeyBindings();
                        game.rebindingKey = null;
                    }
                    e.preventDefault();
                    return;
                }

                if (e.key === 'Escape' || e.key.toLowerCase() === 'k') {
                    game.showKeyBindings = false;
                    sfx.menuBack();
                    e.preventDefault();
                    return;
                }

                // Reset to defaults
                if (e.key.toLowerCase() === 'r') {
                    game.keyBindings = { ...defaultKeyBindings };
                    saveKeyBindings();
                    e.preventDefault();
                    return;
                }

                // Select binding to change (1-9, 0 for 10, -, = for 11-12)
                const bindingKeys = ['moveUp', 'moveDown', 'moveLeft', 'moveRight', 'attack', 'interact', 'drop', 'skill1', 'skill2', 'skill3', 'skill4', 'dash'];
                let index = -1;
                if (e.key >= '1' && e.key <= '9') index = parseInt(e.key) - 1;
                else if (e.key === '0') index = 9;
                else if (e.key === '-') index = 10;
                else if (e.key === '=') index = 11;

                if (index >= 0 && index < bindingKeys.length) {
                    game.rebindingKey = bindingKeys[index];
                    e.preventDefault();
                    return;
                }
                return;
            }

            // Bestiary menu controls
            if (game.showBestiary) {
                if (e.key === 'Escape' || e.key.toLowerCase() === 'b') {
                    game.showBestiary = false;
                    sfx.menuBack();
                    e.preventDefault();
                    return;
                }
                return;
            }

            // Achievements menu controls
            if (game.showAchievements) {
                if (e.key === 'Escape' || e.key.toLowerCase() === 'a') {
                    game.showAchievements = false;
                    sfx.menuBack();
                    e.preventDefault();
                    return;
                }
                return;
            }

            // Upgrade menu controls
            if (game.showUpgradeMenu) {
                if (e.key === 'Escape' || e.key.toLowerCase() === 'u') {
                    closeUpgradeMenu();
                    sfx.menuBack();
                    e.preventDefault();
                    return;
                }
                // Purchase upgrades with 1-8 keys
                const upgradeKeys = Object.keys(permanentUpgradesDef);
                const keyNum = parseInt(e.key);
                if (keyNum >= 1 && keyNum <= 8) {
                    const upgradeKey = upgradeKeys[keyNum - 1];
                    if (upgradeKey) {
                        purchaseUpgrade(upgradeKey);
                    }
                    e.preventDefault();
                    return;
                }
                return;
            }

            // Class selection
            if (!game.classSelected) {
                // Open upgrade menu with U
                if (e.key.toLowerCase() === 'u') {
                    game.showUpgradeMenu = true;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                // Open achievements with A
                if (e.key.toLowerCase() === 'a') {
                    game.showAchievements = true;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                // Open bestiary with B
                if (e.key.toLowerCase() === 'b') {
                    game.showBestiary = true;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                // Open key bindings with K
                if (e.key.toLowerCase() === 'k') {
                    game.showKeyBindings = true;
                    sfx.menuSelect();
                    e.preventDefault();
                    return;
                }
                // Character customization keys
                if (e.key.toLowerCase() === 'z') {
                    game.customization.skin = (game.customization.skin + 1) % characterColors.skin.length;
                    saveCharacterCustomization();
                    e.preventDefault();
                    return;
                }
                if (e.key.toLowerCase() === 'x') {
                    game.customization.hair = (game.customization.hair + 1) % characterColors.hair.length;
                    saveCharacterCustomization();
                    e.preventDefault();
                    return;
                }
                if (e.key.toLowerCase() === 'c') {
                    game.customization.outfit = (game.customization.outfit + 1) % characterColors.outfit.length;
                    saveCharacterCustomization();
                    e.preventDefault();
                    return;
                }
                if (e.key === '1') {
                    selectPlayerClass('warrior');
                    e.preventDefault();
                    return;
                } else if (e.key === '2') {
                    selectPlayerClass('mage');
                    e.preventDefault();
                    return;
                } else if (e.key === '3') {
                    selectPlayerClass('rogue');
                    e.preventDefault();
                    return;
                }
            }

            // Normalize key to lowercase for letters
            const key = e.key.length === 1 ? e.key.toLowerCase() : e.key;
            if (key in game.keys) {
                game.keys[key] = true;
                e.preventDefault();
            }

            // Space for attack (single press)
            if (e.key === ' ' && !game.spacePressed) {
                game.spacePressed = true;
                playerAttack();
                e.preventDefault();
            }

            // Left Shift for dash (location 1 = left side keys)
            if (e.key === 'Shift' && e.location === 1 && !game.player.isDying && game.player.dashCooldown <= 0 && !game.player.isDashing) {
                executeDash();
                e.preventDefault();
            }

            // Number keys for items (X+Number = drop, Number = use)
            // Use keyCode/code for reliable detection
            const numKey = e.code ? e.code.match(/Digit(\d)/) : null;
            const keyNum = numKey ? parseInt(numKey[1]) : (e.key >= '1' && e.key <= '9' ? parseInt(e.key) : 0);

            if (keyNum >= 1 && keyNum <= 9) {
                const slot = keyNum - 1;
                if (game.keys.x) {
                    // X is held, drop item
                    dropItem(slot);
                } else {
                    useItem(slot);
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            // Normalize key to lowercase for letters
            const key = e.key.length === 1 ? e.key.toLowerCase() : e.key;
            if (key in game.keys) {
                game.keys[key] = false;
            }

            // Reset space press flag
            if (e.key === ' ') {
                game.spacePressed = false;
            }
        });

        document.getElementById('healButton').addEventListener('click', () => {
            if (game.player.gold >= 50) {
                game.player.gold -= 50;
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 50);
                // Start drinking animation
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = 50;
                game.player.drinkColor = '#ff1493';
                sfx.heal();  // Heal sound
                addLog('Heiltrank gekauft! +50 HP', 'loot');
            } else {
                addLog('Nicht genug Gold!', 'combat');
            }
        });

        // Voll-Heal Button - Preis basiert auf fehlenden HP (2 Gold pro fehlender HP, min 10)
        function getFullHealPrice() {
            const missingHp = game.player.maxHp - game.player.hp;
            return Math.max(10, Math.floor(missingHp * 2));
        }

        function updateFullHealButton() {
            const price = getFullHealPrice();
            const priceSpan = document.getElementById('fullHealPrice');
            if (priceSpan) priceSpan.textContent = `${price}G`;
        }

        document.getElementById('fullHealButton').addEventListener('click', () => {
            const price = getFullHealPrice();
            if (game.player.hp >= game.player.maxHp) {
                addLog('Du hast bereits volle HP!', 'info');
                return;
            }
            if (game.player.gold >= price) {
                game.player.gold -= price;
                const healAmount = game.player.maxHp - game.player.hp;
                game.player.hp = game.player.maxHp;
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = healAmount;
                game.player.drinkColor = '#ff69b4';
                sfx.heal();
                addLog(`Voll-Heal für ${price}G! +${healAmount} HP`, 'loot');
                updateFullHealButton();
            } else {
                addLog(`Nicht genug Gold! (${price} benötigt)`, 'combat');
            }
        });

        // Stärke-Boost Button (75 Gold) - +50% Angriff für 30 Sekunden
        document.getElementById('attackBoostButton').addEventListener('click', () => {
            if (game.player.gold >= 75) {
                game.player.gold -= 75;
                const boostAmount = Math.floor(game.player.attack * 0.5);
                game.player.attackBoost = (game.player.attackBoost || 0) + boostAmount;
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = 0;
                game.player.drinkColor = '#ff4500';
                sfx.powerUp();
                addLog(`[TRANK] +${boostAmount} Angriff für 30s!`, 'loot');
                setTimeout(() => {
                    game.player.attackBoost = Math.max(0, (game.player.attackBoost || 0) - boostAmount);
                    addLog('[INFO] Stärkungseffekt abgelaufen.', 'info');
                }, 30000);
            } else {
                addLog('Nicht genug Gold! (75 benötigt)', 'combat');
            }
        });

        // Goldschild kaufen Button (75 Gold) - adds a gold shield to inventory
        document.getElementById('defenseBoostButton').addEventListener('click', () => {
            if (game.player.gold >= 75) {
                // Check for empty inventory slot
                let added = false;
                for (let i = 0; i < game.player.inventory.length; i++) {
                    if (!game.player.inventory[i]) {
                        const goldShield = {
                            name: 'Goldschild',
                            defense: 12,
                            type: 'armor',
                            style: 'plate',
                            tier: 'uncommon'
                        };
                        game.player.inventory[i] = goldShield;
                        added = true;
                        break;
                    }
                }
                if (!added && game.player.inventory.length < 9) {
                    const goldShield = {
                        name: 'Goldschild',
                        defense: 12,
                        type: 'armor',
                        style: 'plate',
                        tier: 'uncommon'
                    };
                    game.player.inventory.push(goldShield);
                    added = true;
                }
                if (added) {
                    game.player.gold -= 75;
                    sfx.pickup();
                    addLog('[KAUF] Goldschild! (+12 Verteidigung)', 'loot');
                } else {
                    addLog('Inventar voll!', 'combat');
                }
            } else {
                addLog('Nicht genug Gold! (75 benötigt)', 'combat');
            }
        });

        // Bombe kaufen Button (40 Gold)
        document.getElementById('buyBombButton').addEventListener('click', () => {
            if (game.player.gold >= 40) {
                game.player.gold -= 40;
                // Find empty slot or add to existing bombs
                let added = false;
                for (let i = 0; i < game.player.inventory.length; i++) {
                    if (!game.player.inventory[i]) {
                        const bomb = { ...selectByRarity(itemTypes.bombs) };
                        game.player.inventory[i] = bomb;
                        added = true;
                        break;
                    }
                }
                if (added) {
                    sfx.pickup();
                    addLog('💣 Bombe gekauft!', 'loot');
                } else {
                    game.player.gold += 40; // Refund
                    addLog('Inventar voll!', 'combat');
                }
            } else {
                addLog('Nicht genug Gold! (40 benötigt)', 'combat');
            }
        });

        // ==================== SPEICHER SYSTEM ====================
        function saveGame() {
            const saveData = {
                version: 1,
                timestamp: Date.now(),
                player: {
                    x: game.player.x,
                    y: game.player.y,
                    hp: game.player.hp,
                    maxHp: game.player.maxHp,
                    attack: game.player.attack,
                    baseAttack: game.player.baseAttack,
                    defense: game.player.defense,
                    baseDefense: game.player.baseDefense,
                    gold: game.player.gold,
                    xp: game.player.xp,
                    xpToNext: game.player.xpToNext,
                    level: game.player.level,
                    inventory: game.player.inventory,
                    equipment: game.player.equipment
                },
                currentRoom: game.currentRoom,
                roomsCleared: game.roomsCleared,
                monstersKilled: game.monstersKilled
            };

            try {
                localStorage.setItem('dungeonCrawlerSave', JSON.stringify(saveData));
                addLog('💾 Spiel gespeichert!', 'info');
                sfx.pickup();
            } catch (e) {
                addLog('Fehler beim Speichern!', 'combat');
            }
        }

        function loadGame() {
            try {
                const saveStr = localStorage.getItem('dungeonCrawlerSave');
                if (!saveStr) {
                    addLog('Kein Spielstand gefunden!', 'combat');
                    return false;
                }

                const saveData = JSON.parse(saveStr);

                // Restore player data (position set by generateFloor)
                game.player.hp = saveData.player.hp;
                game.player.maxHp = saveData.player.maxHp;
                game.player.attack = saveData.player.attack;
                game.player.baseAttack = saveData.player.baseAttack;
                game.player.defense = saveData.player.defense;
                game.player.baseDefense = saveData.player.baseDefense;
                game.player.gold = saveData.player.gold;
                game.player.xp = saveData.player.xp;
                game.player.xpToNext = saveData.player.xpToNext;
                game.player.level = saveData.player.level;
                game.player.inventory = saveData.player.inventory || [];
                game.player.equipment = saveData.player.equipment || {};

                game.currentRoom = saveData.currentRoom;
                game.roomsCleared = saveData.roomsCleared;
                game.monstersKilled = saveData.monstersKilled;

                // Regenerate room with correct level
                generateRoom();
                // generateFloor() sets player position - update camera to follow
                updateCamera();
                // Note: Monsters and items are spawned by generateFloor()

                updateInventory();
                updateUI();

                const saveDate = new Date(saveData.timestamp).toLocaleString('de-DE');
                addLog(`📂 Spielstand geladen! (${saveDate})`, 'loot');
                addLog(`Level ${game.player.level}, Raum ${game.currentRoom}`, 'info');
                sfx.levelUp();

                return true;
            } catch (e) {
                addLog('Fehler beim Laden!', 'combat');
                return false;
            }
        }

        document.getElementById('saveButton').addEventListener('click', saveGame);
        document.getElementById('loadButton').addEventListener('click', loadGame);
        document.getElementById('highscoreButton').addEventListener('click', showHighscoreMenu);

        // Difficulty selector
        document.getElementById('difficultySelect').addEventListener('change', (e) => {
            game.difficulty = e.target.value;
            const info = document.getElementById('difficultyInfo');
            const descriptions = {
                easy: 'Monster: -30% HP/ATK, +20% Drops',
                normal: 'Monster: Normal',
                hard: 'Monster: +50% HP, +30% ATK, -20% Drops'
            };
            info.textContent = descriptions[game.difficulty];
            addLog(`Schwierigkeit: ${game.difficulty.charAt(0).toUpperCase() + game.difficulty.slice(1)}`, 'info');
        });

        // Get difficulty multipliers
        function getDifficultyMultipliers() {
            switch (game.difficulty) {
                case 'easy':
                    return { hp: 0.7, attack: 0.7, defense: 0.8, dropRate: 1.2, gold: 1.2 };
                case 'hard':
                    return { hp: 1.5, attack: 1.3, defense: 1.2, dropRate: 0.8, gold: 0.7 };
                default: // normal
                    return { hp: 1, attack: 1, defense: 1, dropRate: 1, gold: 1 };
            }
        }

        // ==================== MUSIK SYSTEM ====================
        const music = {
            context: null,
            isPlaying: false,
            masterGain: null,
            oscillators: [],
            intervalIds: [],

            // Dungeon-Melodie Noten (Moll-Tonleiter für düstere Stimmung)
            notes: {
                // A-Moll Tonleiter
                A2: 110, B2: 123.47, C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196,
                A3: 220, B3: 246.94, C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392,
                A4: 440
            },

            init() {
                if (this.context) return;
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.context.destination);
            },

            createOscillator(freq, type = 'sine', gainValue = 0.1) {
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = gainValue;
                osc.connect(gain);
                gain.connect(this.masterGain);
                return { osc, gain };
            },

            playNote(freq, duration, type = 'sine', gainValue = 0.1, delay = 0) {
                const startTime = this.context.currentTime + delay;
                const { osc, gain } = this.createOscillator(freq, type, 0);

                // Envelope
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(gainValue, startTime + 0.05);
                gain.gain.linearRampToValueAtTime(gainValue * 0.7, startTime + duration * 0.5);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration + 0.1);
            },

            // Bass-Linie
            playBassLine() {
                const bassNotes = [this.notes.A2, this.notes.E3, this.notes.A2, this.notes.D3];
                let noteIndex = 0;

                const playBass = () => {
                    if (!this.isPlaying) return;
                    this.playNote(bassNotes[noteIndex], 0.8, 'triangle', 0.15);
                    noteIndex = (noteIndex + 1) % bassNotes.length;
                };

                playBass();
                const id = setInterval(playBass, 800);
                this.intervalIds.push(id);
            },

            // Melodie
            playMelody() {
                const melodyPatterns = [
                    [this.notes.A3, this.notes.C4, this.notes.E4, this.notes.A4],
                    [this.notes.A3, this.notes.D4, this.notes.F4, this.notes.A4],
                    [this.notes.G3, this.notes.B3, this.notes.D4, this.notes.G4],
                    [this.notes.A3, this.notes.C4, this.notes.E4, this.notes.C4]
                ];
                let patternIndex = 0;
                let noteIndex = 0;

                const playMelodyNote = () => {
                    if (!this.isPlaying) return;
                    const pattern = melodyPatterns[patternIndex];
                    this.playNote(pattern[noteIndex], 0.3, 'sine', 0.08);

                    noteIndex++;
                    if (noteIndex >= pattern.length) {
                        noteIndex = 0;
                        patternIndex = (patternIndex + 1) % melodyPatterns.length;
                    }
                };

                const id = setInterval(playMelodyNote, 400);
                this.intervalIds.push(id);
            },

            // Atmosphärischer Hintergrund
            playAmbient() {
                const ambientNotes = [this.notes.A2, this.notes.E3];
                let noteIndex = 0;

                const playAmbientNote = () => {
                    if (!this.isPlaying) return;
                    // Leiser, langer Ton für Atmosphäre
                    this.playNote(ambientNotes[noteIndex], 3, 'sine', 0.03);
                    this.playNote(ambientNotes[noteIndex] * 1.5, 3, 'sine', 0.02); // Quinte
                    noteIndex = (noteIndex + 1) % ambientNotes.length;
                };

                playAmbientNote();
                const id = setInterval(playAmbientNote, 3200);
                this.intervalIds.push(id);
            },

            // Percussion/Drums
            playDrums() {
                let beat = 0;

                const playBeat = () => {
                    if (!this.isPlaying) return;

                    // Kick auf 1 und 3
                    if (beat % 4 === 0 || beat % 4 === 2) {
                        this.playNote(60, 0.15, 'sine', 0.2);
                    }
                    // Hi-Hat auf jede Zählzeit
                    this.playNote(800 + Math.random() * 200, 0.05, 'square', 0.02);

                    beat++;
                };

                const id = setInterval(playBeat, 200);
                this.intervalIds.push(id);
            },

            start() {
                this.init();
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                this.isPlaying = true;

                this.playBassLine();
                this.playMelody();
                this.playAmbient();
                this.playDrums();
            },

            stop() {
                this.isPlaying = false;
                this.intervalIds.forEach(id => clearInterval(id));
                this.intervalIds = [];
            },

            toggle() {
                if (this.isPlaying) {
                    this.stop();
                    return false;
                } else {
                    this.start();
                    return true;
                }
            }
        };

        // Music button handler
        document.getElementById('musicButton').addEventListener('click', () => {
            const isPlaying = music.toggle();
            document.getElementById('musicButton').textContent = isPlaying ? '🎵' : '🔇';
        });

        // ==================== END MUSIK SYSTEM ====================

        // ==================== SOUND EFFECTS SYSTEM (REALISTIC) ====================
        const sfx = {
            context: null,
            enabled: true,
            volume: 0.5,

            init() {
                if (!this.context) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
            },

            // Erstellt einen Reverb-Effekt
            createReverb(duration = 1) {
                const sampleRate = this.context.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.context.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }

                const convolver = this.context.createConvolver();
                convolver.buffer = impulse;
                return convolver;
            },

            // Realistisches Rauschen mit Hüllkurve
            createNoise(duration, filterFreq = 1000, filterType = 'lowpass', attack = 0.01, decay = 0.1) {
                const bufferSize = this.context.sampleRate * (duration + 0.1);
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.context.createBufferSource();
                const filter = this.context.createBiquadFilter();
                const gain = this.context.createGain();

                noise.buffer = buffer;
                filter.type = filterType;
                filter.frequency.value = filterFreq;
                filter.Q.value = 1;

                const now = this.context.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume, now + attack);
                gain.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);

                noise.connect(filter);
                filter.connect(gain);

                return { noise, gain, filter };
            },

            // Komplexer Ton mit Obertönen
            createComplexTone(freq, harmonics = [1, 0.5, 0.25], types = ['sine']) {
                const oscillators = [];
                const gainNode = this.context.createGain();

                harmonics.forEach((amp, i) => {
                    const osc = this.context.createOscillator();
                    const oscGain = this.context.createGain();
                    osc.type = types[i % types.length];
                    osc.frequency.value = freq * (i + 1);
                    oscGain.gain.value = amp * this.volume;
                    osc.connect(oscGain);
                    oscGain.connect(gainNode);
                    oscillators.push({ osc, gain: oscGain });
                });

                return { oscillators, masterGain: gainNode };
            },

            // === SCHWERT & WAFFEN ===

            swordSwing() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Metallisches Schwingen
                const { noise, gain } = this.createNoise(0.2, 3000, 'highpass', 0.01, 0.15);
                gain.connect(this.context.destination);
                noise.start(now);

                // Luft-Whoosh
                const { noise: whoosh, gain: whooshGain, filter } = this.createNoise(0.25, 800, 'bandpass', 0.02, 0.2);
                filter.Q.value = 2;
                filter.frequency.setValueAtTime(400, now);
                filter.frequency.linearRampToValueAtTime(1200, now + 0.1);
                filter.frequency.linearRampToValueAtTime(600, now + 0.2);
                whooshGain.gain.value *= 0.6;
                whooshGain.connect(this.context.destination);
                whoosh.start(now);
            },

            punch() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Dumpfer Aufprall
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);

                filter.type = 'lowpass';
                filter.frequency.value = 200;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.8, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.2);

                // Fleisch-Aufprall
                const { noise, gain: nGain } = this.createNoise(0.08, 400, 'lowpass', 0.005, 0.06);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            // === SPIELER ===

            playerHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Schmerz-Grunt
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(180, now);
                osc.frequency.linearRampToValueAtTime(120, now + 0.15);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.linearRampToValueAtTime(300, now + 0.15);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.25);

                // Impact
                const { noise, gain: nGain } = this.createNoise(0.1, 600, 'lowpass', 0.005, 0.08);
                nGain.gain.value *= 0.4;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            playerDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Todes-Stöhnen
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'sawtooth';
                    const startFreq = 200 - i * 40;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.2);
                    osc.frequency.linearRampToValueAtTime(startFreq * 0.5, now + i * 0.2 + 0.4);

                    filter.type = 'lowpass';
                    filter.frequency.value = 600 - i * 100;

                    gain.gain.setValueAtTime(0, now + i * 0.2);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + i * 0.2 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.5);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.2);
                    osc.stop(now + i * 0.2 + 0.6);
                }
            },

            // === MAGIE ===

            magicShoot() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Summen mit Shimmer
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const baseFreq = 400 + i * 200;
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(baseFreq * 1.5, now + 0.15);

                    // LFO für Shimmer
                    const lfo = this.context.createOscillator();
                    const lfoGain = this.context.createGain();
                    lfo.frequency.value = 20 + i * 5;
                    lfoGain.gain.value = 30;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(this.volume * (0.2 - i * 0.05), now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.35);
                    lfo.stop(now + 0.35);
                }
            },

            fireShoot() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Feuer-Rauschen
                const { noise, gain, filter } = this.createNoise(0.4, 2000, 'bandpass', 0.02, 0.35);
                filter.Q.value = 0.5;
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.value *= 0.7;
                gain.connect(this.context.destination);
                noise.start(now);

                // Tiefes Wumm
                const osc = this.context.createOscillator();
                const oscGain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                oscGain.gain.setValueAtTime(this.volume * 0.3, now);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                osc.connect(oscGain);
                oscGain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.3);
            },

            // === SKELETT ===

            skeletonHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Realistische Knochen-Klicks
                for (let i = 0; i < 5; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'triangle';
                    const freq = 1200 + Math.random() * 800;
                    osc.frequency.setValueAtTime(freq, now + i * 0.025);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + i * 0.025 + 0.04);

                    filter.type = 'highpass';
                    filter.frequency.value = 800;
                    filter.Q.value = 5;

                    gain.gain.setValueAtTime(0, now + i * 0.025);
                    gain.gain.linearRampToValueAtTime(this.volume * (0.3 - i * 0.04), now + i * 0.025 + 0.002);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.025 + 0.05);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.025);
                    osc.stop(now + i * 0.025 + 0.08);
                }
            },

            skeletonDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Viele Knochen fallen
                for (let i = 0; i < 12; i++) {
                    const delay = i * 0.04 + Math.random() * 0.02;
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'triangle';
                    const freq = 800 + Math.random() * 1200;
                    osc.frequency.setValueAtTime(freq, now + delay);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.2, now + delay + 0.08);

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    gain.gain.setValueAtTime(0, now + delay);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + delay + 0.003);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.1);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.15);
                }

                // Zusammenbruch-Rauschen
                const { noise, gain } = this.createNoise(0.4, 3000, 'highpass', 0.05, 0.35);
                gain.gain.value *= 0.3;
                gain.connect(this.context.destination);
                noise.start(now + 0.1);
            },

            // === GOBLIN ===

            goblinHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Hohes Quieken
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(900, now + 0.03);
                osc.frequency.linearRampToValueAtTime(500, now + 0.12);

                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.35, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            goblinDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Langer Todesschrei
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(700, now);
                osc.frequency.linearRampToValueAtTime(400, now + 0.3);
                osc.frequency.linearRampToValueAtTime(200, now + 0.5);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2500, now);
                filter.frequency.linearRampToValueAtTime(500, now + 0.4);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.02);
                gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            // === ORK ===

            orcHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Tiefes Grunzen
                const osc = this.context.createOscillator();
                const osc2 = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc2.frequency.setValueAtTime(102, now); // Leichte Verstimmung
                osc.frequency.linearRampToValueAtTime(80, now + 0.15);
                osc2.frequency.linearRampToValueAtTime(78, now + 0.15);

                filter.type = 'lowpass';
                filter.frequency.value = 400;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.25);
                osc2.stop(now + 0.25);
            },

            orcDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Langes tiefes Stöhnen
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.linearRampToValueAtTime(60, now + 0.6);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, now);
                filter.frequency.linearRampToValueAtTime(150, now + 0.5);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.03);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.8);

                // Aufprall
                const { noise, gain: nGain } = this.createNoise(0.2, 200, 'lowpass', 0.01, 0.15);
                nGain.gain.value *= 0.4;
                nGain.connect(this.context.destination);
                noise.start(now + 0.4);
            },

            // === MAGIER ===

            mageHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Flackern
                for (let i = 0; i < 4; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const freq = 800 + i * 300 + Math.random() * 100;
                    osc.frequency.setValueAtTime(freq, now + i * 0.02);

                    gain.gain.setValueAtTime(0, now + i * 0.02);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + i * 0.02 + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.02 + 0.08);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.02);
                    osc.stop(now + i * 0.02 + 0.1);
                }
            },

            mageDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magie entweicht
                for (let i = 0; i < 8; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const startFreq = 1500 - i * 100;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.06);
                    osc.frequency.exponentialRampToValueAtTime(200, now + i * 0.06 + 0.3);

                    gain.gain.setValueAtTime(0, now + i * 0.06);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + i * 0.06 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.35);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.06);
                    osc.stop(now + i * 0.06 + 0.4);
                }
            },

            // === DÄMON ===

            demonHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Dunkles Knurren
                const osc = this.context.createOscillator();
                const osc2 = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();
                const distortion = this.context.createWaveShaper();

                // Distortion curve
                const curve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i - 128) / 128;
                    curve[i] = Math.tanh(x * 2);
                }
                distortion.curve = curve;

                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(70, now);
                osc2.frequency.setValueAtTime(71, now);

                filter.type = 'lowpass';
                filter.frequency.value = 300;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

                osc.connect(distortion);
                osc2.connect(distortion);
                distortion.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.3);
                osc2.stop(now + 0.3);
            },

            demonDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Höllisches Brüllen
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.8);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, now);
                filter.frequency.linearRampToValueAtTime(100, now + 0.7);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.6, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 1.1);

                // Explosives Rauschen
                const { noise, gain: nGain } = this.createNoise(0.5, 400, 'lowpass', 0.1, 0.4);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now + 0.2);
            },

            // === BOSS ===

            bossHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Massiver Impact
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.6, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.35);

                const { noise, gain: nGain } = this.createNoise(0.15, 500, 'lowpass', 0.01, 0.12);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            bossDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Epischer Todesschrei
                for (let i = 0; i < 5; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sawtooth';
                    const startFreq = 150 - i * 20;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.15);
                    osc.frequency.linearRampToValueAtTime(startFreq * 0.3, now + i * 0.15 + 0.4);

                    gain.gain.setValueAtTime(0, now + i * 0.15);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + i * 0.15 + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.5);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.15);
                    osc.stop(now + i * 0.15 + 0.6);
                }

                // Massive Explosion
                const { noise, gain } = this.createNoise(1, 600, 'lowpass', 0.1, 0.8);
                gain.gain.value *= 0.6;
                gain.connect(this.context.destination);
                noise.start(now + 0.3);
            },

            // Monster-Dispatcher
            monsterHit(style, isBoss = false) {
                if (isBoss) this.bossHit();
                else if (style === 'skeleton') this.skeletonHit();
                else if (style === 'goblin') this.goblinHit();
                else if (style === 'orc') this.orcHit();
                else if (style === 'mage') this.mageHit();
                else if (style === 'demon') this.demonHit();
                else this.punch();
            },

            monsterDeath(style, isBoss = false) {
                if (isBoss) this.bossDeath();
                else if (style === 'skeleton') this.skeletonDeath();
                else if (style === 'goblin') this.goblinDeath();
                else if (style === 'orc') this.orcDeath();
                else if (style === 'mage') this.mageDeath();
                else if (style === 'demon') this.demonDeath();
                else this.goblinDeath();
            },

            // === ITEMS & UI ===

            itemPickup() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const notes = [523, 659, 784]; // C5, E5, G5
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.2);
                });
            },

            heal() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Gluckern
                for (let i = 0; i < 6; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400 + i * 80, now + i * 0.08);
                    osc.frequency.linearRampToValueAtTime(600 + i * 80, now + i * 0.08 + 0.1);

                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.2);
                }
            },

            levelUp() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const notes = [523, 587, 659, 784, 880, 1047]; // C-Dur aufsteigend
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const osc2 = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc2.type = 'triangle';
                    osc.frequency.value = freq;
                    osc2.frequency.value = freq * 2;

                    gain.gain.setValueAtTime(0, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + i * 0.1 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.25);

                    osc.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.1);
                    osc2.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.3);
                    osc2.stop(now + i * 0.1 + 0.3);
                });
            },

            bossPhase() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Dramatic phase transition sound
                // Deep rumble
                const osc1 = this.context.createOscillator();
                const gain1 = this.context.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(80, now);
                osc1.frequency.linearRampToValueAtTime(120, now + 0.3);
                gain1.gain.setValueAtTime(0, now);
                gain1.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.1);
                gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc1.connect(gain1);
                gain1.connect(this.context.destination);
                osc1.start(now);
                osc1.stop(now + 0.6);

                // Warning chord
                const notes = [220, 277, 330]; // A minor chord
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + 0.15);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + 0.15);
                    osc.stop(now + 0.9);
                });
            },

            doorOpen() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Knarren
                const { noise, gain, filter } = this.createNoise(0.4, 400, 'bandpass', 0.05, 0.35);
                filter.Q.value = 5;
                filter.frequency.setValueAtTime(200, now);
                filter.frequency.linearRampToValueAtTime(500, now + 0.2);
                filter.frequency.linearRampToValueAtTime(300, now + 0.4);
                gain.gain.value *= 0.4;
                gain.connect(this.context.destination);
                noise.start(now);

                // Metallisches Klicken
                const osc = this.context.createOscillator();
                const oscGain = this.context.createGain();
                osc.type = 'square';
                osc.frequency.value = 1200;
                oscGain.gain.setValueAtTime(this.volume * 0.15, now + 0.3);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                osc.connect(oscGain);
                oscGain.connect(this.context.destination);
                osc.start(now + 0.3);
                osc.stop(now + 0.4);
            },

            newRoom() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Atmosphärischer Ton
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = 220;

                filter.type = 'lowpass';
                filter.frequency.value = 500;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            bombThrow() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Wurf-Whoosh
                const { noise, gain, filter } = this.createNoise(0.2, 1500, 'bandpass', 0.02, 0.15);
                filter.Q.value = 1;
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.linearRampToValueAtTime(2000, now + 0.1);
                gain.connect(this.context.destination);
                noise.start(now);
            },

            bombExplode() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Tiefe Explosion
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.8, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);

                // Explosions-Rauschen
                const { noise, gain: nGain, filter } = this.createNoise(0.6, 2000, 'lowpass', 0.01, 0.5);
                filter.frequency.setValueAtTime(4000, now);
                filter.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                nGain.gain.value *= 0.7;
                nGain.connect(this.context.destination);
                noise.start(now);

                // Nachhall
                const { noise: echo, gain: echoGain } = this.createNoise(0.8, 500, 'lowpass', 0.2, 0.6);
                echoGain.gain.value *= 0.3;
                echoGain.connect(this.context.destination);
                echo.start(now + 0.2);
            },

            goldPickup() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Münzen-Klingeln
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = 2000 + i * 500 + Math.random() * 200;

                    gain.gain.setValueAtTime(0, now + i * 0.05);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + i * 0.05 + 0.005);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.1);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.05);
                    osc.stop(now + i * 0.05 + 0.15);
                }
            },

            // === NEW SOUND EFFECTS ===

            explosion() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Deep boom
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.3);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.7, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.5);

                // Explosion noise burst
                const { noise, gain: nGain, filter } = this.createNoise(0.4, 1500, 'lowpass', 0.01, 0.35);
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampToValueAtTime(300, now + 0.35);
                nGain.gain.value *= 0.6;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            powerUp() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Ascending magical tones
                const notes = [330, 440, 550, 660, 880];
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + i * 0.06);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + i * 0.06 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.15);
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.06);
                    osc.stop(now + i * 0.06 + 0.2);
                });

                // Shimmer overlay
                const shimmer = this.context.createOscillator();
                const shimmerGain = this.context.createGain();
                shimmer.type = 'triangle';
                shimmer.frequency.setValueAtTime(1200, now);
                shimmer.frequency.linearRampToValueAtTime(1800, now + 0.3);
                shimmerGain.gain.setValueAtTime(0, now);
                shimmerGain.gain.linearRampToValueAtTime(this.volume * 0.1, now + 0.1);
                shimmerGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                shimmer.connect(shimmerGain);
                shimmerGain.connect(this.context.destination);
                shimmer.start(now);
                shimmer.stop(now + 0.4);
            },

            pickup() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Quick pickup chime
                const notes = [600, 800];
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + i * 0.05);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + i * 0.05 + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.1);
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.05);
                    osc.stop(now + i * 0.05 + 0.15);
                });
            },

            dash() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Whoosh sound
                const { noise, gain, filter } = this.createNoise(0.2, 1200, 'bandpass', 0.01, 0.15);
                filter.Q.value = 1.5;
                filter.frequency.setValueAtTime(600, now);
                filter.frequency.linearRampToValueAtTime(1800, now + 0.08);
                filter.frequency.linearRampToValueAtTime(400, now + 0.18);
                gain.gain.value *= 0.5;
                gain.connect(this.context.destination);
                noise.start(now);

                // Quick low swoosh
                const osc = this.context.createOscillator();
                const oscGain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                oscGain.gain.setValueAtTime(this.volume * 0.3, now);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(oscGain);
                oscGain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            chestOpen() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Creaky wooden lid
                const { noise, gain, filter } = this.createNoise(0.25, 600, 'bandpass', 0.02, 0.2);
                filter.Q.value = 3;
                filter.frequency.setValueAtTime(300, now);
                filter.frequency.linearRampToValueAtTime(700, now + 0.1);
                filter.frequency.linearRampToValueAtTime(400, now + 0.2);
                gain.gain.value *= 0.35;
                gain.connect(this.context.destination);
                noise.start(now);

                // Magical reveal tones
                const notes = [392, 494, 587, 784]; // G4, B4, D5, G5
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const g = this.context.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    g.gain.setValueAtTime(0, now + 0.15 + i * 0.05);
                    g.gain.linearRampToValueAtTime(this.volume * 0.2, now + 0.15 + i * 0.05 + 0.02);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 0.15 + i * 0.05 + 0.2);
                    osc.connect(g);
                    g.connect(this.context.destination);
                    osc.start(now + 0.15 + i * 0.05);
                    osc.stop(now + 0.15 + i * 0.05 + 0.25);
                });
            },

            achievement() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Triumphant fanfare
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const osc2 = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.type = 'sine';
                    osc2.type = 'triangle';
                    osc.frequency.value = freq;
                    osc2.frequency.value = freq * 2;
                    gain.gain.setValueAtTime(0, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.35, now + i * 0.1 + 0.02);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + i * 0.1 + 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.4);
                    osc.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.1);
                    osc2.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.5);
                    osc2.stop(now + i * 0.1 + 0.5);
                });

                // Sparkle overlay
                for (let i = 0; i < 5; i++) {
                    const sparkle = this.context.createOscillator();
                    const sGain = this.context.createGain();
                    sparkle.type = 'sine';
                    sparkle.frequency.value = 2000 + Math.random() * 1000;
                    sGain.gain.setValueAtTime(0, now + 0.3 + i * 0.05);
                    sGain.gain.linearRampToValueAtTime(this.volume * 0.1, now + 0.3 + i * 0.05 + 0.01);
                    sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3 + i * 0.05 + 0.08);
                    sparkle.connect(sGain);
                    sGain.connect(this.context.destination);
                    sparkle.start(now + 0.3 + i * 0.05);
                    sparkle.stop(now + 0.3 + i * 0.05 + 0.1);
                }
            },

            secretRoom() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Mysterious reveal chord
                const notes = [220, 277, 330, 440]; // A minor with octave
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.frequency.linearRampToValueAtTime(2000, now + 0.5);
                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + i * 0.08 + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.8);
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.9);
                });

                // Eerie whisper noise
                const { noise, gain } = this.createNoise(0.6, 800, 'bandpass', 0.2, 0.5);
                gain.gain.value *= 0.15;
                gain.connect(this.context.destination);
                noise.start(now);
            },

            criticalHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Heavy impact
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.7, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.25);

                // High pitch ring
                const ring = this.context.createOscillator();
                const ringGain = this.context.createGain();
                ring.type = 'sine';
                ring.frequency.value = 1500;
                ringGain.gain.setValueAtTime(0, now);
                ringGain.gain.linearRampToValueAtTime(this.volume * 0.3, now + 0.02);
                ringGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                ring.connect(ringGain);
                ringGain.connect(this.context.destination);
                ring.start(now);
                ring.stop(now + 0.3);

                // Impact crunch
                const { noise, gain: nGain } = this.createNoise(0.1, 1000, 'highpass', 0.005, 0.08);
                nGain.gain.value *= 0.4;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            menuSelect() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(this.volume * 0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            menuBack() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.value = 400;
                gain.gain.setValueAtTime(this.volume * 0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        };
        // ==================== END SOUND EFFECTS ====================

        // Sound Effects toggle button
        document.getElementById('sfxButton').addEventListener('click', () => {
            sfx.enabled = !sfx.enabled;
            document.getElementById('sfxButton').textContent = sfx.enabled ? '🔊' : '🔈';
        });

        // Fullscreen toggle
        document.getElementById('fullscreenButton').addEventListener('click', () => {
            const container = document.getElementById('gameContainer');
            if (!document.fullscreenElement) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                document.getElementById('fullscreenButton').textContent = '[X]';
                document.getElementById('fullscreenButton').title = 'Vollbild beenden';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                document.getElementById('fullscreenButton').textContent = '[FS]';
                document.getElementById('fullscreenButton').title = 'Vollbild';
            }
        });

        // ==================== SECRET MENU SYSTEM ====================
        const SECRET_CODE = 'Uu09876';

        // Get all available weapons for the give command
        function getAllWeapons() {
            const weapons = [...itemTypes.weapons];
            // Add monster drops
            for (const drop of Object.values(itemTypes.monsterDrops)) {
                weapons.push(...drop.items.filter(i => i.type === 'weapon'));
            }
            return weapons;
        }

        function getAllItems() {
            return {
                weapons: getAllWeapons(),
                armor: itemTypes.armor,
                potions: itemTypes.potions,
                bombs: itemTypes.bombs
            };
        }

        function openSecretMenu() {
            game.secretMenuOpen = true;
            document.getElementById('secretMenu').style.display = 'block';
            document.getElementById('commandInput').focus();
            addCommandOutput('🔓 Entwickler-Menü aktiviert!', 'success');
        }

        function closeSecretMenu() {
            game.secretMenuOpen = false;
            document.getElementById('secretMenu').style.display = 'none';
            document.getElementById('commandOutput').innerHTML = '';
        }

        function addCommandOutput(text, type = 'info') {
            const output = document.getElementById('commandOutput');
            const line = document.createElement('div');
            line.className = `cmd-line cmd-${type}`;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function executeCommand(cmd) {
            const parts = cmd.trim().toLowerCase().split(/\s+/);
            const command = parts[0];

            if (command === '/help' || command === '/h' || command === '/?') {
                addCommandOutput('=== BEFEHLE ===', 'info');
                addCommandOutput('/give *name* - Item suchen & geben', 'info');
                addCommandOutput('/list weapons|armor|monsters|bosses', 'info');
                addCommandOutput('/spawn goblin|skeleton|orc|mage|demon|boss [el1|el2|el3]', 'info');
                addCommandOutput('/skip [anzahl] - Level überspringen', 'info');
                addCommandOutput('/heal - Voll heilen', 'info');
                addCommandOutput('/god - Unverwundbar', 'info');
                addCommandOutput('/kill - Alle Monster töten', 'info');
                addCommandOutput('/xp [menge] - XP geben', 'info');
                addCommandOutput('/stats - Spieler-Stats', 'info');
                addCommandOutput('/tp [x] [y] - Teleportieren', 'info');
                addCommandOutput('/clear - Items löschen', 'info');
                addCommandOutput('/speed [wert] - Spieler-Speed', 'info');
                addCommandOutput('--- NEUE BEFEHLE ---', 'info');
                addCommandOutput('/crit [chance] - Krit-Chance (0-1)', 'info');
                addCommandOutput('/status poison|burn|freeze - Status auf Monster', 'info');
                addCommandOutput('/nocooldown - Fähigkeiten-Cooldowns zurücksetzen', 'info');
                addCommandOutput('/difficulty easy|normal|hard', 'info');
                addCommandOutput('/debug - Debug-Infos ein/aus (FPS, Entities)', 'info');
                return;
            }

            if (command === '/debug') {
                game.debugMode = !game.debugMode;
                addCommandOutput(`Debug-Modus: ${game.debugMode ? 'AN' : 'AUS'}`, 'success');
                return;
            }

            if (command === '/list') {
                const listType = parts[1];
                if (listType === 'weapons' || listType === 'w') {
                    addCommandOutput('=== WAFFEN ===', 'info');
                    getAllWeapons().forEach(w => addCommandOutput(`${w.name} (${w.attack} ATK)`, 'info'));
                } else if (listType === 'armor' || listType === 'a') {
                    addCommandOutput('=== RÜSTUNGEN ===', 'info');
                    itemTypes.armor.forEach(a => addCommandOutput(`${a.name} (${a.defense} DEF)`, 'info'));
                } else if (listType === 'monsters' || listType === 'm') {
                    addCommandOutput('=== MONSTER ===', 'info');
                    monsterTypes.forEach(m => addCommandOutput(`${m.name} (${m.style})`, 'info'));
                } else if (listType === 'bosses' || listType === 'b') {
                    addCommandOutput('=== BOSSE ===', 'info');
                    bossTypes.forEach((b, i) => addCommandOutput(`${i+1}. ${b.name} (HP: ${b.hp}, ATK: ${b.attack})`, 'info'));
                } else {
                    addCommandOutput('Nutzung: /list weapons|armor|monsters|bosses', 'error');
                }
                return;
            }

            if (command === '/spawn' || command === '/s') {
                const type = parts[1];
                const eliteLevel = parts[2];  // el1, el2, el3
                const monsterMap = {
                    'goblin': 0, 'g': 0,
                    'skeleton': 1, 'skel': 1, 'sk': 1,
                    'orc': 2, 'o': 2,
                    'mage': 3, 'dark': 3, 'm': 3,
                    'demon': 4, 'd': 4,
                    'boss': 'boss', 'b': 'boss'
                };

                if (type in monsterMap) {
                    let template, isBoss = false, isElite = false;

                    // Check for elite modifier (el1, el2, el3)
                    const eliteMatch = eliteLevel ? eliteLevel.match(/^el(\d)$/i) : null;
                    const eliteTier = eliteMatch ? parseInt(eliteMatch[1]) : 0;

                    if (monsterMap[type] === 'boss') {
                        template = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                        isBoss = true;
                    } else if (eliteTier > 0) {
                        // Spawn elite version
                        template = eliteMonsterTypes[monsterMap[type]];
                        isElite = true;
                    } else {
                        template = monsterTypes[monsterMap[type]];
                    }

                    // Elite monsters get better weapons
                    const weaponPool = isElite
                        ? (eliteMonsterWeapons[template.style] || monsterWeapons[template.style] || [null])
                        : (monsterWeapons[template.style] || [null]);
                    const armorPool = isElite
                        ? (eliteMonsterArmors[template.style] || monsterArmors[template.style] || [null])
                        : (monsterArmors[template.style] || [null]);
                    const equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                    const equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];
                    const baseAtk = template.baseAttack || template.attack || 10;
                    const baseDef = template.baseDefense || template.defense || 2;

                    // Elite tier multiplier (el1=1.0x, el2=1.5x, el3=2.0x bonus stats)
                    const eliteMultiplier = eliteTier > 0 ? 1 + (eliteTier - 1) * 0.5 : 1;

                    const monster = {
                        ...template,
                        x: game.player.x + (Math.random() - 0.5) * 200,
                        y: game.player.y + (Math.random() - 0.5) * 200,
                        size: isBoss ? 35 : (isElite ? 24 : (template.style === 'orc' ? 22 : (template.style === 'goblin' ? 14 : 18))),
                        hp: Math.floor(template.hp * eliteMultiplier),
                        maxHp: Math.floor(template.hp * eliteMultiplier),
                        attack: Math.floor((baseAtk + (equippedWeapon ? equippedWeapon.attack : 0)) * eliteMultiplier),
                        defense: Math.floor((baseDef + (equippedArmor ? equippedArmor.defense : 0)) * eliteMultiplier),
                        equippedWeapon, equippedArmor,
                        weaponRange: equippedWeapon ? equippedWeapon.range : 40,
                        targetX: game.player.x, targetY: game.player.y,
                        aiTimer: 0, animFrame: 0, attackFrame: 0, flashTimer: 0, rangedCooldown: 0, meleeCooldown: 0,
                        isBoss, isElite
                    };
                    game.monsters.push(monster);
                    const eliteText = isElite ? ` (Elite Stufe ${eliteTier})` : '';
                    addCommandOutput(`[OK] ${monster.name}${eliteText} gespawnt!`, 'success');
                } else {
                    addCommandOutput('Nutzung: /spawn goblin|skeleton|orc|mage|demon|boss [el1|el2|el3]', 'error');
                }
                return;
            }

            if (command === '/stats') {
                addCommandOutput('=== SPIELER-STATS ===', 'info');
                addCommandOutput(`HP: ${game.player.hp}/${game.player.maxHp}`, 'info');
                addCommandOutput(`ATK: ${game.player.attack} (Basis: ${game.player.baseAttack})`, 'info');
                addCommandOutput(`DEF: ${game.player.defense} (Basis: ${game.player.baseDefense})`, 'info');
                addCommandOutput(`Level: ${game.player.level} | XP: ${game.player.xp}/${game.player.xpToNext}`, 'info');
                addCommandOutput(`Gold: ${game.player.gold}`, 'info');
                addCommandOutput(`Waffe: ${game.player.equippedWeapon ? game.player.equippedWeapon.name : 'Keine'}`, 'info');
                addCommandOutput(`Rüstung: ${game.player.equippedArmor ? game.player.equippedArmor.name : 'Keine'}`, 'info');
                return;
            }

            if (command === '/tp') {
                const tx = parseInt(parts[1]) || game.player.x;
                const ty = parseInt(parts[2]) || game.player.y;
                game.player.x = Math.max(30, Math.min(game.worldWidth - 30, tx));
                game.player.y = Math.max(30, Math.min(game.worldHeight - 30, ty));
                addCommandOutput(`[OK] Teleportiert zu (${Math.floor(game.player.x)}, ${Math.floor(game.player.y)})`, 'success');
                return;
            }

            if (command === '/clear') {
                const count = game.items.length;
                game.items = [];
                addCommandOutput(`[OK] ${count} Items gelöscht!`, 'success');
                return;
            }

            if (command === '/speed') {
                const spd = parseFloat(parts[1]) || 4;
                game.player.speed = Math.max(1, Math.min(20, spd));
                addCommandOutput(`[OK] Speed: ${game.player.speed}`, 'success');
                return;
            }

            // NEW COMMANDS
            if (command === '/crit') {
                const chance = parseFloat(parts[1]);
                if (isNaN(chance)) {
                    addCommandOutput(`Aktuelle Krit-Chance: ${(game.player.critChance * 100).toFixed(0)}%`, 'info');
                } else {
                    game.player.critChance = Math.max(0, Math.min(1, chance));
                    addCommandOutput(`[OK] Krit-Chance: ${(game.player.critChance * 100).toFixed(0)}%`, 'success');
                }
                return;
            }

            if (command === '/status') {
                const statusType = parts[1];
                const validTypes = ['poison', 'burn', 'freeze'];
                if (!validTypes.includes(statusType)) {
                    addCommandOutput('Nutzung: /status poison|burn|freeze', 'error');
                    return;
                }

                const effects = {
                    poison: { type: 'poison', damage: 5, duration: 300, chance: 1 },
                    burn: { type: 'burn', damage: 8, duration: 180, chance: 1 },
                    freeze: { type: 'freeze', slowAmount: 0.3, duration: 240, chance: 1 }
                };

                let count = 0;
                for (const monster of game.monsters) {
                    applyStatusEffect(monster, effects[statusType]);
                    count++;
                }
                addCommandOutput(`[OK] ${statusType} auf ${count} Monster angewendet!`, 'success');
                return;
            }

            if (command === '/nocooldown' || command === '/nocd') {
                game.player.dashCooldown = 0;
                game.player.attackCooldown = 0;
                addCommandOutput('[OK] Alle Cooldowns zurückgesetzt!', 'success');
                return;
            }

            if (command === '/difficulty' || command === '/diff') {
                const diff = parts[1];
                if (['easy', 'normal', 'hard'].includes(diff)) {
                    game.difficulty = diff;
                    document.getElementById('difficultySelect').value = diff;
                    addCommandOutput(`[OK] Schwierigkeit: ${diff}`, 'success');
                } else {
                    addCommandOutput(`Aktuelle Schwierigkeit: ${game.difficulty}`, 'info');
                    addCommandOutput('Nutzung: /difficulty easy|normal|hard', 'info');
                }
                return;
            }

            if (command === '/give' || command === '/g') {
                const itemName = parts.slice(1).join(' ').toLowerCase();

                if (!itemName) {
                    addCommandOutput('/give *name* oder /give gold *menge*', 'error');
                    return;
                }

                // Check for gold
                if (itemName === 'gold' || itemName.startsWith('gold ')) {
                    const amount = parseInt(parts[2]) || 1000;
                    game.player.gold += amount;
                    addCommandOutput(`[OK] +${amount} Gold!`, 'success');
                    return;
                }

                // Search weapons
                const weapons = getAllWeapons();
                const weapon = weapons.find(w => w.name.toLowerCase().includes(itemName));
                if (weapon) {
                    game.player.equippedWeapon = { ...weapon };
                    game.player.attack = game.player.baseAttack + weapon.attack;
                    addCommandOutput(`[OK] ${weapon.name} ausgerüstet!`, 'success');
                    return;
                }

                // Search armor
                const armor = itemTypes.armor.find(a => a.name.toLowerCase().includes(itemName));
                if (armor) {
                    game.player.equippedArmor = { ...armor };
                    game.player.defense = game.player.baseDefense + armor.defense;
                    addCommandOutput(`[OK] ${armor.name} ausgerüstet!`, 'success');
                    return;
                }

                // Search potions
                const potion = itemTypes.potions.find(p => p.name.toLowerCase().includes(itemName));
                if (potion) {
                    game.player.inventory.push({ ...potion });
                    addCommandOutput(`[OK] ${potion.name} erhalten!`, 'success');
                    return;
                }

                // Search bombs
                const bomb = itemTypes.bombs.find(b => b.name.toLowerCase().includes(itemName));
                if (bomb) {
                    game.player.inventory.push({ ...bomb });
                    addCommandOutput(`[OK] ${bomb.name} erhalten!`, 'success');
                    return;
                }

                addCommandOutput(`[ERR] "${itemName}" nicht gefunden`, 'error');
                return;
            }

            if (command === '/skip') {
                const count = Math.max(1, parseInt(parts[1]) || 1);
                for (let i = 0; i < count; i++) {
                    game.currentRoom++;
                }
                game.dyingMonsters = [];
                generateRoom();
                // generateFloor() already sets player position correctly
                updateCamera();
                game.player.spawnProtection = 180;
                // Note: Monsters and items are spawned by generateFloor()
                document.getElementById('currentRoom').textContent = game.currentRoom;
                addCommandOutput(`[OK] ${count} Level übersprungen! Jetzt in Level ${game.currentRoom}`, 'success');
                addLog(`[SKIP] Zu Level ${game.currentRoom}!`, 'info');
                return;
            }

            if (command === '/heal') {
                game.player.hp = game.player.maxHp;
                addCommandOutput('[OK] Vollständig geheilt!', 'success');
                addLog('[HEAL] Vollständig geheilt!', 'loot');
                return;
            }

            if (command === '/god') {
                game.player.defense = game.player.defense >= 9999 ? game.player.baseDefense : 9999;
                const isGod = game.player.defense >= 9999;
                addCommandOutput(isGod ? '[OK] Gott-Modus AKTIVIERT!' : '[OFF] Gott-Modus DEAKTIVIERT!', isGod ? 'success' : 'info');
                addLog(isGod ? '>>> GOTT-MODUS! <<<' : '[INFO] Gott-Modus beendet', 'level');
                return;
            }

            if (command === '/kill') {
                const count = game.monsters.length;
                game.monsters.forEach(m => {
                    game.player.xp += m.xp;
                    game.player.gold += m.gold;
                    game.monstersKilled++;
                    createParticles(m.x, m.y, m.color);
                });
                game.monsters = [];
                roomCleared();
                addCommandOutput(`[OK] ${count} Monster getötet!`, 'success');
                addLog(`[CHEAT] ${count} Monster eliminiert!`, 'combat');
                return;
            }

            if (command === '/xp') {
                const amount = parseInt(parts[1]) || 100;
                game.player.xp += amount;
                checkLevelUp();
                addCommandOutput(`[OK] ${amount} XP erhalten!`, 'success');
                addLog(`[XP] ${amount} XP erhalten!`, 'loot');
                return;
            }

            addCommandOutput(`[ERR] Unbekannter Befehl: ${command}. Tippe /help`, 'error');
        }

        // Secret code detection
        document.addEventListener('keydown', (e) => {
            // Don't track when in input field
            if (document.activeElement.tagName === 'INPUT') return;

            // ESC to close secret menu
            if (e.key === 'Escape' && game.secretMenuOpen) {
                closeSecretMenu();
                return;
            }

            // Track secret code input
            if (!game.secretMenuOpen) {
                game.secretCodeBuffer += e.key;
                // Keep only the last N characters where N is the length of the secret code
                if (game.secretCodeBuffer.length > SECRET_CODE.length) {
                    game.secretCodeBuffer = game.secretCodeBuffer.slice(-SECRET_CODE.length);
                }

                // Check if secret code was entered
                if (game.secretCodeBuffer === SECRET_CODE) {
                    game.secretCodeBuffer = '';
                    game.secretCodeUnlocked = true;
                    openSecretMenu();
                }
            }
        });

        // Command input handler
        document.getElementById('commandInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target;
                const cmd = input.value.trim();
                if (cmd) {
                    addCommandOutput(`> ${cmd}`, 'info');
                    executeCommand(cmd);
                    input.value = '';
                }
                e.preventDefault();
            } else if (e.key === 'Escape') {
                closeSecretMenu();
            }
            e.stopPropagation();
        });

        // Prevent game keys while in secret menu input
        document.getElementById('commandInput').addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        // ==================== END SECRET MENU ====================

        // Initialize
        loadPermanentProgress(); // Load permanent upgrades from localStorage
        loadAchievements(); // Load achievements from localStorage
        initDailyChallenges(); // Initialize daily challenges
        initCharacterCustomization(); // Load character customization
        initBestiary(); // Load bestiary data
        initKeyBindings(); // Load key bindings
        game.gameStartTime = Date.now(); // Track game start for speedrun achievement
        generateRoom();
        // Note: Monsters and items are spawned by generateFloor()
        addLog('Willkommen im Dungeon! Besiege alle Monster!', 'info');
        addLog('[TIPP] Left Shift = Dash', 'info');
        gameLoop();
    </script>
</body>
</html>