<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #gameContainer {
            background: #16213e;
            border: 3px solid #0f3460;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #e94560;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameArea {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        #canvasContainer {
            flex: 1;
            min-width: 900px;
            max-width: 100%;
        }

        canvas {
            border: 2px solid #0f3460;
            background: #0a0e27;
            display: block;
            width: 100%;
            height: auto;
        }

        #sidebar {
            flex: 0 0 280px;
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            display: none;  /* Hidden - using in-game HUD now */
        }

        .stat-section {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 5px;
            border-left: 3px solid #e94560;
        }

        .stat-section h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-bar {
            width: 100%;
            height: 20px;
            background: #1a1a2e;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b9d);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .xp-bar-fill {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
        }

        #inventory {
            max-height: 150px;
            overflow-y: auto;
        }

        .item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            margin: 3px 0;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .item:hover {
            background: rgba(233, 69, 96, 0.3);
        }

        .item.weapon { border-left: 3px solid #ff6b6b; }
        .item.armor { border-left: 3px solid #4ecdc4; }
        .item.potion { border-left: 3px solid #95e1d3; }

        #log {
            background: #0a0e27;
            padding: 10px;
            border-radius: 5px;
            height: 100px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 10px;
        }

        #gameControls {
            display: grid;
            grid-template-columns: repeat(5, 52px);
            grid-template-rows: repeat(2, 52px);
            gap: 8px;
            margin-top: 12px;
            justify-content: center;
            padding: 10px;
            background: linear-gradient(180deg, #2a1f1a 0%, #1a1510 100%);
            border: 4px solid #3d2f25;
            border-radius: 0;
        }

        #gameControls .button {
            width: 52px;
            height: 52px;
            margin: 0;
            padding: 2px;
            font-size: 20px;
            line-height: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Medieval 8-bit stone button style */
            background:
                linear-gradient(135deg, #6b5a4a 0%, #4a3f35 25%, #5a4f42 50%, #3d342c 75%, #2a241f 100%);
            border: 4px solid;
            border-color: #8a7a6a #2a1f1a #2a1f1a #8a7a6a;
            border-radius: 0;
            box-shadow:
                inset 3px 3px 0 #9a8a7a,
                inset -3px -3px 0 #1a1510,
                inset 6px 6px 0 rgba(255,255,255,0.1),
                5px 5px 0 #0a0805,
                6px 6px 0 #000;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            color: #e8dcc8;
            image-rendering: pixelated;
            cursor: pointer;
            transition: none;
            position: relative;
        }

        /* Stone texture overlay */
        #gameControls .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(0,0,0,0.1) 4px, rgba(0,0,0,0.1) 8px),
                repeating-linear-gradient(90deg, transparent, transparent 4px, rgba(0,0,0,0.05) 4px, rgba(0,0,0,0.05) 8px);
            pointer-events: none;
        }

        #gameControls .button .price {
            font-size: 10px;
            font-weight: bold;
            margin-top: 1px;
            color: #ffd700;
            text-shadow: 1px 1px 0 #000, 2px 2px 0 #4a3000;
        }

        #gameControls .button:hover {
            background:
                linear-gradient(135deg, #7b6a5a 0%, #5a4f45 25%, #6a5f52 50%, #4d443c 75%, #3a342f 100%);
            border-color: #aa9a8a #3a2f2a #3a2f2a #aa9a8a;
            color: #fff;
            box-shadow:
                inset 3px 3px 0 #ba9a8a,
                inset -3px -3px 0 #2a2520,
                inset 6px 6px 0 rgba(255,255,255,0.15),
                5px 5px 0 #0a0805,
                6px 6px 0 #000;
        }

        #gameControls .button:active {
            background:
                linear-gradient(135deg, #4a3f35 0%, #3d342c 50%, #2a241f 100%);
            border-color: #2a1f1a #6a5a4a #6a5a4a #2a1f1a;
            box-shadow:
                inset 3px 3px 0 #1a1510,
                inset -3px -3px 0 #6a5a4a,
                2px 2px 0 #0a0805;
            transform: translate(3px, 3px);
        }

        #gameControls .button:disabled {
            background: #3a3535;
            border-color: #4a4545 #2a2525 #2a2525 #4a4545;
            color: #666;
            box-shadow:
                inset 3px 3px 0 #4a4545,
                inset -3px -3px 0 #1a1515,
                5px 5px 0 #0a0805;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .log-message {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-combat { color: #e94560; }
        .log-loot { color: #4CAF50; }
        .log-info { color: #64b5f6; }
        .log-level { color: #ffd700; font-weight: bold; }

        #controls {
            margin-top: 15px;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 5px;
            font-size: 11px;
        }

        #controls h4 {
            color: #e94560;
            margin-bottom: 5px;
        }

        .button {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin: 5px 0;
            width: 100%;
            font-size: 12px;
            transition: background 0.2s;
        }

        .button:hover {
            background: #ff6b9d;
        }

        .button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px 70px;
            border-radius: 15px;
            border: 4px solid #e94560;
            text-align: center;
            display: none;
            z-index: 9999;
            min-width: 350px;
        }

        #gameContainer:fullscreen #gameOver,
        #gameContainer:-webkit-full-screen #gameOver {
            position: fixed;
            padding: 60px 90px;
            min-width: 450px;
        }

        #gameOver h2 {
            color: #e94560;
            font-size: 42px;
            margin-bottom: 25px;
        }

        #gameContainer:fullscreen #gameOver h2,
        #gameContainer:-webkit-full-screen #gameOver h2 {
            font-size: 52px;
        }

        #gameOver .stats {
            font-size: 18px;
        }

        #gameContainer:fullscreen #gameOver .stats,
        #gameContainer:-webkit-full-screen #gameOver .stats {
            font-size: 22px;
        }

        #highscoreMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 4px solid #fbbf24;
            text-align: center;
            display: none;
            z-index: 9998;
            min-width: 300px;
        }
        #highscoreMenu h2 {
            color: #fbbf24;
            font-size: 32px;
            margin-bottom: 20px;
        }
        #highscoreList {
            text-align: left;
            margin: 15px 0;
            max-height: 250px;
            overflow-y: auto;
        }
        .highscore-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 5px;
            font-size: 14px;
        }
        .highscore-entry.current {
            background: rgba(251, 191, 36, 0.3);
            border: 1px solid #fbbf24;
        }
        .highscore-rank { color: #fbbf24; font-weight: bold; width: 30px; }
        .highscore-name { color: #fff; flex: 1; margin: 0 10px; }
        .highscore-score { color: #4ade80; }
        #highscoreInput {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: #1a1a2e;
            border: 2px solid #fbbf24;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
            text-align: center;
        }

        /* Fullscreen mode styles */
        #gameContainer:fullscreen,
        #gameContainer:-webkit-full-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #0a0e27;
            padding: 10px;
            max-width: none;
        }

        #gameContainer:fullscreen #gameArea,
        #gameContainer:-webkit-full-screen #gameArea {
            flex-direction: column;
            align-items: center;
        }

        #gameContainer:fullscreen #canvasContainer,
        #gameContainer:-webkit-full-screen #canvasContainer {
            min-width: auto;
            max-width: 95vw;
        }

        #gameContainer:fullscreen canvas,
        #gameContainer:-webkit-full-screen canvas {
            max-height: 70vh;
            max-width: 95vw;
            width: auto;
            height: auto;
        }

        #gameContainer:fullscreen h1,
        #gameContainer:-webkit-full-screen h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        #gameContainer:fullscreen #gameControls,
        #gameContainer:-webkit-full-screen #gameControls {
            max-width: 500px;
        }

        #gameContainer:fullscreen #log,
        #gameContainer:-webkit-full-screen #log {
            max-width: 95vw;
            height: 80px;
        }

        #gameOver .stats {
            margin: 20px 0;
            font-size: 16px;
        }

        /* Secret Menu Styles */
        #secretMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 4px solid #fbbf24;
            text-align: center;
            z-index: 9999;
            min-width: 400px;
        }

        #secretMenu h2 {
            color: #fbbf24;
            font-size: 28px;
            margin-bottom: 20px;
        }

        #commandInput {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            border: 2px solid #fbbf24;
            border-radius: 5px;
            color: #fff;
            margin-bottom: 15px;
        }

        #commandInput:focus {
            outline: none;
            border-color: #f59e0b;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        #commandOutput {
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            font-size: 13px;
            margin-bottom: 15px;
        }

        #commandOutput .cmd-success { color: #4ade80; }
        #commandOutput .cmd-error { color: #ef4444; }
        #commandOutput .cmd-info { color: #60a5fa; }
        #commandOutput .cmd-line { margin: 3px 0; }

        #secretMenu .hint {
            color: #666;
            font-size: 12px;
            margin-bottom: 15px;
        }

        /* Spawn Protection Indicator */
        .spawn-protected {
            animation: spawnShield 0.5s ease-in-out infinite alternate;
        }

        @keyframes spawnShield {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>‚öîÔ∏è DUNGEON CRAWLER ‚öîÔ∏è</h1>
        <div id="gameArea">
            <div id="canvasContainer">
                <canvas id="gameCanvas" width="900" height="550"></canvas>
                <div id="gameControls">
                    <button class="button" id="healButton">üß™<span class="price">50G</span></button>
                    <button class="button" id="fullHealButton">üíñ<span class="price" id="fullHealPrice">--G</span></button>
                    <button class="button" id="attackBoostButton">‚öîÔ∏è<span class="price">75G</span></button>
                    <button class="button" id="defenseBoostButton">üõ°Ô∏è<span class="price">75G</span></button>
                    <button class="button" id="buyBombButton">üí£<span class="price">40G</span></button>
                    <button class="button" id="fullscreenButton">üñ•Ô∏è</button>
                    <button class="button" id="saveButton">üíæ</button>
                    <button class="button" id="loadButton">üìÇ</button>
                    <button class="button" id="highscoreButton">üèÜ</button>
                    <button class="button" id="musicButton">üîá</button>
                    <button class="button" id="sfxButton">üîä</button>
                </div>
                <div id="log"></div>
            </div>
            <div id="sidebar">
                <div class="stat-section">
                    <h3>üë§ CHARAKTER</h3>
                    <div class="stat">
                        <span>Level:</span>
                        <span id="playerLevel">1</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="hpBar">
                            <span id="hpText">100/100</span>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill xp-bar-fill" id="xpBar">
                            <span id="xpText">0/100</span>
                        </div>
                    </div>
                    <div class="stat">
                        <span>‚öîÔ∏è Angriff:</span>
                        <span id="playerAttack">10</span>
                    </div>
                    <div class="stat">
                        <span>üõ°Ô∏è Verteidigung:</span>
                        <span id="playerDefense">5</span>
                    </div>
                    <div class="stat">
                        <span>üí∞ Gold:</span>
                        <span id="playerGold">0</span>
                    </div>
                </div>

                <div class="stat-section">
                    <h3>üéí INVENTAR</h3>
                    <div id="inventory"></div>
                </div>

                <div class="stat-section">
                    <h3>üó∫Ô∏è DUNGEON</h3>
                    <div class="stat">
                        <span>Level:</span>
                        <span id="currentRoom">1</span>
                    </div>
                    <div class="stat">
                        <span>Monster:</span>
                        <span id="monsterCount">0</span>
                    </div>
                </div>

                <div class="stat-section" id="abilitiesSection" style="display: none;">
                    <h3>üí• F√ÑHIGKEITEN</h3>
                    <div id="abilities"></div>
                </div>

                <div id="controls">
                    <h4>‚å®Ô∏è STEUERUNG</h4>
                    <p>WASD / Pfeiltasten: Bewegung</p>
                    <p>Leertaste: Angriff</p>
                    <p>E: Item aufheben</p>
                    <p>Q: Bombe werfen (Lvl 3)</p>
                    <p>1-9: Item benutzen</p>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h2>üíÄ GAME OVER üíÄ</h2>
            <div class="stats">
                <p>Du hast Level <span id="finalLevel"></span> erreicht</p>
                <p>R√§ume erkundet: <span id="roomsCleared"></span></p>
                <p>Monster besiegt: <span id="monstersKilled"></span></p>
                <p>Gold gesammelt: <span id="totalGold"></span></p>
                <p style="color: #fbbf24; font-size: 22px; margin-top: 15px;">Score: <span id="finalScore"></span></p>
            </div>
            <div id="saveScoreSection" style="margin: 15px 0;">
                <input type="text" id="playerNameInput" placeholder="Dein Name..." maxlength="15" style="padding: 8px; width: 150px; background: #1a1a2e; border: 2px solid #fbbf24; border-radius: 5px; color: #fff; text-align: center;">
                <button class="button" onclick="saveHighscore()" style="margin-left: 10px;">üíæ Speichern</button>
            </div>
            <button class="button" onclick="location.reload()">Neues Spiel</button>
        </div>

        <div id="highscoreMenu">
            <h2>üèÜ HIGHSCORES üèÜ</h2>
            <div id="highscoreList"></div>
            <button class="button" onclick="closeHighscoreMenu()">Schlie√üen</button>
        </div>

        <div id="secretMenu" style="display: none;">
            <h2>üîß ENTWICKLER-MEN√ú üîß</h2>
            <div id="secretMenuContent">
                <input type="text" id="commandInput" placeholder="Befehl eingeben..." autocomplete="off">
                <div id="commandOutput"></div>
                <p class="hint">Tippe /help f√ºr alle Befehle</p>
            </div>
            <button class="button" onclick="closeSecretMenu()">Schlie√üen (ESC)</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Easing functions for smoother animations
        const easing = {
            // Smooth deceleration
            easeOutQuad: t => t * (2 - t),
            // Smooth acceleration
            easeInQuad: t => t * t,
            // Smooth acceleration and deceleration
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            // Bouncy effect
            easeOutBack: t => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            },
            // Elastic bounce
            easeOutElastic: t => {
                if (t === 0 || t === 1) return t;
                return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
            },
            // Smooth sine wave
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2
        };

        // Smooth interpolation helper
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Game State
        const game = {
            player: {
                x: 450,  // Center of 900 wide canvas
                y: 275,  // Center of 550 tall canvas
                size: 20,
                hp: 100,
                maxHp: 100,
                attack: 10,
                defense: 5,
                speed: 3,
                level: 1,
                xp: 0,
                xpToNext: 100,
                gold: 0,
                inventory: [],
                equippedWeapon: null,  // Currently equipped weapon
                equippedArmor: null,   // Currently equipped armor
                baseAttack: 10,
                baseDefense: 5,
                attackCooldown: 0,
                animFrame: 0,
                direction: 0,
                // Animation states
                isMoving: false,
                walkFrame: 0,
                flashTimer: 0,
                facingLeft: false,
                facingAngle: 0,
                isAttacking: false,
                attackFrame: 0,
                isShooting: false,
                shootFrame: 0,
                isDrinking: false,
                drinkFrame: 0,
                isDying: false,
                deathFrame: 0,
                levelUpAnim: 0,
                // Abilities
                abilities: {
                    bomb: { cooldown: 0, maxCooldown: 120 }  // Only from items now
                },
                // Spawn protection (5 seconds = 300 frames at 60fps for level 1)
                spawnProtection: 300
            },
            // Secret menu state
            secretMenuOpen: false,
            secretCodeBuffer: '',
            secretCodeUnlocked: false,
            bombs: [],  // Active bombs
            monsters: [],
            dyingMonsters: [],  // For death animations
            items: [],
            projectiles: [],
            particles: [],
            screenShake: 0,     // Screen shake effect
            roomTransition: 0,  // Room transition fade
            currentRoom: 1,
            roomsCleared: 0,
            monstersKilled: 0,
            walls: [],
            doors: [],
            keys: {
                w: false, a: false, s: false, d: false,
                ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
                e: false, x: false
            },
            spacePressed: false,
            animCounter: 0
        };

        // Monster Templates with unique designs and attack types
        // Monster weapon pool (weapons monsters can spawn with)
        const monsterWeapons = {
            goblin: [
                { name: 'Goblin-Dolch', attack: 6, type: 'weapon', style: 'dagger', range: 50, speed: 0.7 },
                { name: 'Rostiger Dolch', attack: 4, type: 'weapon', style: 'dagger', range: 50, speed: 0.8 },
                null  // 33% chance no weapon (uses fists)
            ],
            skeleton: [
                { name: 'Knochenschwert', attack: 8, type: 'weapon', style: 'bone', range: 80 },
                { name: 'Rostiges Schwert', attack: 5, type: 'weapon', style: 'rusty_sword', range: 80 },
                { name: 'Alter Speer', attack: 7, type: 'weapon', style: 'spear', range: 110 }
            ],
            orc: [
                { name: 'Ork-Axt', attack: 14, type: 'weapon', style: 'axe', range: 70, speed: 1.3 },
                { name: 'Kriegshammer', attack: 16, type: 'weapon', style: 'hammer', range: 65, speed: 1.5 },
                { name: 'Grobe Keule', attack: 12, type: 'weapon', style: 'hammer', range: 60, speed: 1.4 }
            ],
            mage: [
                { name: 'Magierstab', attack: 14, type: 'weapon', style: 'staff', range: 100 },
                { name: 'Feuerstab', attack: 18, type: 'weapon', style: 'fire_staff', range: 100 }
            ],
            demon: [
                { name: 'D√§monenklaue', attack: 22, type: 'weapon', style: 'claw', range: 60, speed: 0.8 },
                { name: 'H√∂llenschwert', attack: 20, type: 'weapon', style: 'flame', range: 85 }
            ]
        };

        // Monster armor pool
        const monsterArmors = {
            goblin: [
                null, null,  // 66% chance no armor
                { name: 'Lumpige R√ºstung', defense: 2, type: 'armor', style: 'leather' }
            ],
            skeleton: [
                null,  // 33% chance no armor
                { name: 'Verrostete Kettenr√ºstung', defense: 4, type: 'armor', style: 'chain' },
                { name: 'Knochenr√ºstung', defense: 3, type: 'armor', style: 'leather' }
            ],
            orc: [
                { name: 'Ork-Lederr√ºstung', defense: 5, type: 'armor', style: 'leather' },
                { name: 'Ork-Kettenhemd', defense: 7, type: 'armor', style: 'chain' },
                { name: 'Schwere Ork-R√ºstung', defense: 10, type: 'armor', style: 'plate' }
            ],
            mage: [
                { name: 'Magierrobe', defense: 2, type: 'armor', style: 'leather' },
                null  // 50% chance no armor
            ],
            demon: [
                { name: 'D√§monenhaut', defense: 8, type: 'armor', style: 'dragon' },
                { name: 'H√∂llenpanzer', defense: 12, type: 'armor', style: 'plate' }
            ]
        };

        // Elite Monster weapon pools (bessere Waffen als normale Monster)
        const eliteMonsterWeapons = {
            goblin: [
                { name: 'Elite-Goblinklinge', attack: 18, type: 'weapon', style: 'sword', range: 75, speed: 0.8, tier: 'rare' },
                { name: 'Vergifteter Dolch', attack: 15, type: 'weapon', style: 'dagger', range: 55, speed: 0.6, tier: 'rare' },
                { name: 'Goblin-Assassinenklinge', attack: 22, type: 'weapon', style: 'dagger', range: 60, speed: 0.7, tier: 'epic' }
            ],
            skeleton: [
                { name: 'Verfluchtes Schwert', attack: 20, type: 'weapon', style: 'bone', range: 85, tier: 'rare' },
                { name: 'Seelenschneider', attack: 25, type: 'weapon', style: 'sword', range: 90, tier: 'epic' },
                { name: 'Knochensense', attack: 28, type: 'weapon', style: 'battleaxe', range: 95, speed: 1.3, tier: 'epic' }
            ],
            orc: [
                { name: 'Ork-Kriegsaxt', attack: 30, type: 'weapon', style: 'battleaxe', range: 80, speed: 1.4, tier: 'rare' },
                { name: 'Berserker-Hammer', attack: 35, type: 'weapon', style: 'hammer', range: 75, speed: 1.5, tier: 'epic' },
                { name: 'Blutdurst', attack: 38, type: 'weapon', style: 'battleaxe', range: 85, speed: 1.3, tier: 'legendary' }
            ],
            mage: [
                { name: 'Erzmagier-Stab', attack: 28, type: 'weapon', style: 'staff', range: 110, tier: 'rare' },
                { name: 'Stab der Verdammnis', attack: 32, type: 'weapon', style: 'fire_staff', range: 115, tier: 'epic' },
                { name: 'Seelenstab', attack: 36, type: 'weapon', style: 'staff', range: 120, tier: 'legendary' }
            ],
            demon: [
                { name: 'H√∂llenf√ºrst-Klaue', attack: 35, type: 'weapon', style: 'claw', range: 70, speed: 0.7, tier: 'rare' },
                { name: 'D√§monenschwert', attack: 40, type: 'weapon', style: 'flame', range: 90, tier: 'epic' },
                { name: 'Verderbnis', attack: 45, type: 'weapon', style: 'flame', range: 95, tier: 'legendary' }
            ]
        };

        // Elite Monster armor pools (bessere R√ºstungen)
        const eliteMonsterArmors = {
            goblin: [
                { name: 'Elite-Goblinr√ºstung', defense: 8, type: 'armor', style: 'leather', tier: 'rare' },
                { name: 'Schatten-Leder', defense: 10, type: 'armor', style: 'leather', tier: 'epic' }
            ],
            skeleton: [
                { name: 'Verfluchte R√ºstung', defense: 12, type: 'armor', style: 'chain', tier: 'rare' },
                { name: 'Totenknochen-Panzer', defense: 15, type: 'armor', style: 'plate', tier: 'epic' }
            ],
            orc: [
                { name: 'Ork-Kriegsr√ºstung', defense: 14, type: 'armor', style: 'plate', tier: 'rare' },
                { name: 'Berserker-R√ºstung', defense: 18, type: 'armor', style: 'plate', tier: 'epic' }
            ],
            mage: [
                { name: 'Erzmagier-Robe', defense: 6, type: 'armor', style: 'leather', tier: 'rare' },
                { name: 'Robe der Macht', defense: 8, type: 'armor', style: 'leather', tier: 'epic' }
            ],
            demon: [
                { name: 'D√§monenlord-Panzer', defense: 18, type: 'armor', style: 'dragon', tier: 'rare' },
                { name: 'H√∂llenf√ºrst-R√ºstung', defense: 24, type: 'armor', style: 'plate', tier: 'legendary' }
            ]
        };

        const monsterTypes = [
            {
                name: 'Goblin',
                color: '#4ade80',
                colorDark: '#22c55e',
                hp: 30,
                baseAttack: 4,  // Base attack without weapon
                baseDefense: 1,  // Base defense without armor
                xp: 25,
                gold: 12,
                speed: 1.5,
                attackType: 'melee',
                style: 'goblin'
            },
            {
                name: 'Skeleton',
                color: '#e2e8f0',
                colorDark: '#94a3b8',
                hp: 40,
                baseAttack: 5,
                baseDefense: 1,
                xp: 35,
                gold: 18,
                speed: 1.2,
                attackType: 'melee',
                style: 'skeleton'
            },
            {
                name: 'Orc',
                color: '#4ade80',
                colorDark: '#166534',
                hp: 45,
                baseAttack: 6,
                baseDefense: 2,
                xp: 50,
                gold: 30,
                speed: 1,
                attackType: 'melee',
                style: 'orc'
            },
            {
                name: 'Dark Mage',
                color: '#a78bfa',
                colorDark: '#7c3aed',
                hp: 50,
                baseAttack: 8,
                baseDefense: 1,
                xp: 60,
                gold: 35,
                speed: 0.8,
                attackType: 'ranged',
                projectileColor: '#c084fc',
                projectileSpeed: 4,
                attackRange: 250,
                attackCooldown: 120,
                style: 'mage'
            },
            {
                name: 'Demon',
                color: '#ef4444',
                colorDark: '#b91c1c',
                hp: 80,
                baseAttack: 10,
                baseDefense: 4,
                xp: 100,
                gold: 60,
                speed: 1.3,
                attackType: 'melee',
                style: 'demon'
            },
            // Hybrid Monsters (erscheinen ab Level 15) - k√∂nnen melee und ranged angreifen
            {
                name: 'Hexenmeister',
                color: '#6b21a8',
                colorDark: '#581c87',
                hp: 70,
                baseAttack: 7,
                baseDefense: 2,
                xp: 85,
                gold: 50,
                speed: 1.0,
                attackType: 'hybrid',
                projectileColor: '#a855f7',
                projectileSpeed: 5,
                attackRange: 200,
                attackCooldown: 90,
                meleeRange: 50,
                style: 'mage',
                minLevel: 15
            },
            {
                name: 'Bandit-Hauptmann',
                color: '#78350f',
                colorDark: '#451a03',
                hp: 65,
                baseAttack: 9,
                baseDefense: 3,
                xp: 75,
                gold: 55,
                speed: 1.4,
                attackType: 'hybrid',
                projectileColor: '#a3a3a3',
                projectileSpeed: 7,
                attackRange: 150,
                attackCooldown: 100,
                meleeRange: 60,
                style: 'skeleton',
                minLevel: 15
            },
            {
                name: 'Feuer-Elementar',
                color: '#f97316',
                colorDark: '#ea580c',
                hp: 90,
                baseAttack: 12,
                baseDefense: 5,
                xp: 120,
                gold: 70,
                speed: 1.1,
                attackType: 'hybrid',
                projectileColor: '#ef4444',
                projectileSpeed: 4,
                attackRange: 180,
                attackCooldown: 80,
                meleeRange: 55,
                style: 'demon',
                minLevel: 20
            },
            {
                name: 'Eis-Golem',
                color: '#22d3ee',
                colorDark: '#0891b2',
                hp: 150,
                baseAttack: 14,
                baseDefense: 8,
                xp: 140,
                gold: 80,
                speed: 0.7,
                attackType: 'hybrid',
                projectileColor: '#67e8f9',
                projectileSpeed: 5,
                attackRange: 160,
                attackCooldown: 110,
                meleeRange: 60,
                style: 'orc',
                minLevel: 20
            },
            {
                name: 'Schattenl√§ufer',
                color: '#1e1b4b',
                colorDark: '#0f0d24',
                hp: 55,
                baseAttack: 11,
                baseDefense: 2,
                xp: 100,
                gold: 65,
                speed: 2.0,
                attackType: 'hybrid',
                projectileColor: '#4c1d95',
                projectileSpeed: 8,
                attackRange: 170,
                attackCooldown: 70,
                meleeRange: 45,
                style: 'demon',
                minLevel: 18
            },
            {
                name: 'Drachenwelpe',
                color: '#dc2626',
                colorDark: '#991b1b',
                hp: 120,
                baseAttack: 15,
                baseDefense: 6,
                xp: 160,
                gold: 100,
                speed: 1.2,
                attackType: 'hybrid',
                projectileColor: '#f97316',
                projectileSpeed: 6,
                attackRange: 200,
                attackCooldown: 100,
                meleeRange: 65,
                style: 'demon',
                minLevel: 25
            }
        ];

        // Item Templates
        // tier: 'common' (grau), 'uncommon' (gr√ºn), 'rare' (blau, ab lvl 10), 'legendary' (orange, ab lvl 10)
        const itemTypes = {
            weapons: [
                // Swords - Common/Uncommon
                { name: 'Rostiges Schwert', attack: 5, type: 'weapon', rarity: 0.35, style: 'rusty_sword', range: 80, tier: 'common' },
                { name: 'Eisenschwert', attack: 10, type: 'weapon', rarity: 0.28, style: 'iron_sword', range: 80, tier: 'common' },
                { name: 'Stahlschwert', attack: 15, type: 'weapon', rarity: 0.15, style: 'steel_sword', range: 85, tier: 'uncommon' },
                // Swords - Rare/Legendary (ab Level 10)
                { name: 'Flammschwert', attack: 25, type: 'weapon', rarity: 0.04, style: 'flame', range: 90, tier: 'legendary', minLevel: 10 },
                // Daggers (fast, short range)
                { name: 'Dolch', attack: 4, type: 'weapon', rarity: 0.22, style: 'dagger', range: 50, speed: 0.7, tier: 'common' },
                { name: 'Giftdolch', attack: 8, type: 'weapon', rarity: 0.08, style: 'poison_dagger', range: 50, speed: 0.6, tier: 'uncommon' },
                // Axes (slow, high damage)
                { name: 'Handaxt', attack: 12, type: 'weapon', rarity: 0.12, style: 'axe', range: 70, speed: 1.3, tier: 'common' },
                { name: 'Kriegsaxt', attack: 20, type: 'weapon', rarity: 0.05, style: 'battleaxe', range: 75, speed: 1.5, tier: 'rare', minLevel: 10 },
                // Hammers (very slow, very high damage)
                { name: 'Kriegshammer', attack: 18, type: 'weapon', rarity: 0.06, style: 'hammer', range: 65, speed: 1.6, tier: 'uncommon' },
                // Spears (long range)
                { name: 'Speer', attack: 9, type: 'weapon', rarity: 0.10, style: 'spear', range: 110, tier: 'common' },
                { name: 'Hellebarde', attack: 16, type: 'weapon', rarity: 0.04, style: 'halberd', range: 120, speed: 1.4, tier: 'rare', minLevel: 10 },
                // Magic weapons
                { name: 'Magierstab', attack: 14, type: 'weapon', rarity: 0.05, style: 'staff', range: 100, tier: 'rare', minLevel: 10 },
                { name: 'Feuerstab', attack: 22, type: 'weapon', rarity: 0.03, style: 'fire_staff', range: 100, tier: 'legendary', minLevel: 10 }
            ],
            armor: [
                { name: 'Lederr√ºstung', defense: 2, type: 'armor', rarity: 0.5, style: 'leather' },
                { name: 'Kettenr√ºstung', defense: 4, type: 'armor', rarity: 0.3, style: 'chain' },
                { name: 'Plattenr√ºstung', defense: 6, type: 'armor', rarity: 0.15, style: 'plate' },
                { name: 'Drachenr√ºstung', defense: 10, type: 'armor', rarity: 0.05, style: 'dragon' }
            ],
            potions: [
                { name: 'Kleiner Heiltrank', heal: 30, type: 'potion', rarity: 0.5 },
                { name: 'Heiltrank', heal: 50, type: 'potion', rarity: 0.35 },
                { name: 'Gro√üer Heiltrank', heal: 100, type: 'potion', rarity: 0.15 }
            ],
            bombs: [
                { name: 'Bombe', damage: 40, type: 'bomb', rarity: 0.7 },
                { name: 'Gro√üe Bombe', damage: 80, type: 'bomb', rarity: 0.3 }
            ],
            // Monster-specific drops with drop chances
            monsterDrops: {
                goblin: { chance: 0.3, items: [{ name: 'Goblin-Dolch', attack: 6, type: 'weapon', style: 'dagger', range: 50, speed: 0.7 }] },
                skeleton: { chance: 0.25, items: [{ name: 'Knochenschwert', attack: 8, type: 'weapon', style: 'bone', range: 80 }] },
                orc: { chance: 0.2, items: [{ name: 'Ork-Axt', attack: 14, type: 'weapon', style: 'axe', range: 70, speed: 1.3 }] },
                mage: { chance: 0.1, items: [{ name: 'Magierstab', attack: 14, type: 'weapon', style: 'staff', range: 100 }] },
                demon: { chance: 0.15, items: [{ name: 'D√§monenklaue', attack: 22, type: 'weapon', style: 'claw', range: 60, speed: 0.8 }] }
            }
        };

        // Select item by rarity (respects minLevel requirement)
        function selectByRarity(items, isBossDrop = false) {
            // Filter items based on current room level and boss-only restrictions
            const currentLevel = game.currentRoom || 1;
            let availableItems = items.filter(item => {
                // Level requirement check
                if (item.minLevel && currentLevel < item.minLevel) return false;
                // LEGENDARY items ONLY from bosses!
                if (item.tier === 'legendary' && !isBossDrop) return false;
                return true;
            });

            // If no items available after filtering, use common items
            if (availableItems.length === 0) {
                availableItems = items.filter(item => !item.minLevel && item.tier !== 'legendary');
            }

            // Boss drops have +20% bonus for rare/legendary items
            const roll = Math.random();
            let cumulative = 0;

            // Recalculate rarities for available items
            let totalRarity = availableItems.reduce((sum, item) => sum + (item.rarity || 0.1), 0);

            for (const item of availableItems) {
                let itemRarity = (item.rarity || 0.1) / totalRarity;
                // Boss bonus for rare/legendary
                if (isBossDrop && (item.tier === 'rare' || item.tier === 'legendary')) {
                    itemRarity += 0.20;
                }
                cumulative += itemRarity;
                if (roll < cumulative) return { ...item };
            }
            return { ...availableItems[0] };
        }

        // Level Layouts
        const levelLayouts = {
            1: { // Tutorial Level - Einfach
                walls: [
                    { x: 200, y: 200, width: 200, height: 15 },
                    { x: 200, y: 400, width: 200, height: 15 }
                ]
            },
            2: { // Kreuzung
                walls: [
                    { x: 50, y: 280, width: 200, height: 15 },
                    { x: 350, y: 280, width: 200, height: 15 },
                    { x: 280, y: 50, width: 15, height: 200 },
                    { x: 280, y: 335, width: 15, height: 200 }
                ]
            },
            3: { // Labyrinth
                walls: [
                    { x: 100, y: 100, width: 15, height: 200 },
                    { x: 200, y: 100, width: 15, height: 300 },
                    { x: 300, y: 200, width: 15, height: 300 },
                    { x: 400, y: 100, width: 15, height: 200 },
                    { x: 100, y: 300, width: 200, height: 15 }
                ]
            },
            4: { // Vier R√§ume - adjusted to leave spawn area clear
                walls: [
                    { x: 0, y: 270, width: 220, height: 15 },
                    { x: 380, y: 270, width: 220, height: 15 },
                    { x: 270, y: 0, width: 15, height: 220 },
                    { x: 270, y: 380, width: 15, height: 220 }
                ]
            },
            5: { // Spiral
                walls: [
                    { x: 100, y: 100, width: 400, height: 15 },
                    { x: 100, y: 100, width: 15, height: 400 },
                    { x: 200, y: 200, width: 300, height: 15 },
                    { x: 200, y: 200, width: 15, height: 300 },
                    { x: 300, y: 300, width: 200, height: 15 }
                ]
            },
            6: { // Pillar Arena
                walls: [
                    { x: 150, y: 150, width: 40, height: 40 },
                    { x: 410, y: 150, width: 40, height: 40 },
                    { x: 150, y: 410, width: 40, height: 40 },
                    { x: 410, y: 410, width: 40, height: 40 },
                    { x: 280, y: 280, width: 40, height: 40 }
                ]
            },
            7: { // Enge G√§nge
                walls: [
                    { x: 100, y: 150, width: 15, height: 300 },
                    { x: 200, y: 100, width: 15, height: 350 },
                    { x: 300, y: 150, width: 15, height: 300 },
                    { x: 400, y: 100, width: 15, height: 350 },
                    { x: 500, y: 150, width: 15, height: 300 }
                ]
            },
            8: { // Chaotisches Layout
                walls: [
                    { x: 80, y: 120, width: 120, height: 15 },
                    { x: 250, y: 80, width: 15, height: 150 },
                    { x: 350, y: 200, width: 150, height: 15 },
                    { x: 150, y: 300, width: 15, height: 150 },
                    { x: 400, y: 350, width: 15, height: 120 },
                    { x: 100, y: 450, width: 200, height: 15 }
                ]
            },
            9: { // Vor-Boss Level
                walls: [
                    { x: 100, y: 100, width: 15, height: 150 },
                    { x: 485, y: 100, width: 15, height: 150 },
                    { x: 100, y: 350, width: 15, height: 150 },
                    { x: 485, y: 350, width: 15, height: 150 },
                    { x: 200, y: 200, width: 200, height: 15 },
                    { x: 200, y: 385, width: 200, height: 15 }
                ]
            },
            10: { // BOSS ARENA - Offene Arena mit Eck-S√§ulen
                walls: [
                    // Vier Eck-S√§ulen statt geschlossenem Ring
                    { x: 100, y: 100, width: 40, height: 40 },
                    { x: 760, y: 100, width: 40, height: 40 },
                    { x: 100, y: 410, width: 40, height: 40 },
                    { x: 760, y: 410, width: 40, height: 40 }
                ]
            }
        };

        function generateRoom() {
            game.walls = [];
            game.doors = [];

            // Border walls
            game.walls.push(
                { x: 0, y: 0, width: canvas.width, height: 20 },
                { x: 0, y: 0, width: 20, height: canvas.height },
                { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 },
                { x: canvas.width - 20, y: 0, width: 20, height: canvas.height }
            );

            // Add level-specific walls
            if (game.currentRoom <= 10 && levelLayouts[game.currentRoom]) {
                const layout = levelLayouts[game.currentRoom];
                game.walls.push(...layout.walls);
            } else {
                // Random walls for levels beyond 10
                // Define spawn safe zone (bottom center where player spawns)
                const spawnX = canvas.width / 2;
                const spawnY = canvas.height - 50;
                const safeZoneRadius = 80; // Keep walls away from spawn point

                const numWalls = Math.floor(Math.random() * 5) + 3;
                for (let i = 0; i < numWalls; i++) {
                    let wallX, wallY, wallWidth, wallHeight;
                    let attempts = 0;
                    let validPosition = false;

                    const horizontal = Math.random() > 0.5;

                    // Try to find a valid wall position that doesn't block spawn
                    do {
                        if (horizontal) {
                            wallX = Math.random() * (canvas.width - 200) + 50;
                            wallY = Math.random() * (canvas.height - 200) + 50;
                            wallWidth = Math.random() * 100 + 50;
                            wallHeight = 15;
                        } else {
                            wallX = Math.random() * (canvas.width - 200) + 50;
                            wallY = Math.random() * (canvas.height - 200) + 50;
                            wallWidth = 15;
                            wallHeight = Math.random() * 100 + 50;
                        }

                        // Check if wall overlaps with spawn safe zone
                        const wallCenterX = wallX + wallWidth / 2;
                        const wallCenterY = wallY + wallHeight / 2;
                        const distToSpawn = Math.hypot(wallCenterX - spawnX, wallCenterY - spawnY);

                        // Also check corners of the wall
                        const corner1Dist = Math.hypot(wallX - spawnX, wallY - spawnY);
                        const corner2Dist = Math.hypot(wallX + wallWidth - spawnX, wallY - spawnY);
                        const corner3Dist = Math.hypot(wallX - spawnX, wallY + wallHeight - spawnY);
                        const corner4Dist = Math.hypot(wallX + wallWidth - spawnX, wallY + wallHeight - spawnY);

                        validPosition = distToSpawn > safeZoneRadius &&
                                       corner1Dist > safeZoneRadius &&
                                       corner2Dist > safeZoneRadius &&
                                       corner3Dist > safeZoneRadius &&
                                       corner4Dist > safeZoneRadius;
                        attempts++;
                    } while (!validPosition && attempts < 50);

                    if (validPosition) {
                        game.walls.push({
                            x: wallX,
                            y: wallY,
                            width: wallWidth,
                            height: wallHeight
                        });
                    }
                }
            }

            // Doors (exits) - larger door that player can reach (infinite levels)
            game.doors.push({ x: canvas.width / 2 - 30, y: 0, width: 60, height: 40, active: false });
        }

        // Boss types for different levels
        const bossTypes = [
            // Tier 1: Level 10-50
            { name: 'Dungeon Lord', color: '#9333ea', hp: 300, attack: 30, defense: 10, xp: 500, gold: 200, speed: 0.7,
              meleeBonus: 15, specialAttacks: ['jumpAttack', 'groundSlam'], minionType: 'goblin_elite', style: 'demon' },
            { name: 'Skelett-K√∂nig', color: '#e2e8f0', hp: 400, attack: 40, defense: 15, xp: 800, gold: 350, speed: 0.8,
              meleeBonus: 20, specialAttacks: ['arrowRain', 'boneShield'], minionType: 'skeleton_knight', style: 'skeleton' },
            { name: 'Drachen-F√ºrst', color: '#ef4444', hp: 550, attack: 55, defense: 20, xp: 1200, gold: 500, speed: 0.9,
              meleeBonus: 25, specialAttacks: ['fireBreath', 'wingGust'], minionType: 'orc_berserker', style: 'demon' },
            { name: 'Schatten-Lord', color: '#1a1a2e', hp: 700, attack: 70, defense: 25, xp: 1800, gold: 700, speed: 1.0,
              meleeBonus: 30, specialAttacks: ['shadowDash', 'darkOrbs'], minionType: 'mage_corrupted', style: 'demon' },
            { name: 'Uralt-Titan', color: '#fbbf24', hp: 1000, attack: 90, defense: 35, xp: 2500, gold: 1000, speed: 0.6,
              meleeBonus: 40, specialAttacks: ['earthquake', 'meteorStrike'], minionType: 'demon_spawn', style: 'demon' },
            // Tier 2: Level 60-100
            { name: 'Frost-Hexer', color: '#60a5fa', hp: 850, attack: 75, defense: 20, xp: 3000, gold: 1200, speed: 0.8,
              meleeBonus: 25, specialAttacks: ['iceSpikes', 'frostNova'], minionType: 'frost_elemental', style: 'mage' },
            { name: 'Gift-K√∂nigin', color: '#22c55e', hp: 750, attack: 85, defense: 18, xp: 3500, gold: 1400, speed: 1.1,
              meleeBonus: 35, specialAttacks: ['poisonCloud', 'acidSpit'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Blut-Baron', color: '#dc2626', hp: 900, attack: 95, defense: 28, xp: 4000, gold: 1600, speed: 1.2,
              meleeBonus: 40, specialAttacks: ['bloodDrain', 'batSwarm'], minionType: 'vampire_spawn', style: 'demon' },
            { name: 'Sturm-W√§chter', color: '#fbbf24', hp: 1100, attack: 110, defense: 32, xp: 4500, gold: 1800, speed: 1.3,
              meleeBonus: 45, specialAttacks: ['lightningStrike', 'thunderWave'], minionType: 'storm_elemental', style: 'demon' },
            { name: 'Chaos-Imperator', color: '#a855f7', hp: 1500, attack: 130, defense: 40, xp: 6000, gold: 2500, speed: 1.0,
              meleeBonus: 55, specialAttacks: ['chaosRift', 'voidBlast'], minionType: 'chaos_spawn', style: 'demon' },
            // Tier 3: Level 110-150
            { name: 'Nekromant', color: '#4a044e', hp: 1200, attack: 140, defense: 35, xp: 7000, gold: 3000, speed: 0.9,
              meleeBonus: 50, specialAttacks: ['summonUndead', 'deathWave', 'soulDrain'], minionType: 'skeleton_knight', style: 'mage' },
            { name: 'Lavabiest', color: '#f97316', hp: 1800, attack: 155, defense: 45, xp: 8000, gold: 3500, speed: 0.7,
              meleeBonus: 60, specialAttacks: ['lavaPool', 'fireBreath', 'eruption'], minionType: 'fire_imp', style: 'demon' },
            { name: 'Eisk√∂nig', color: '#0ea5e9', hp: 1600, attack: 145, defense: 50, xp: 8500, gold: 3800, speed: 0.8,
              meleeBonus: 55, specialAttacks: ['blizzard', 'iceSpikes', 'freezeAura'], minionType: 'frost_elemental', style: 'skeleton' },
            { name: 'Seelenfresser', color: '#6b21a8', hp: 1400, attack: 170, defense: 30, xp: 9000, gold: 4000, speed: 1.2,
              meleeBonus: 65, specialAttacks: ['soulDrain', 'terrorScream', 'shadowClones'], minionType: 'wraith', style: 'demon' },
            { name: 'Kriegsherr', color: '#78350f', hp: 2200, attack: 160, defense: 60, xp: 9500, gold: 4200, speed: 0.6,
              meleeBonus: 70, specialAttacks: ['battleCry', 'shieldBash', 'whirlwind'], minionType: 'orc_berserker', style: 'orc' },
            // Tier 4: Level 160-200
            { name: 'Void-Wanderer', color: '#312e81', hp: 1900, attack: 185, defense: 40, xp: 10000, gold: 4500, speed: 1.1,
              meleeBonus: 75, specialAttacks: ['voidBlast', 'dimensionRift', 'darkPulse'], minionType: 'void_spawn', style: 'demon' },
            { name: 'Ph√∂nix-Lord', color: '#fbbf24', hp: 2000, attack: 175, defense: 35, xp: 11000, gold: 5000, speed: 1.3,
              meleeBonus: 70, specialAttacks: ['fireBreath', 'rebirth', 'inferno'], minionType: 'fire_imp', style: 'demon' },
            { name: 'Kristall-Golem', color: '#67e8f9', hp: 3000, attack: 150, defense: 80, xp: 12000, gold: 5500, speed: 0.4,
              meleeBonus: 80, specialAttacks: ['crystalShards', 'reflectShield', 'earthquake'], minionType: 'crystal_shard', style: 'demon' },
            { name: 'Giftdrache', color: '#84cc16', hp: 2400, attack: 195, defense: 45, xp: 13000, gold: 6000, speed: 1.0,
              meleeBonus: 85, specialAttacks: ['poisonCloud', 'acidBreath', 'toxicRain'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Zeitw√§chter', color: '#e0e7ff', hp: 2100, attack: 180, defense: 55, xp: 14000, gold: 6500, speed: 1.4,
              meleeBonus: 75, specialAttacks: ['timeFreeze', 'chronoBlast', 'rewind'], minionType: 'time_phantom', style: 'mage' },
            // Tier 5: Level 210-250
            { name: 'Hydra', color: '#14b8a6', hp: 3500, attack: 200, defense: 50, xp: 15000, gold: 7000, speed: 0.8,
              meleeBonus: 90, specialAttacks: ['multiHead', 'acidSpit', 'regenerate'], minionType: 'poison_spider', style: 'demon' },
            { name: 'Lichk√∂nig', color: '#d4d4d8', hp: 2800, attack: 220, defense: 45, xp: 16000, gold: 7500, speed: 0.9,
              meleeBonus: 95, specialAttacks: ['frostNova', 'summonUndead', 'deathGrip'], minionType: 'death_knight', style: 'skeleton' },
            { name: 'Erz-D√§mon', color: '#b91c1c', hp: 3200, attack: 230, defense: 55, xp: 17000, gold: 8000, speed: 1.1,
              meleeBonus: 100, specialAttacks: ['hellfire', 'demonGate', 'corruption'], minionType: 'demon_lord', style: 'demon' },
            { name: 'Sturmriese', color: '#3b82f6', hp: 4000, attack: 210, defense: 65, xp: 18000, gold: 8500, speed: 0.5,
              meleeBonus: 110, specialAttacks: ['thunderStorm', 'earthquake', 'giantSmash'], minionType: 'storm_elemental', style: 'orc' },
            { name: 'Schattenf√ºrst', color: '#1e1b4b', hp: 2600, attack: 250, defense: 40, xp: 19000, gold: 9000, speed: 1.5,
              meleeBonus: 105, specialAttacks: ['shadowDash', 'darkOrbs', 'nightmare'], minionType: 'shadow_assassin', style: 'demon' },
            // Tier 6: Level 260-300 (Endgame)
            { name: 'Weltenverschlinger', color: '#581c87', hp: 4500, attack: 270, defense: 60, xp: 22000, gold: 10000, speed: 0.9,
              meleeBonus: 120, specialAttacks: ['voidBlast', 'consume', 'dimensionRift'], minionType: 'void_spawn', style: 'demon' },
            { name: 'Uralter Drache', color: '#dc2626', hp: 5000, attack: 280, defense: 70, xp: 25000, gold: 12000, speed: 0.8,
              meleeBonus: 130, specialAttacks: ['fireBreath', 'tailSwipe', 'dragonRoar'], minionType: 'dragon_whelp', style: 'demon' },
            { name: 'G√∂tterbote', color: '#fcd34d', hp: 4200, attack: 300, defense: 55, xp: 28000, gold: 14000, speed: 1.2,
              meleeBonus: 140, specialAttacks: ['holySmite', 'judgement', 'divineWrath'], minionType: 'angel_warrior', style: 'mage' },
            { name: 'Apokalypse', color: '#7c2d12', hp: 5500, attack: 320, defense: 75, xp: 32000, gold: 16000, speed: 1.0,
              meleeBonus: 150, specialAttacks: ['meteorStrike', 'hellfire', 'worldEnder'], minionType: 'demon_lord', style: 'demon' },
            { name: 'Der Ewige', color: '#fafafa', hp: 6666, attack: 350, defense: 80, xp: 40000, gold: 20000, speed: 1.1,
              meleeBonus: 175, specialAttacks: ['timeFreeze', 'cosmicBlast', 'rebirth', 'judgment'], minionType: 'eternal_guardian', style: 'demon' }
        ];

        // Mutierte Monster-Typen (von Bossen gespawnt)
        const mutatedMonsters = {
            goblin_elite: { name: 'Goblin-Elite', color: '#4a5c3a', hp: 60, attack: 12, defense: 5, xp: 40, gold: 25, speed: 2.2, style: 'goblin' },
            skeleton_knight: { name: 'Skelett-Ritter', color: '#d4d4d8', hp: 80, attack: 18, defense: 10, xp: 60, gold: 35, speed: 1.5, style: 'skeleton' },
            orc_berserker: { name: 'Ork-Berserker', color: '#4a7c3a', hp: 100, attack: 22, defense: 8, xp: 80, gold: 45, speed: 1.8, style: 'orc' },
            mage_corrupted: { name: 'Verdorbener Magier', color: '#6b21a8', hp: 70, attack: 25, defense: 4, xp: 90, gold: 55, speed: 1.3, style: 'mage', attackType: 'ranged', attackRange: 200, attackCooldown: 90, projectileColor: '#9333ea', projectileSpeed: 5 },
            demon_spawn: { name: 'D√§monenbrut', color: '#7f1d1d', hp: 120, attack: 28, defense: 12, xp: 100, gold: 65, speed: 2.0, style: 'demon' },
            frost_elemental: { name: 'Frost-Elementar', color: '#93c5fd', hp: 90, attack: 30, defense: 8, xp: 120, gold: 70, speed: 1.4, style: 'mage', attackType: 'ranged', attackRange: 180, attackCooldown: 80, projectileColor: '#60a5fa', projectileSpeed: 5 },
            poison_spider: { name: 'Gift-Spinne', color: '#4ade80', hp: 70, attack: 35, defense: 5, xp: 130, gold: 75, speed: 2.5, style: 'goblin' },
            vampire_spawn: { name: 'Vampir-Brut', color: '#991b1b', hp: 100, attack: 38, defense: 10, xp: 150, gold: 85, speed: 2.0, style: 'demon' },
            storm_elemental: { name: 'Sturm-Elementar', color: '#fcd34d', hp: 110, attack: 42, defense: 12, xp: 170, gold: 95, speed: 1.8, style: 'mage', attackType: 'ranged', attackRange: 220, attackCooldown: 70, projectileColor: '#fbbf24', projectileSpeed: 7 },
            chaos_spawn: { name: 'Chaos-Brut', color: '#c084fc', hp: 140, attack: 50, defense: 15, xp: 200, gold: 120, speed: 2.2, style: 'demon' },
            // New minion types for new bosses
            fire_imp: { name: 'Feuer-Imp', color: '#f97316', hp: 80, attack: 45, defense: 8, xp: 140, gold: 80, speed: 2.3, style: 'goblin', attackType: 'ranged', attackRange: 150, attackCooldown: 100, projectileColor: '#ef4444', projectileSpeed: 6 },
            wraith: { name: 'Geist', color: '#a1a1aa', hp: 60, attack: 55, defense: 3, xp: 160, gold: 90, speed: 2.5, style: 'mage', attackType: 'ranged', attackRange: 200, attackCooldown: 85, projectileColor: '#6b21a8', projectileSpeed: 5 },
            void_spawn: { name: 'Leerenbrut', color: '#312e81', hp: 150, attack: 60, defense: 18, xp: 220, gold: 130, speed: 1.8, style: 'demon' },
            crystal_shard: { name: 'Kristallsplitter', color: '#67e8f9', hp: 200, attack: 40, defense: 35, xp: 180, gold: 100, speed: 1.0, style: 'demon' },
            time_phantom: { name: 'Zeitphantom', color: '#e0e7ff', hp: 90, attack: 65, defense: 10, xp: 200, gold: 110, speed: 2.8, style: 'mage', attackType: 'ranged', attackRange: 250, attackCooldown: 60, projectileColor: '#818cf8', projectileSpeed: 8 },
            death_knight: { name: 'Todesritter', color: '#1f2937', hp: 180, attack: 70, defense: 25, xp: 280, gold: 160, speed: 1.4, style: 'skeleton' },
            demon_lord: { name: 'D√§monenf√ºrst', color: '#7f1d1d', hp: 220, attack: 80, defense: 22, xp: 320, gold: 180, speed: 1.6, style: 'demon' },
            shadow_assassin: { name: 'Schatten-Assassine', color: '#1e1b4b', hp: 100, attack: 90, defense: 8, xp: 300, gold: 170, speed: 3.0, style: 'demon' },
            dragon_whelp: { name: 'Drachenwelpe', color: '#dc2626', hp: 250, attack: 85, defense: 30, xp: 350, gold: 200, speed: 1.5, style: 'demon', attackType: 'ranged', attackRange: 180, attackCooldown: 90, projectileColor: '#f97316', projectileSpeed: 6 },
            angel_warrior: { name: 'Engel-Krieger', color: '#fcd34d', hp: 200, attack: 95, defense: 28, xp: 380, gold: 220, speed: 1.8, style: 'mage' },
            eternal_guardian: { name: 'Ewiger W√§chter', color: '#fafafa', hp: 300, attack: 100, defense: 35, xp: 450, gold: 280, speed: 1.4, style: 'demon' }
        };

        // Elite Monster Templates (ab Level 12) - st√§rker und droppen Elite-Waffen
        const eliteMonsterTypes = [
            { name: 'Elite-Goblin', color: '#2d4a1c', colorDark: '#1a2e10', hp: 80, attack: 20, defense: 8, xp: 100, gold: 60, speed: 2.0, style: 'goblin', isElite: true },
            { name: 'Elite-Skelett', color: '#f5f5f5', colorDark: '#b8b8b8', hp: 100, attack: 25, defense: 12, xp: 120, gold: 75, speed: 1.5, style: 'skeleton', isElite: true },
            { name: 'Elite-Ork', color: '#22c55e', colorDark: '#0f5132', hp: 150, attack: 32, defense: 15, xp: 150, gold: 90, speed: 1.3, style: 'orc', isElite: true },
            { name: 'Elite-Magier', color: '#7c3aed', colorDark: '#4c1d95', hp: 90, attack: 35, defense: 6, xp: 180, gold: 110, speed: 1.2, style: 'mage', isElite: true, attackType: 'ranged', attackRange: 280, attackCooldown: 70, projectileColor: '#a855f7', projectileSpeed: 6 },
            { name: 'Elite-D√§mon', color: '#dc2626', colorDark: '#7f1d1d', hp: 200, attack: 45, defense: 18, xp: 250, gold: 150, speed: 1.5, style: 'demon', isElite: true }
        ];

        // Elite-Waffen Generator - skaliert mit Level
        function generateEliteWeapon(level) {
            const weaponTypes = [
                { baseName: 'Eliteklinge', style: 'sword', baseAttack: 20, range: 85 },
                { baseName: 'Eliteaxt', style: 'battleaxe', baseAttack: 25, range: 75, speed: 1.4 },
                { baseName: 'Elitespeer', style: 'spear', baseAttack: 18, range: 115 },
                { baseName: 'Elitehammer', style: 'hammer', baseAttack: 28, range: 70, speed: 1.5 },
                { baseName: 'Elitestab', style: 'staff', baseAttack: 22, range: 100 }
            ];

            const baseWeapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
            const levelBonus = Math.floor((level - 12) * 2);  // +2 attack pro Level √ºber 12
            const tierSuffix = level >= 20 ? ' III' : level >= 16 ? ' II' : '';

            return {
                name: baseWeapon.baseName + tierSuffix,
                attack: baseWeapon.baseAttack + levelBonus,
                type: 'weapon',
                style: baseWeapon.style,
                range: baseWeapon.range,
                speed: baseWeapon.speed || 1,
                tier: 'rare',
                isEliteWeapon: true
            };
        }

        // Spawn mutated minion from boss
        function spawnBossMinion(boss) {
            const template = mutatedMonsters[boss.minionType];
            if (!template) return;

            // Find valid spawn position near boss
            let x, y, valid;
            let attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const dist = 60 + Math.random() * 40;
                x = boss.x + Math.cos(angle) * dist;
                y = boss.y + Math.sin(angle) * dist;
                valid = x > 50 && x < canvas.width - 50 && y > 50 && y < canvas.height - 50 && !isInWall(x, y, 20);
                attempts++;
            } while (!valid && attempts < 30);

            if (!valid) return;

            const minion = {
                name: template.name,
                color: template.color,
                hp: template.hp,
                maxHp: template.hp,
                attack: template.attack,
                defense: template.defense,
                xp: template.xp,
                gold: template.gold,
                speed: template.speed,
                style: template.style,
                x: x,
                y: y,
                size: 22,
                targetX: x,
                targetY: y,
                aiTimer: 0,
                animFrame: 0,
                flashTimer: 0,
                rangedCooldown: 0,
                spawnedByBoss: boss,
                isMutated: true,
                attackType: template.attackType || 'melee',
                attackRange: template.attackRange || 0,
                attackCooldown: template.attackCooldown || 60,
                projectileColor: template.projectileColor || '#ff0000',
                projectileSpeed: template.projectileSpeed || 4
            };

            game.monsters.push(minion);
            addLog(`‚öîÔ∏è ${boss.name} beschw√∂rt ${template.name}!`, 'combat');

            // Spawn effect particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    color: boss.color,
                    life: 30,
                    size: 4
                });
            }
        }

        // Execute boss special attack
        function executeBossSpecialAttack(boss, attackType) {
            const playerDist = Math.hypot(game.player.x - boss.x, game.player.y - boss.y);

            switch(attackType) {
                case 'jumpAttack':
                    // Dungeon Lord jumps to player location
                    boss.isJumping = true;
                    boss.jumpTarget = { x: game.player.x, y: game.player.y };
                    boss.jumpProgress = 0;
                    boss.jumpStartX = boss.x;
                    boss.jumpStartY = boss.y;
                    addLog(`üí• ${boss.name} springt auf dich zu!`, 'combat');
                    break;

                case 'groundSlam':
                    // Area damage around boss
                    if (playerDist < 150) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.6) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 20;
                        game.screenShake = 20;
                        addLog(`üí• ${boss.name} schl√§gt auf den Boden! ${damage} Schaden!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    // Visual effect
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        game.particles.push({
                            x: boss.x + Math.cos(angle) * 50,
                            y: boss.y + Math.sin(angle) * 50,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            color: '#9333ea',
                            life: 40,
                            size: 6
                        });
                    }
                    break;

                case 'arrowRain':
                    // Skeleton King - Rain of arrows from above
                    addLog(`üèπ ${boss.name} ruft einen Pfeilregen herbei!`, 'combat');
                    for (let i = 0; i < 12; i++) {
                        setTimeout(() => {
                            if (game.player.isDying) return;
                            const targetX = game.player.x + (Math.random() - 0.5) * 150;
                            const targetY = game.player.y + (Math.random() - 0.5) * 150;
                            game.projectiles.push({
                                x: targetX,
                                y: -20,
                                vx: 0,
                                vy: 6,
                                color: '#e2e8f0',
                                damage: Math.floor(boss.attack * 0.4),
                                size: 6,
                                life: 120,
                                fromMonster: true,
                                trail: [],
                                isArrow: true
                            });
                        }, i * 100);
                    }
                    break;

                case 'boneShield':
                    // Skeleton King activates damage reduction
                    boss.shieldActive = true;
                    boss.shieldTimer = 180; // 3 seconds
                    addLog(`üõ°Ô∏è ${boss.name} aktiviert Knochenschild!`, 'combat');
                    break;

                case 'fireBreath':
                    // Dragon - Cone of fire projectiles
                    addLog(`üî• ${boss.name} spuckt Feuer!`, 'combat');
                    const angleToPlayer = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                    for (let i = -2; i <= 2; i++) {
                        const spreadAngle = angleToPlayer + (i * 0.2);
                        game.projectiles.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(spreadAngle) * 5,
                            vy: Math.sin(spreadAngle) * 5,
                            color: '#ff6600',
                            damage: Math.floor(boss.attack * 0.5),
                            size: 12,
                            life: 90,
                            fromMonster: true,
                            trail: []
                        });
                    }
                    break;

                case 'wingGust':
                    // Dragon pushes player away
                    if (playerDist < 200) {
                        const pushAngle = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                        const pushDist = 100;
                        let newX = game.player.x + Math.cos(pushAngle) * pushDist;
                        let newY = game.player.y + Math.sin(pushAngle) * pushDist;
                        // Clamp to bounds
                        newX = Math.max(30, Math.min(canvas.width - 30, newX));
                        newY = Math.max(30, Math.min(canvas.height - 30, newY));
                        if (!isInWall(newX, newY, 20)) {
                            game.player.x = newX;
                            game.player.y = newY;
                        }
                        addLog(`üí® ${boss.name} bl√§st dich zur√ºck!`, 'combat');
                    }
                    break;

                case 'shadowDash':
                    // Shadow Lord dashes through player
                    const dashAngle = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
                    const dashDist = 200;
                    let dashX = boss.x + Math.cos(dashAngle) * dashDist;
                    let dashY = boss.y + Math.sin(dashAngle) * dashDist;
                    dashX = Math.max(50, Math.min(canvas.width - 50, dashX));
                    dashY = Math.max(50, Math.min(canvas.height - 50, dashY));
                    // Create trail particles
                    for (let i = 0; i < 15; i++) {
                        const t = i / 15;
                        game.particles.push({
                            x: boss.x + (dashX - boss.x) * t,
                            y: boss.y + (dashY - boss.y) * t,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#1a1a2e',
                            life: 40,
                            size: 8
                        });
                    }
                    boss.x = dashX;
                    boss.y = dashY;
                    // Damage if player was in path
                    if (playerDist < dashDist) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.7) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 15;
                        addLog(`üåë ${boss.name} durchbohrt dich! ${damage} Schaden!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    break;

                case 'darkOrbs':
                    // Shadow Lord fires homing orbs
                    addLog(`üîÆ ${boss.name} beschw√∂rt Schattenkugeln!`, 'combat');
                    for (let i = 0; i < 4; i++) {
                        const orbAngle = (i / 4) * Math.PI * 2;
                        game.projectiles.push({
                            x: boss.x + Math.cos(orbAngle) * 30,
                            y: boss.y + Math.sin(orbAngle) * 30,
                            vx: Math.cos(orbAngle) * 2,
                            vy: Math.sin(orbAngle) * 2,
                            color: '#6b21a8',
                            damage: Math.floor(boss.attack * 0.35),
                            size: 10,
                            life: 180,
                            fromMonster: true,
                            trail: [],
                            isHoming: true,
                            homingStrength: 0.03
                        });
                    }
                    break;

                case 'earthquake':
                    // Titan shakes the ground
                    game.screenShake = 30;
                    addLog(`üåã ${boss.name} ersch√ºttert die Erde!`, 'combat');
                    // Damage all in range and create obstacles
                    if (playerDist < 250) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, Math.floor(boss.attack * 0.5) - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 20;
                        addLog(`Du nimmst ${damage} Schaden vom Erdbeben!`, 'combat');
                        if (game.player.hp <= 0) startPlayerDeath();
                    }
                    // Ground crack particles
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * 150;
                        game.particles.push({
                            x: boss.x + Math.cos(angle) * dist,
                            y: boss.y + Math.sin(angle) * dist,
                            vx: 0,
                            vy: -2 - Math.random() * 3,
                            color: '#92400e',
                            life: 50,
                            size: 5 + Math.random() * 5
                        });
                    }
                    break;

                case 'meteorStrike':
                    // Titan calls meteors
                    addLog(`‚òÑÔ∏è ${boss.name} ruft Meteore herbei!`, 'combat');
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (game.player.isDying) return;
                            const targetX = Math.random() * (canvas.width - 100) + 50;
                            const targetY = Math.random() * (canvas.height - 100) + 50;
                            // Warning indicator
                            game.particles.push({
                                x: targetX,
                                y: targetY,
                                vx: 0,
                                vy: 0,
                                color: '#fbbf24',
                                life: 60,
                                size: 30,
                                isMeteorWarning: true
                            });
                            // Actual meteor
                            setTimeout(() => {
                                if (game.player.isDying) return;
                                const distToTarget = Math.hypot(game.player.x - targetX, game.player.y - targetY);
                                if (distToTarget < 50) {
                                    const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                                    const damage = Math.max(1, Math.floor(boss.attack * 0.8) - totalDef);
                                    game.player.hp = Math.max(0, game.player.hp - damage);
                                    game.player.flashTimer = 20;
                                    game.screenShake = 15;
                                    addLog(`‚òÑÔ∏è Meteor trifft dich! ${damage} Schaden!`, 'combat');
                                    if (game.player.hp <= 0) startPlayerDeath();
                                }
                                // Impact particles
                                for (let j = 0; j < 15; j++) {
                                    const pAngle = Math.random() * Math.PI * 2;
                                    game.particles.push({
                                        x: targetX,
                                        y: targetY,
                                        vx: Math.cos(pAngle) * 4,
                                        vy: Math.sin(pAngle) * 4,
                                        color: '#f97316',
                                        life: 30,
                                        size: 6
                                    });
                                }
                            }, 1000);
                        }, i * 400);
                    }
                    break;
            }
        }

        function spawnMonsters() {
            game.monsters = [];

            // BOSS FIGHT every 10 levels
            if (game.currentRoom % 10 === 0) {
                const bossIndex = Math.min(Math.floor(game.currentRoom / 10) - 1, bossTypes.length - 1);
                const bossTemplate = bossTypes[bossIndex];
                // Scale boss with level progression
                const levelMultiplier = 1 + (game.currentRoom - 10) * 0.1;

                // Find valid spawn position for boss (not in wall, far from player)
                let bossX, bossY, validPos;
                let attempts = 0;
                do {
                    bossX = canvas.width / 2 + (Math.random() - 0.5) * 200;
                    bossY = canvas.height / 2 + (Math.random() - 0.5) * 150;
                    validPos = !isInWall(bossX, bossY, 40) && Math.hypot(bossX - game.player.x, bossY - game.player.y) > 150;
                    attempts++;
                } while (!validPos && attempts < 100);

                const boss = {
                    name: bossTemplate.name,
                    color: bossTemplate.color,
                    hp: Math.floor(bossTemplate.hp * levelMultiplier),
                    maxHp: Math.floor(bossTemplate.hp * levelMultiplier),
                    attack: Math.floor(bossTemplate.attack * levelMultiplier),
                    defense: Math.floor(bossTemplate.defense * levelMultiplier),
                    xp: Math.floor(bossTemplate.xp * levelMultiplier),
                    gold: Math.floor(bossTemplate.gold * levelMultiplier),
                    speed: bossTemplate.speed,
                    x: bossX,
                    y: bossY,
                    size: 35 + bossIndex * 3,
                    targetX: bossX,
                    targetY: bossY,
                    aiTimer: 0,
                    animFrame: 0,
                    flashTimer: 0,
                    meleeCooldown: 0,
                    isBoss: true,
                    bossType: bossIndex,
                    attackType: 'melee',
                    style: bossTemplate.style,
                    // Boss special abilities
                    meleeBonus: bossTemplate.meleeBonus || 0,
                    specialAttacks: bossTemplate.specialAttacks || [],
                    minionType: bossTemplate.minionType,
                    specialCooldown: 0,
                    minionCooldown: 0,
                    minionCount: 0,
                    isJumping: false,
                    jumpTarget: null,
                    shieldActive: false,
                    shieldTimer: 0
                };
                game.monsters.push(boss);
                addLog(`üî• BOSS ERSCHIENEN: ${boss.name}! üî•`, 'combat');
            } else {
                // Normal levels
                const numMonsters = Math.min(game.currentRoom + 1, 8);

                // Ab Level 12: Elite-Monster erscheinen
                const eliteChance = game.currentRoom >= 12 ? Math.min(0.15 + (game.currentRoom - 12) * 0.03, 0.5) : 0;
                const levelScale = game.currentRoom >= 12 ? 1 + (game.currentRoom - 12) * 0.08 : 1;

                for (let i = 0; i < numMonsters; i++) {
                    let template;
                    let isElite = false;

                    // Pr√ºfe ob Elite-Monster spawnen soll
                    if (game.currentRoom >= 12 && Math.random() < eliteChance) {
                        // Elite Monster ausw√§hlen
                        const eliteLevel = Math.min(Math.floor((game.currentRoom - 12) / 3), eliteMonsterTypes.length - 1);
                        template = eliteMonsterTypes[Math.min(eliteLevel + Math.floor(Math.random() * 2), eliteMonsterTypes.length - 1)];
                        isElite = true;
                    } else {
                        // Normales Monster - filter by minLevel
                        const availableMonsters = monsterTypes.filter(m => !m.minLevel || m.minLevel <= game.currentRoom);
                        const level = Math.min(Math.floor(game.currentRoom / 2), availableMonsters.length - 1);
                        template = availableMonsters[Math.min(level + Math.floor(Math.random() * 2), availableMonsters.length - 1)];
                    }

                    let x, y, valid;
                    let attempts = 0;
                    do {
                        x = Math.random() * (canvas.width - 100) + 50;
                        y = Math.random() * (canvas.height - 100) + 50;
                        // Check distance from player AND not in wall
                        valid = Math.hypot(x - game.player.x, y - game.player.y) > 150 && !isInWall(x, y, 25);
                        attempts++;
                    } while (!valid && attempts < 100);

                    // Select random weapon and armor for monster (elite monsters get better gear)
                    const weaponPool = isElite
                        ? (eliteMonsterWeapons[template.style] || monsterWeapons[template.style] || [null])
                        : (monsterWeapons[template.style] || [null]);
                    const armorPool = isElite
                        ? (eliteMonsterArmors[template.style] || monsterArmors[template.style] || [null])
                        : (monsterArmors[template.style] || [null]);
                    const equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                    const equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];

                    // Calculate total attack and defense
                    const baseAtk = template.baseAttack || template.attack || 5;
                    const baseDef = template.baseDefense || template.defense || 1;
                    const weaponAtk = equippedWeapon ? equippedWeapon.attack : 0;
                    const armorDef = equippedArmor ? equippedArmor.defense : 0;
                    const totalAttack = baseAtk + weaponAtk;
                    const totalDefense = baseDef + armorDef;

                    const monster = {
                        ...template,
                        x, y,
                        size: template.style === 'orc' ? 22 : (template.style === 'goblin' ? 14 : (isElite ? 24 : 18)),
                        hp: isElite ? Math.floor(template.hp * levelScale) : template.hp,
                        maxHp: isElite ? Math.floor(template.hp * levelScale) : template.hp,
                        attack: isElite ? Math.floor(totalAttack * levelScale) : totalAttack,
                        defense: isElite ? Math.floor(totalDefense * levelScale) : totalDefense,
                        equippedWeapon: equippedWeapon ? { ...equippedWeapon } : null,
                        equippedArmor: equippedArmor ? { ...equippedArmor } : null,
                        weaponRange: equippedWeapon ? (equippedWeapon.range || 60) : 40,
                        targetX: x,
                        targetY: y,
                        aiTimer: 0,
                        animFrame: 0,
                        attackFrame: 0,
                        flashTimer: 0,
                        rangedCooldown: 0,
                        meleeCooldown: 0,
                        isElite: isElite
                    };

                    game.monsters.push(monster);

                    if (isElite) {
                        addLog(`‚öîÔ∏è ${monster.name} erscheint!`, 'combat');
                    }
                }
            }
            updateMonsterCount();
        }

        function spawnItems() {
            game.items = [];
            const numItems = Math.floor(Math.random() * 3) + 1;

            // Level 1: Always spawn at least one weapon first
            if (game.currentRoom === 1) {
                const starterWeapons = itemTypes.weapons.filter(w => w.tier === 'common');
                const weapon = { ...starterWeapons[Math.floor(Math.random() * starterWeapons.length)] };
                let x, y, valid, attempts = 0;
                do {
                    x = Math.random() * (canvas.width - 100) + 50;
                    y = Math.random() * (canvas.height - 100) + 50;
                    valid = !isInWall(x, y, 15);
                    attempts++;
                } while (!valid && attempts < 50);
                weapon.x = x;
                weapon.y = y;
                weapon.size = 12;
                weapon.animOffset = Math.random() * Math.PI * 2;
                game.items.push(weapon);
            }

            for (let i = 0; i < numItems; i++) {
                const roll = Math.random();
                let item;

                if (roll < 0.45) {
                    item = selectByRarity(itemTypes.potions);
                } else if (roll < 0.70) {
                    item = selectByRarity(itemTypes.weapons);
                } else if (roll < 0.85) {
                    item = selectByRarity(itemTypes.armor);
                } else {
                    // 15% chance for bombs
                    item = selectByRarity(itemTypes.bombs);
                }

                // Find valid spawn position (not in wall)
                let x, y, valid;
                let attempts = 0;
                do {
                    x = Math.random() * (canvas.width - 100) + 50;
                    y = Math.random() * (canvas.height - 100) + 50;
                    valid = !isInWall(x, y, 15);
                    attempts++;
                } while (!valid && attempts < 50);

                item.x = x;
                item.y = y;
                item.size = 12;
                item.animOffset = Math.random() * Math.PI * 2;

                game.items.push(item);
            }
        }

        // Check if position is inside a wall
        function isInWall(x, y, padding = 20) {
            for (const wall of game.walls) {
                if (x > wall.x - padding && x < wall.x + wall.width + padding &&
                    y > wall.y - padding && y < wall.y + wall.height + padding) {
                    return true;
                }
            }
            return false;
        }

        // Drop item from monster with animation
        // Monsters now drop what they have equipped or potions
        function dropMonsterLoot(monster) {
            const isBoss = monster.isBoss || false;
            const isElite = monster.isElite || false;
            let item = null;

            // Drop chances based on monster type (increased)
            const dropChance = isBoss ? 1.0 : (isElite ? 0.85 : 0.50);

            if (Math.random() > dropChance) return; // No drop

            // 5% chance to drop nothing (except bosses)
            if (!isBoss && Math.random() < 0.05) return;

            // Determine what to drop: equipped weapon, equipped armor, or potion
            const hasWeapon = monster.equippedWeapon;
            const hasArmor = monster.equippedArmor;

            if (isBoss) {
                // Bosses always drop their weapon with high tier (30% legendary, 70% rare)
                const isLegendary = Math.random() < 0.30;
                const tier = isLegendary ? 'legendary' : 'rare';

                // Last 6 bosses (bossType >= 4) have 25% chance to drop Feuerstab
                const bossIndex = monster.bossType || 0;
                if (bossIndex >= 4 && Math.random() < 0.25) {
                    item = {
                        name: 'Feuerstab',
                        attack: 22 + Math.floor(bossIndex * 3),  // Scales with boss level
                        type: 'weapon',
                        style: 'fire_staff',
                        range: 100,
                        tier: 'legendary'
                    };
                } else if (hasWeapon) {
                    item = { ...monster.equippedWeapon, tier: tier };
                    // Boost stats for boss drops
                    item.attack = Math.floor(item.attack * (isLegendary ? 1.5 : 1.2));
                } else {
                    item = selectByRarity(itemTypes.weapons, true);
                    item.tier = tier;
                }
                const dropEmoji = item.style === 'fire_staff' ? 'üî•' : (isLegendary ? 'üåü' : 'üëë');
                addLog(`${dropEmoji} ${monster.name} droppt ${item.name}! (${item.tier})`, 'loot');
            } else if (isElite) {
                // Elite monsters drop elite weapons
                item = generateEliteWeapon(game.currentRoom);
                addLog(`‚ú® ${monster.name} droppt ${item.name}!`, 'loot');
            } else {
                // Normal monsters: 40% weapon, 25% armor, 35% potion
                const roll = Math.random();
                if (roll < 0.40 && hasWeapon) {
                    item = { ...monster.equippedWeapon };
                } else if (roll < 0.65 && hasArmor) {
                    item = { ...monster.equippedArmor };
                } else {
                    // Drop a potion
                    item = selectByRarity(itemTypes.potions, false);
                }
            }

            if (!item) return;

            // Find valid spawn position (not in wall)
            let itemX = monster.x;
            let itemY = monster.y;

            // If monster position is in a wall, find nearby valid position
            if (isInWall(itemX, itemY, 15)) {
                let found = false;
                // Try positions in expanding circle
                for (let radius = 20; radius <= 100 && !found; radius += 20) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const testX = monster.x + Math.cos(angle) * radius;
                        const testY = monster.y + Math.sin(angle) * radius;
                        if (!isInWall(testX, testY, 15) &&
                            testX > 50 && testX < canvas.width - 50 &&
                            testY > 50 && testY < canvas.height - 50) {
                            itemX = testX;
                            itemY = testY;
                            found = true;
                            break;
                        }
                    }
                }
            }

            // Spawn with drop animation
            item.x = itemX;
            item.y = itemY;
            item.size = 12;
            item.animOffset = Math.random() * Math.PI * 2;
            item.dropAnim = 20;  // Drop animation frames
            item.dropVy = -4;    // Initial upward velocity

            game.items.push(item);
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.size > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.size > rect2.y;
        }

        function movePlayer() {
            if (game.player.isDying) return;  // Can't move while dying

            const oldX = game.player.x;
            const oldY = game.player.y;

            // Movement keys
            const moveUp = game.keys.w || game.keys.ArrowUp;
            const moveDown = game.keys.s || game.keys.ArrowDown;
            const moveLeft = game.keys.a || game.keys.ArrowLeft;
            const moveRight = game.keys.d || game.keys.ArrowRight;
            const speed = game.player.speed;

            if (moveUp) game.player.y -= speed;
            if (moveDown) game.player.y += speed;
            if (moveLeft) {
                game.player.x -= speed;
                game.player.facingLeft = true;
            }
            if (moveRight) {
                game.player.x += speed;
                game.player.facingLeft = false;
            }

            // Track if player is moving for walk animation
            game.player.isMoving = (game.player.x !== oldX || game.player.y !== oldY);
            if (game.player.isMoving) {
                game.player.walkFrame += 0.3;
            }

            // Wall collision (player sprite is taller)
            for (const wall of game.walls) {
                const playerLeft = game.player.x - 10;
                const playerRight = game.player.x + 10;
                const playerTop = game.player.y - 12;
                const playerBottom = game.player.y + 25;

                if (playerLeft < wall.x + wall.width &&
                    playerRight > wall.x &&
                    playerTop < wall.y + wall.height &&
                    playerBottom > wall.y) {
                    game.player.x = oldX;
                    game.player.y = oldY;
                    break;
                }
            }

            // Door collision (only if room cleared)
            for (const door of game.doors) {
                if (door.active) {
                    // Simple distance check - if player is near top center
                    const doorCenterX = door.x + door.width / 2;
                    const doorCenterY = door.y + door.height / 2;
                    const distX = Math.abs(game.player.x - doorCenterX);
                    const distY = Math.abs(game.player.y - doorCenterY);

                    if (distX < 40 && distY < 50) {
                        nextRoom();
                        return;
                    }
                }
            }

            // Keep in bounds (allow player to reach door at top)
            game.player.x = Math.max(30, Math.min(canvas.width - 30, game.player.x));
            game.player.y = Math.max(35, Math.min(canvas.height - 30, game.player.y));
        }

        function updateMonsters() {
            for (let i = game.monsters.length - 1; i >= 0; i--) {
                const monster = game.monsters[i];

                monster.animFrame += 0.1;
                if (monster.flashTimer > 0) monster.flashTimer--;

                // AI behavior
                monster.aiTimer++;
                if (monster.aiTimer > 60) {
                    monster.aiTimer = 0;
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                    if (dist < 200) {
                        // Chase player
                        monster.targetX = game.player.x;
                        monster.targetY = game.player.y;
                    } else {
                        // Wander
                        monster.targetX = Math.random() * canvas.width;
                        monster.targetY = Math.random() * canvas.height;
                    }
                }

                // Boss Jump Attack animation
                if (monster.isBoss && monster.isJumping && monster.jumpTarget) {
                    monster.jumpProgress += 0.05;
                    const t = monster.jumpProgress;
                    // Parabolic arc
                    const arcHeight = 100;
                    monster.x = monster.jumpStartX + (monster.jumpTarget.x - monster.jumpStartX) * t;
                    monster.y = monster.jumpStartY + (monster.jumpTarget.y - monster.jumpStartY) * t - Math.sin(t * Math.PI) * arcHeight;

                    // Trail particles
                    if (Math.random() < 0.5) {
                        game.particles.push({
                            x: monster.x,
                            y: monster.y + monster.size/2,
                            vx: (Math.random() - 0.5) * 2,
                            vy: 1,
                            color: monster.color,
                            life: 20,
                            size: 4
                        });
                    }

                    // Land and deal damage
                    if (monster.jumpProgress >= 1) {
                        monster.isJumping = false;
                        monster.jumpTarget = null;
                        game.screenShake = 20;
                        // Impact damage
                        const landDist = Math.hypot(game.player.x - monster.x, game.player.y - monster.y);
                        if (landDist < 60 && !game.player.isDying && game.player.spawnProtection <= 0) {
                            const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                            const damage = Math.max(1, Math.floor(monster.attack * 0.8) - totalDef);
                            game.player.hp = Math.max(0, game.player.hp - damage);
                            game.player.flashTimer = 20;
                            addLog(`üí• ${monster.name} landet auf dir! ${damage} Schaden!`, 'combat');
                            if (game.player.hp <= 0) startPlayerDeath();
                        }
                        // Impact particles
                        for (let p = 0; p < 20; p++) {
                            const angle = (p / 20) * Math.PI * 2;
                            game.particles.push({
                                x: monster.x + Math.cos(angle) * 30,
                                y: monster.y + Math.sin(angle) * 30,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                color: '#92400e',
                                life: 30,
                                size: 5
                            });
                        }
                    }
                    continue; // Skip normal movement while jumping
                }

                // Move towards target
                const dx = monster.targetX - monster.x;
                const dy = monster.targetY - monster.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    const oldX = monster.x;
                    const oldY = monster.y;

                    monster.x += (dx / dist) * monster.speed;
                    monster.y += (dy / dist) * monster.speed;

                    // Wall collision for monsters
                    for (const wall of game.walls) {
                        const monsterLeft = monster.x - monster.size/2;
                        const monsterRight = monster.x + monster.size/2;
                        const monsterTop = monster.y - monster.size/2;
                        const monsterBottom = monster.y + monster.size/2;

                        if (monsterLeft < wall.x + wall.width &&
                            monsterRight > wall.x &&
                            monsterTop < wall.y + wall.height &&
                            monsterBottom > wall.y) {
                            monster.x = oldX;
                            monster.y = oldY;
                            // Change direction when hitting wall
                            monster.targetX = Math.random() * canvas.width;
                            monster.targetY = Math.random() * canvas.height;
                            break;
                        }
                    }
                }

                // Ranged attack for ranged and hybrid monsters
                if (monster.attackType === 'ranged' || monster.attackType === 'hybrid') {
                    monster.rangedCooldown = Math.max(0, monster.rangedCooldown - 1);
                    const distToPlayer = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                    // Hybrid monsters only use ranged if beyond melee range
                    const useRanged = monster.attackType === 'ranged' ||
                        (monster.attackType === 'hybrid' && distToPlayer > (monster.meleeRange || 60));

                    // Check line of sight before ranged attack
                    if (useRanged && distToPlayer < monster.attackRange && monster.rangedCooldown <= 0 && hasLineOfSight(monster.x, monster.y, game.player.x, game.player.y)) {
                        // Fire projectile
                        const angle = Math.atan2(game.player.y - monster.y, game.player.x - monster.x);
                        game.projectiles.push({
                            x: monster.x,
                            y: monster.y,
                            vx: Math.cos(angle) * monster.projectileSpeed,
                            vy: Math.sin(angle) * monster.projectileSpeed,
                            color: monster.projectileColor,
                            damage: monster.attack,
                            size: 8,
                            life: 180,
                            fromMonster: true,
                            trail: []
                        });
                        monster.rangedCooldown = monster.attackCooldown;
                        monster.isAttacking = true;
                        monster.attackFrame = 0;
                    }
                }

                // Boss Special Abilities
                if (monster.isBoss && !game.player.isDying) {
                    monster.specialCooldown = Math.max(0, monster.specialCooldown - 1);
                    monster.minionCooldown = Math.max(0, monster.minionCooldown - 1);

                    // Shield timer countdown
                    if (monster.shieldActive) {
                        monster.shieldTimer--;
                        if (monster.shieldTimer <= 0) {
                            monster.shieldActive = false;
                        }
                    }

                    // Special Attack (every 5-8 seconds)
                    if (monster.specialCooldown <= 0 && monster.specialAttacks.length > 0) {
                        const attack = monster.specialAttacks[Math.floor(Math.random() * monster.specialAttacks.length)];
                        executeBossSpecialAttack(monster, attack);
                        monster.specialCooldown = 300 + Math.random() * 180; // 5-8 seconds
                    }

                    // Spawn Minions (max 3, every 10-15 seconds)
                    const currentMinions = game.monsters.filter(m => m.spawnedByBoss === monster).length;
                    if (monster.minionCooldown <= 0 && currentMinions < 3 && monster.minionType) {
                        spawnBossMinion(monster);
                        monster.minionCooldown = 600 + Math.random() * 300; // 10-15 seconds
                    }
                }

                // Melee attack based on weapon range (only if player not dying and not spawn protected)
                const meleeRange = monster.weaponRange || 30;
                const distToPlayer = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);

                // Decrement melee cooldown
                monster.meleeCooldown = Math.max(0, (monster.meleeCooldown || 0) - 1);

                // For hybrid monsters, use their meleeRange; otherwise use weaponRange
                const effectiveMeleeRange = monster.attackType === 'hybrid' ? (monster.meleeRange || 60) : meleeRange;

                // Check line of sight before melee attack (no attacking through walls)
                // Hybrid and melee monsters can melee attack
                if (!game.player.isDying && game.player.spawnProtection <= 0 && monster.attackType !== 'ranged' && distToPlayer < effectiveMeleeRange && monster.meleeCooldown <= 0 && hasLineOfSight(monster.x, monster.y, game.player.x, game.player.y)) {
                    // Boss melee bonus damage
                    const meleeBonus = monster.isBoss ? (monster.meleeBonus || 0) : 0;
                    const totalDefense = game.player.defense + (game.player.defenseBoost || 0);
                    const damage = Math.max(1, monster.attack + meleeBonus - totalDefense);
                    game.player.hp = Math.max(0, game.player.hp - damage);
                    game.player.flashTimer = 15;  // Player damage flash
                    game.screenShake = monster.isBoss ? 15 : 10;  // Stronger shake for boss
                    monster.isAttacking = true;   // Monster attack animation
                    monster.attackFrame = 0;
                    sfx.playerHit();  // Player damage sound
                    addLog(`${monster.name} trifft dich f√ºr ${damage} Schaden!`, 'combat');
                    createParticles(game.player.x, game.player.y, '#ef4444');

                    // Set cooldown (60 frames = 1 second, bosses attack faster)
                    monster.meleeCooldown = monster.isBoss ? 45 : 60;

                    if (game.player.hp <= 0) {
                        startPlayerDeath();
                    }
                }

                // Update monster attack animation
                if (monster.isAttacking) {
                    monster.attackFrame += 0.4;
                    if (monster.attackFrame > 15) {
                        monster.isAttacking = false;
                    }
                }
            }
        }

        // Update projectiles
        function updateProjectiles() {
            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const proj = game.projectiles[i];

                // Store trail position
                proj.trail.push({ x: proj.x, y: proj.y });
                if (proj.trail.length > 8) proj.trail.shift();

                // Homing projectile logic
                if (proj.isHoming && proj.fromMonster) {
                    const angleToPlayer = Math.atan2(game.player.y - proj.y, game.player.x - proj.x);
                    const currentAngle = Math.atan2(proj.vy, proj.vx);
                    let angleDiff = angleToPlayer - currentAngle;
                    // Normalize angle
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const newAngle = currentAngle + angleDiff * (proj.homingStrength || 0.05);
                    const speed = Math.hypot(proj.vx, proj.vy);
                    proj.vx = Math.cos(newAngle) * speed;
                    proj.vy = Math.sin(newAngle) * speed;
                }

                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;

                // Check collision with player (monster projectiles) - only if not dying and not spawn protected
                if (proj.fromMonster && !game.player.isDying && game.player.spawnProtection <= 0) {
                    const distToPlayer = Math.hypot(proj.x - game.player.x, proj.y - game.player.y);
                    if (distToPlayer < 20) {
                        const totalDef = game.player.defense + (game.player.defenseBoost || 0);
                        const damage = Math.max(1, proj.damage - totalDef);
                        game.player.hp = Math.max(0, game.player.hp - damage);
                        game.player.flashTimer = 15;
                        game.screenShake = 8;
                        sfx.playerHit();  // Player damage sound
                        addLog(`Magischer Angriff trifft! -${damage} HP`, 'combat');
                        createParticles(game.player.x, game.player.y, proj.color);

                        if (game.player.hp <= 0) {
                            startPlayerDeath();
                        }

                        game.projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with monsters (player projectiles)
                if (proj.fromPlayer) {
                    for (let m = game.monsters.length - 1; m >= 0; m--) {
                        const monster = game.monsters[m];
                        const distToMonster = Math.hypot(proj.x - monster.x, proj.y - monster.y);
                        if (distToMonster < monster.size + 5) {
                            let damage = Math.max(1, proj.damage - monster.defense);
                            // Boss shield reduces damage
                            if (monster.isBoss && monster.shieldActive) {
                                damage = Math.max(1, Math.floor(damage * 0.5));
                            }
                            monster.hp -= damage;
                            monster.flashTimer = 10;
                            sfx.monsterHit(monster.style, monster.isBoss);  // Monster hit sound
                            addLog(`Magischer Schuss trifft ${monster.name} f√ºr ${damage} Schaden!`, 'combat');
                            createParticles(monster.x, monster.y, monster.shieldActive ? '#60a5fa' : proj.color);

                            if (monster.hp <= 0) {
                                sfx.monsterDeath(monster.style, monster.isBoss);  // Monster death sound
                                addLog(`${monster.name} besiegt! +${monster.xp} XP, +${monster.gold} Gold`, 'loot');
                                game.player.xp += monster.xp;
                                game.player.gold += monster.gold;
                                game.monstersKilled++;
                                dropMonsterLoot(monster);

                                game.monsters.splice(m, 1);
                                monster.deathFrame = 0;
                                monster.isDying = true;
                                game.dyingMonsters.push(monster);
                                game.screenShake = 8;

                                checkLevelUp();
                                updateMonsterCount();

                                if (game.monsters.length === 0) {
                                    roomCleared();
                                }
                            }

                            game.projectiles.splice(i, 1);
                            break;
                        }
                    }
                    if (!game.projectiles[i]) continue;
                }

                // Check wall collision
                let hitWall = false;
                for (const wall of game.walls) {
                    if (proj.x > wall.x && proj.x < wall.x + wall.width &&
                        proj.y > wall.y && proj.y < wall.y + wall.height) {
                        hitWall = true;
                        break;
                    }
                }

                if (hitWall || proj.life <= 0 ||
                    proj.x < 0 || proj.x > canvas.width ||
                    proj.y < 0 || proj.y > canvas.height) {
                    // Create impact particles
                    for (let j = 0; j < 6; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        game.particles.push({
                            x: proj.x,
                            y: proj.y,
                            vx: Math.cos(angle) * 2,
                            vy: Math.sin(angle) * 2,
                            color: proj.color,
                            life: 20,
                            size: 3
                        });
                    }
                    game.projectiles.splice(i, 1);
                }
            }
        }

        // Player death animation
        function startPlayerDeath() {
            game.player.isDying = true;
            game.player.deathFrame = 0;
            game.screenShake = 20;
            sfx.playerDeath();  // Player death sound
            addLog('Du bist gestorben!', 'combat');
        }

        function updatePlayerDeath() {
            if (game.player.isDying) {
                game.player.deathFrame++;
                // Create death particles
                if (game.player.deathFrame % 3 === 0) {
                    createParticles(game.player.x, game.player.y, '#ef4444');
                }
                if (game.player.deathFrame >= 60) {
                    gameOver();
                }
            }
        }

        // Update dying monsters
        function updateDyingMonsters() {
            for (let i = game.dyingMonsters.length - 1; i >= 0; i--) {
                const monster = game.dyingMonsters[i];
                monster.deathFrame++;

                // Create death particles with varying intensity (more at start)
                const particleChance = 1 - (monster.deathFrame / 45);
                if (Math.random() < particleChance * 0.5) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 25;
                    const speed = 2 + Math.random() * 3;
                    game.particles.push({
                        x: monster.x + Math.cos(angle) * dist,
                        y: monster.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 1,
                        color: monster.color,
                        life: 35,
                        size: Math.random() * 4 + 2
                    });
                }

                // Remove after animation completes (longer duration for smoother fade)
                if (monster.deathFrame >= 45) {
                    game.dyingMonsters.splice(i, 1);
                }
            }
        }

        // Check if there's a clear line of sight (no walls between two points)
        function hasLineOfSight(x1, y1, x2, y2) {
            const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / 10);
            if (steps === 0) return true; // Same position = clear line of sight
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const checkX = x1 + (x2 - x1) * t;
                const checkY = y1 + (y2 - y1) * t;
                if (isInWall(checkX, checkY, 5)) {
                    return false;
                }
            }
            return true;
        }

        function playerAttack() {
            if (game.player.attackCooldown > 0 || game.player.isDying) return;

            // Get weapon properties
            const weapon = game.player.equippedWeapon;
            const weaponRange = weapon ? (weapon.range || 80) : 28; // Faust = 28 (realistisch kurz)
            const weaponSpeed = weapon ? (weapon.speed || 1) : 1;
            const weaponStyle = weapon ? weapon.style : 'sword';

            game.player.attackCooldown = Math.floor(30 * weaponSpeed);

            // Magic Staff - shoots projectile with auto-aim (use shooting animation)
            if (weaponStyle === 'staff' || weaponStyle === 'fire_staff') {
                game.player.isShooting = true;
                game.player.shootFrame = 0;
                game.player.isAttacking = false;
                // Sound effect
                if (weaponStyle === 'fire_staff') {
                    sfx.fireShoot();
                } else {
                    sfx.magicShoot();
                }
                // Find nearest monster for auto-aim
                let target = null;
                let targetDist = 300;  // Max targeting range

                for (const monster of game.monsters) {
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                    if (dist < targetDist) {
                        target = monster;
                        targetDist = dist;
                    }
                }

                // Fire projectile
                let angle;
                if (target) {
                    angle = Math.atan2(target.y - game.player.y, target.x - game.player.x);
                    game.player.facingLeft = target.x < game.player.x;
                } else {
                    // No target - shoot in facing direction
                    angle = game.player.facingLeft ? Math.PI : 0;
                }
                game.player.facingAngle = angle;

                const projColor = weaponStyle === 'fire_staff' ? '#ff6600' : '#c084fc';
                game.projectiles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    color: projColor,
                    damage: game.player.attack,
                    size: 10,
                    life: 120,
                    fromMonster: false,
                    fromPlayer: true,
                    trail: []
                });

                // Staff shoot effect
                for (let i = 0; i < 8; i++) {
                    const pAngle = angle + (Math.random() - 0.5) * 0.5;
                    game.particles.push({
                        x: game.player.x,
                        y: game.player.y,
                        vx: Math.cos(pAngle) * 3,
                        vy: Math.sin(pAngle) * 3,
                        color: projColor,
                        life: 20,
                        size: 3
                    });
                }
                return;
            }

            // Melee attack animation
            game.player.isAttacking = true;
            game.player.attackFrame = 0;

            // Attack sound based on weapon
            if (!weapon) {
                sfx.punch();
            } else {
                sfx.swordSwing();
            }

            // Find closest monster that we can actually hit (line of sight check)
            let closest = null;
            let closestDist = weaponRange;

            for (const monster of game.monsters) {
                const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                if (dist < closestDist) {
                    // Check if there's a wall between player and monster
                    if (hasLineOfSight(game.player.x, game.player.y, monster.x, monster.y)) {
                        closest = monster;
                        closestDist = dist;
                        // Face the monster
                        game.player.facingLeft = monster.x < game.player.x;
                    }
                }
            }

            // Set facing angle for range indicator
            if (closest) {
                game.player.facingAngle = Math.atan2(closest.y - game.player.y, closest.x - game.player.x);
            } else {
                game.player.facingAngle = game.player.facingLeft ? Math.PI : 0;
            }

            if (closest) {
                const totalAttack = game.player.attack + (game.player.attackBoost || 0);
                let damage = Math.max(1, totalAttack - closest.defense);
                // Boss shield reduces damage by 50%
                if (closest.isBoss && closest.shieldActive) {
                    damage = Math.max(1, Math.floor(damage * 0.5));
                    addLog(`üõ°Ô∏è Schild absorbiert Schaden!`, 'combat');
                }
                closest.hp -= damage;
                closest.flashTimer = 10;
                addLog(`Du triffst ${closest.name} f√ºr ${damage} Schaden!`, 'combat');
                createParticles(closest.x, closest.y, closest.shieldActive ? '#60a5fa' : '#fbbf24');
                createSlashEffect(closest.x, closest.y);

                // Monster hit sound
                sfx.monsterHit(closest.style, closest.isBoss);

                if (closest.hp <= 0) {
                    // Monster death sound
                    sfx.monsterDeath(closest.style, closest.isBoss);
                    addLog(`${closest.name} besiegt! +${closest.xp} XP, +${closest.gold} Gold`, 'loot');
                    game.player.xp += closest.xp;
                    game.player.gold += closest.gold;
                    game.monstersKilled++;

                    // Drop loot
                    dropMonsterLoot(closest);

                    // Move to dying monsters for death animation
                    const index = game.monsters.indexOf(closest);
                    game.monsters.splice(index, 1);
                    closest.deathFrame = 0;
                    closest.isDying = true;
                    game.dyingMonsters.push(closest);
                    game.screenShake = 8;  // Screen shake on kill

                    checkLevelUp();
                    updateMonsterCount();

                    if (game.monsters.length === 0) {
                        roomCleared();
                    }
                }
            }
        }

        function createSlashEffect(x, y) {
            // Create arc of slash particles
            const baseAngle = Math.atan2(y - game.player.y, x - game.player.x);
            for (let i = 0; i < 12; i++) {
                const angle = baseAngle - Math.PI/4 + (i / 12) * Math.PI/2;
                const speed = Math.random() * 6 + 6;
                const dist = Math.random() * 15 + 10;
                game.particles.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: i % 2 === 0 ? '#fbbf24' : '#ffffff',
                    life: 15,
                    size: Math.random() * 3 + 2
                });
            }

            // Create impact sparks
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                game.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: '#ff4444',
                    life: 20,
                    size: Math.random() * 2 + 1
                });
            }
        }

        function pickupItem() {
            for (let i = game.items.length - 1; i >= 0; i--) {
                const item = game.items[i];
                if (Math.hypot(item.x - game.player.x, item.y - game.player.y) < 30) {
                    // Pickup sparkle effect
                    const color = item.type === 'weapon' ? '#C0C0C0' :
                                  item.type === 'armor' ? '#4169E1' : '#FF1493';
                    for (let j = 0; j < 15; j++) {
                        const angle = (j / 15) * Math.PI * 2;
                        game.particles.push({
                            x: item.x,
                            y: item.y,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3 - 2,
                            color: color,
                            life: 30,
                            size: 3
                        });
                    }

                    // Check if stackable (potions and bombs stack, weapons/armor don't)
                    let stacked = false;
                    if (item.type === 'potion' || item.type === 'bomb') {
                        // Find existing stack of same item
                        const existingStack = game.player.inventory.find(
                            invItem => invItem.name === item.name && invItem.type === item.type
                        );
                        if (existingStack) {
                            existingStack.count = (existingStack.count || 1) + 1;
                            stacked = true;
                        }
                    }

                    if (!stacked) {
                        // Check max inventory limit (5 different items)
                        if (game.player.inventory.length >= 5) {
                            addLog('Inventar voll! (Max 5 Items)', 'combat');
                            return;
                        }
                        item.count = 1;
                        game.player.inventory.push(item);
                    }

                    game.items.splice(i, 1);
                    sfx.itemPickup();  // Item pickup sound
                    addLog(`${item.name} aufgehoben!`, 'loot');
                    updateInventory();
                }
            }
        }

        function useItem(index) {
            if (index >= game.player.inventory.length) return;

            const item = game.player.inventory[index];

            if (item.type === 'potion') {
                // Start drinking animation
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = item.heal;
                game.player.drinkColor = item.heal >= 100 ? '#ff0066' : item.heal >= 50 ? '#ff1493' : '#ff69b4';

                game.player.hp = Math.min(game.player.maxHp, game.player.hp + item.heal);
                sfx.heal();  // Heal sound
                addLog(`${item.name} benutzt! +${item.heal} HP`, 'loot');
                // Reduce stack count
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
            } else if (item.type === 'weapon') {
                // Unequip old weapon if any
                if (game.player.equippedWeapon) {
                    addToInventory(game.player.equippedWeapon);
                }
                // Equip new weapon
                game.player.equippedWeapon = { ...item };
                delete game.player.equippedWeapon.count;
                game.player.attack = game.player.baseAttack + item.attack;
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
                addLog(`${item.name} ausger√ºstet! Angriff: ${game.player.attack}`, 'info');
            } else if (item.type === 'armor') {
                // Unequip old armor if any
                if (game.player.equippedArmor) {
                    addToInventory(game.player.equippedArmor);
                }
                // Equip new armor
                game.player.equippedArmor = { ...item };
                delete game.player.equippedArmor.count;
                game.player.defense = game.player.baseDefense + item.defense;
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
                addLog(`${item.name} ausger√ºstet! Verteidigung: ${game.player.defense}`, 'info');
            } else if (item.type === 'bomb') {
                // Throw bomb at nearest monster
                if (game.player.abilities.bomb.cooldown > 0) {
                    addLog('Bombe wird noch vorbereitet...', 'info');
                    return;
                }

                // Find nearest monster for targeting
                let target = null;
                let targetDist = 250;
                for (const monster of game.monsters) {
                    const dist = Math.hypot(monster.x - game.player.x, monster.y - game.player.y);
                    if (dist < targetDist) {
                        target = monster;
                        targetDist = dist;
                    }
                }

                const targetX = target ? target.x : game.player.x + (game.player.facingLeft ? -100 : 100);
                const targetY = target ? target.y : game.player.y;

                sfx.bombThrow();  // Bomb throw sound
                game.bombs.push({
                    x: game.player.x,
                    y: game.player.y,
                    startX: game.player.x,
                    startY: game.player.y,
                    targetX: targetX,
                    targetY: targetY,
                    progress: 0,
                    damage: item.damage || 40,
                    radius: item.damage >= 60 ? 80 : 60,
                    fuseTime: 60,
                    size: 10
                });

                game.player.abilities.bomb.cooldown = game.player.abilities.bomb.maxCooldown;
                addLog(`${item.name} geworfen!`, 'combat');

                // Reduce stack count
                item.count = (item.count || 1) - 1;
                if (item.count <= 0) {
                    game.player.inventory.splice(index, 1);
                }
            }

            updateInventory();
        }

        // Add item to inventory with stacking support
        function addToInventory(item) {
            if (item.type === 'potion' || item.type === 'bomb') {
                const existingStack = game.player.inventory.find(
                    invItem => invItem.name === item.name && invItem.type === item.type
                );
                if (existingStack) {
                    existingStack.count = (existingStack.count || 1) + 1;
                    return;
                }
            }
            item.count = item.count || 1;
            game.player.inventory.push(item);
        }

        // Drop single item from inventory
        function dropItem(index) {
            if (index >= game.player.inventory.length) return;

            const item = game.player.inventory[index];

            // Create dropped item near player
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            const droppedItem = {
                ...item,
                x: game.player.x + Math.cos(angle) * dist,
                y: game.player.y + Math.sin(angle) * dist,
                size: 12,
                animOffset: Math.random() * Math.PI * 2,
                dropAnim: 15,
                dropVy: -3,
                count: undefined
            };
            delete droppedItem.count;

            // Check if position is in wall, find valid nearby position
            if (isInWall(droppedItem.x, droppedItem.y, 10)) {
                let found = false;
                for (let radius = 20; radius <= 80 && !found; radius += 20) {
                    for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                        const testX = game.player.x + Math.cos(a) * radius;
                        const testY = game.player.y + Math.sin(a) * radius;
                        if (!isInWall(testX, testY, 10)) {
                            droppedItem.x = testX;
                            droppedItem.y = testY;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    droppedItem.x = game.player.x;
                    droppedItem.y = game.player.y;
                }
            }

            game.items.push(droppedItem);

            // Reduce stack or remove
            item.count = (item.count || 1) - 1;
            if (item.count <= 0) {
                game.player.inventory.splice(index, 1);
            }

            addLog(`${item.name} fallen gelassen!`, 'info');
            updateInventory();

            // Drop particle effect
            for (let i = 0; i < 8; i++) {
                const pAngle = (i / 8) * Math.PI * 2;
                game.particles.push({
                    x: game.player.x,
                    y: game.player.y,
                    vx: Math.cos(pAngle) * 2,
                    vy: Math.sin(pAngle) * 2,
                    color: '#888',
                    life: 20,
                    size: 2
                });
            }
        }

        function checkLevelUp() {
            while (game.player.xp >= game.player.xpToNext) {
                game.player.level++;
                game.player.xp -= game.player.xpToNext;
                game.player.xpToNext = Math.floor(game.player.xpToNext * 1.5);

                game.player.maxHp += 20;
                game.player.attack += 3;
                game.player.defense += 2;

                // Trigger level-up animation
                game.player.levelUpAnim = 60;
                sfx.levelUp();  // Level up sound

                addLog(`LEVEL UP! Du bist jetzt Level ${game.player.level}!`, 'level');
                // Create burst of golden particles
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    game.particles.push({
                        x: game.player.x,
                        y: game.player.y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        color: '#ffd700',
                        life: 50,
                        size: 4
                    });
                }
            }
        }

        // Update abilities UI
        function updateAbilitiesUI() {
            const section = document.getElementById('abilitiesSection');
            const container = document.getElementById('abilities');
            // Abilities section is hidden - bombs are now items
            container.innerHTML = '';
            section.style.display = 'none';
        }

        // Update bombs
        function updateBombs() {
            // Update ability cooldown
            if (game.player.abilities.bomb.cooldown > 0) {
                game.player.abilities.bomb.cooldown--;
            }

            for (let i = game.bombs.length - 1; i >= 0; i--) {
                const bomb = game.bombs[i];

                // Move bomb in arc
                if (bomb.progress < 1) {
                    bomb.progress += 0.05;
                    const t = bomb.progress;
                    // Parabolic arc
                    bomb.x = lerp(bomb.startX, bomb.targetX, t);
                    bomb.y = lerp(bomb.startY, bomb.targetY, t) - Math.sin(t * Math.PI) * 50;
                }

                bomb.fuseTime--;

                // Explosion
                if (bomb.fuseTime <= 0) {
                    explodeBomb(bomb);
                    game.bombs.splice(i, 1);
                }
            }
        }

        // Bomb explosion - damages through walls!
        function explodeBomb(bomb) {
            const explosionRadius = bomb.radius || 80;
            const bombDamage = bomb.damage || 40;
            game.screenShake = 15;
            sfx.bombExplode();  // Explosion sound

            // Create explosion particles
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 2;
                game.particles.push({
                    x: bomb.x,
                    y: bomb.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: Math.random() > 0.5 ? '#ff6600' : '#ffcc00',
                    life: 40,
                    size: Math.random() * 6 + 3
                });
            }

            // Damage monsters in radius (ignores walls!)
            for (let i = game.monsters.length - 1; i >= 0; i--) {
                const monster = game.monsters[i];
                const dist = Math.hypot(monster.x - bomb.x, monster.y - bomb.y);

                if (dist < explosionRadius) {
                    const damage = Math.floor(bombDamage * (1 - dist / explosionRadius));
                    monster.hp -= damage;
                    monster.flashTimer = 10;
                    addLog(`Explosion trifft ${monster.name} f√ºr ${damage} Schaden!`, 'combat');

                    if (monster.hp <= 0) {
                        addLog(`${monster.name} besiegt! +${monster.xp} XP, +${monster.gold} Gold`, 'loot');
                        game.player.xp += monster.xp;
                        game.player.gold += monster.gold;
                        game.monstersKilled++;
                        dropMonsterLoot(monster);

                        game.monsters.splice(i, 1);
                        monster.deathFrame = 0;
                        monster.isDying = true;
                        game.dyingMonsters.push(monster);

                        checkLevelUp();
                        updateMonsterCount();

                        if (game.monsters.length === 0) {
                            roomCleared();
                        }
                    }
                }
            }
        }

        function roomCleared() {
            game.roomsCleared++;
            game.doors[0].active = true;
            game.doors[0].openAnim = 0;  // Start door opening animation
            sfx.doorOpen();  // Door open sound

            if (game.currentRoom % 10 === 0) {
                addLog('üéâ BOSS BESIEGT! Weiter zum n√§chsten Abschnitt! üéâ', 'level');
            }
            addLog('Raum ges√§ubert! T√ºr ge√∂ffnet!', 'info');
        }

        function nextRoom() {
            // Start room transition
            game.roomTransition = 30;

            game.currentRoom++;

            // Clear dying monsters from previous room
            game.dyingMonsters = [];

            generateRoom();

            // Set initial spawn position (bottom center)
            let spawnX = canvas.width / 2;
            let spawnY = canvas.height - 50;

            // Safety check: ensure player doesn't spawn in a wall
            if (isInWall(spawnX, spawnY, 25)) {
                // Find a valid spawn position
                let found = false;
                for (let attempts = 0; attempts < 100 && !found; attempts++) {
                    // Try positions around the intended spawn point
                    const angle = (attempts / 100) * Math.PI * 2;
                    const radius = 30 + (attempts * 2);
                    const testX = canvas.width / 2 + Math.cos(angle) * radius;
                    const testY = canvas.height - 50 + Math.sin(angle) * radius;

                    // Keep within bounds
                    if (testX > 40 && testX < canvas.width - 40 &&
                        testY > 40 && testY < canvas.height - 40 &&
                        !isInWall(testX, testY, 25)) {
                        spawnX = testX;
                        spawnY = testY;
                        found = true;
                    }
                }

                // Fallback: spawn in center of map if all else fails
                if (!found) {
                    spawnX = canvas.width / 2;
                    spawnY = canvas.height / 2;
                }
            }

            game.player.x = spawnX;
            game.player.y = spawnY;

            // Activate spawn protection (5 sec for level 1, 3 sec otherwise)
            const protectionTime = game.currentRoom === 1 ? 300 : 180;
            game.player.spawnProtection = protectionTime;
            sfx.newRoom();  // New room sound
            addLog(`üõ°Ô∏è Spawn-Schutz aktiv (${protectionTime / 60} Sek.)`, 'info');

            spawnMonsters();
            spawnItems();

            if (game.currentRoom % 10 === 0) {
                addLog(`‚ö†Ô∏è LEVEL ${game.currentRoom} - BOSS ARENA ‚ö†Ô∏è`, 'combat');
                game.screenShake = 15;  // Dramatic shake for boss room
            } else {
                addLog(`Level ${game.currentRoom} betreten!`, 'info');
            }
            document.getElementById('currentRoom').textContent = game.currentRoom;
        }

        function gameWon() {
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.querySelector('h2').textContent = 'üéâ SIEG! üéâ';
            gameOverDiv.querySelector('h2').style.color = '#4ade80';
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('roomsCleared').textContent = game.roomsCleared;
            document.getElementById('monstersKilled').textContent = game.monstersKilled;
            document.getElementById('totalGold').textContent = game.player.gold;
            gameOverDiv.style.display = 'block';
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color,
                    life: 40,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function updateParticles() {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];

                // Apply velocity with smooth deceleration
                p.x += p.vx;
                p.y += p.vy;

                // Apply slight gravity
                p.vy += 0.1;

                // Smooth velocity decay (friction)
                p.vx *= 0.96;
                p.vy *= 0.96;

                // Shrink particle over time
                if (p.size > 0.5) {
                    p.size *= 0.98;
                }

                p.life--;

                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        function addLog(message, type = 'info') {
            const log = document.getElementById('log');
            const msg = document.createElement('div');
            msg.className = `log-message log-${type}`;
            msg.textContent = '> ' + message;
            log.appendChild(msg);
            log.scrollTop = log.scrollHeight;

            // Keep only last 50 messages
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        function updateUI() {
            document.getElementById('playerLevel').textContent = game.player.level;
            document.getElementById('hpText').textContent = `${Math.max(0, Math.floor(game.player.hp))}/${game.player.maxHp}`;
            document.getElementById('hpBar').style.width = `${(game.player.hp / game.player.maxHp) * 100}%`;
            document.getElementById('xpText').textContent = `${game.player.xp}/${game.player.xpToNext}`;
            document.getElementById('xpBar').style.width = `${(game.player.xp / game.player.xpToNext) * 100}%`;
            document.getElementById('playerAttack').textContent = game.player.attack;
            document.getElementById('playerDefense').textContent = game.player.defense;
            document.getElementById('playerGold').textContent = game.player.gold;
        }

        function updateMonsterCount() {
            document.getElementById('monsterCount').textContent = game.monsters.length;
        }

        function updateInventory() {
            const inv = document.getElementById('inventory');
            inv.innerHTML = '';

            game.player.inventory.forEach((item, i) => {
                const div = document.createElement('div');
                div.className = `item ${item.type}`;
                div.textContent = `${i + 1}. ${item.name}`;
                div.onclick = () => useItem(i);
                inv.appendChild(div);
            });
        }

        function gameOver() {
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('roomsCleared').textContent = game.roomsCleared;
            document.getElementById('monstersKilled').textContent = game.monstersKilled;
            document.getElementById('totalGold').textContent = game.player.gold;

            // Calculate score
            const score = calculateScore();
            document.getElementById('finalScore').textContent = score;
            game.finalScore = score;

            document.getElementById('gameOver').style.display = 'block';
        }

        // ==================== HIGHSCORE SYSTEM ====================
        function calculateScore() {
            return (game.currentRoom * 100) +
                   (game.monstersKilled * 10) +
                   (game.player.gold) +
                   (game.player.level * 50);
        }

        function getHighscores() {
            try {
                const data = localStorage.getItem('dungeonCrawlerHighscores');
                return data ? JSON.parse(data) : [];
            } catch (e) {
                return [];
            }
        }

        function saveHighscore() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim() || 'Anonym';
            const score = game.finalScore || calculateScore();

            const highscores = getHighscores();
            highscores.push({
                name: name,
                score: score,
                level: game.player.level,
                room: game.currentRoom,
                date: new Date().toLocaleDateString('de-DE')
            });

            // Sort by score descending and keep top 10
            highscores.sort((a, b) => b.score - a.score);
            highscores.splice(10);

            try {
                localStorage.setItem('dungeonCrawlerHighscores', JSON.stringify(highscores));
                document.getElementById('saveScoreSection').innerHTML = '<p style="color: #4ade80;">‚úÖ Highscore gespeichert!</p>';
                addLog(`üèÜ Highscore gespeichert: ${score} Punkte`, 'loot');
            } catch (e) {
                addLog('Fehler beim Speichern!', 'combat');
            }
        }

        function showHighscoreMenu() {
            const highscores = getHighscores();
            const list = document.getElementById('highscoreList');

            if (highscores.length === 0) {
                list.innerHTML = '<p style="color: #888; text-align: center;">Noch keine Highscores!</p>';
            } else {
                list.innerHTML = highscores.map((hs, i) => `
                    <div class="highscore-entry">
                        <span class="highscore-rank">#${i + 1}</span>
                        <span class="highscore-name">${hs.name}</span>
                        <span class="highscore-score">${hs.score} (Lvl ${hs.level})</span>
                    </div>
                `).join('');
            }

            document.getElementById('highscoreMenu').style.display = 'block';
        }

        function closeHighscoreMenu() {
            document.getElementById('highscoreMenu').style.display = 'none';
        }

        function drawBrick(x, y, width, height) {
            const brickW = 20;
            const brickH = 10;

            for (let by = 0; by < height; by += brickH) {
                for (let bx = 0; bx < width; bx += brickW) {
                    const offset = (Math.floor(by / brickH) % 2) * (brickW / 2);
                    const actualX = x + bx + offset;
                    const actualY = y + by;

                    if (actualX >= x + width || actualY >= y + height) continue;

                    // Stone brick base
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(actualX, actualY, Math.min(brickW - 1, x + width - actualX), Math.min(brickH - 1, y + height - actualY));

                    // Highlight
                    ctx.fillStyle = '#6f6f6f';
                    ctx.fillRect(actualX, actualY, Math.min(brickW - 1, x + width - actualX), 2);
                    ctx.fillRect(actualX, actualY, 2, Math.min(brickH - 1, y + height - actualY));

                    // Shadow
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(actualX + Math.min(brickW - 2, x + width - actualX - 2), actualY, 1, Math.min(brickH - 1, y + height - actualY));
                    ctx.fillRect(actualX, actualY + Math.min(brickH - 2, y + height - actualY - 2), Math.min(brickW - 1, x + width - actualX), 1);
                }
            }
        }

        function draw() {
            // Apply screen shake
            ctx.save();
            if (game.screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * game.screenShake;
                const shakeY = (Math.random() - 0.5) * game.screenShake;
                ctx.translate(shakeX, shakeY);
                game.screenShake *= 0.9;
                if (game.screenShake < 0.5) game.screenShake = 0;
            }

            // Background - dungeon stone floor
            const tileSize = 32;
            for (let y = 0; y < canvas.height; y += tileSize) {
                for (let x = 0; x < canvas.width; x += tileSize) {
                    const isLight = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = isLight ? '#2a2a2a' : '#1f1f1f';
                    ctx.fillRect(x, y, tileSize, tileSize);

                    // Stone texture details
                    ctx.fillStyle = isLight ? '#353535' : '#252525';
                    ctx.fillRect(x, y, tileSize, 2);
                    ctx.fillRect(x, y, 2, tileSize);
                }
            }

            // Draw walls with stone texture
            for (const wall of game.walls) {
                drawBrick(wall.x, wall.y, wall.width, wall.height);
            }

            // Draw doors - castle gate style with animations
            for (const door of game.doors) {
                // Update door animation
                if (door.active && door.openAnim !== undefined) {
                    door.openAnim = Math.min(door.openAnim + 2, 100);
                }

                const doorColor = door.active ? '#00D000' : '#808080';
                const pulseIntensity = door.active ? Math.sin(game.animCounter * 0.1) * 0.3 + 0.7 : 1;

                // Glow effect for active door
                if (door.active) {
                    const glowSize = 10 + Math.sin(game.animCounter * 0.15) * 5;
                    ctx.shadowBlur = glowSize;
                    ctx.shadowColor = '#00FF00';

                    // Particle sparkles around door
                    if (Math.random() < 0.1) {
                        game.particles.push({
                            x: door.x + Math.random() * door.width,
                            y: door.y + Math.random() * door.height,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * -2,
                            color: '#00FF00',
                            life: 30,
                            size: 2
                        });
                    }
                }

                // Door frame
                ctx.fillStyle = '#000000';
                ctx.fillRect(door.x - 2, door.y - 2, door.width + 4, door.height + 4);

                // Door base with pulse
                ctx.globalAlpha = pulseIntensity;
                ctx.fillStyle = doorColor;
                ctx.fillRect(door.x, door.y, door.width, door.height);
                ctx.globalAlpha = 1;

                // Door pattern (vertical lines) - animate opening
                const openOffset = door.openAnim ? (door.openAnim / 100) * 10 : 0;
                ctx.fillStyle = door.active ? '#00A000' : '#606060';
                for (let i = door.x + 5; i < door.x + door.width - 5; i += 8) {
                    const lineOffset = (i < door.x + door.width/2) ? -openOffset : openOffset;
                    ctx.fillRect(i + lineOffset, door.y, 3, door.height);
                }

                // Door top decoration - pulse and rotate for active door
                if (door.active) {
                    ctx.save();
                    ctx.translate(door.x + door.width/2, door.y + 8);
                    ctx.rotate(game.animCounter * 0.05);
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-4, -4, 8, 8);
                    ctx.restore();
                }

                ctx.shadowBlur = 0;
            }

            // Draw items - pixel art style with drop animation
            for (const item of game.items) {
                // Update drop animation
                if (item.dropAnim && item.dropAnim > 0) {
                    item.dropAnim--;
                    item.dropVy += 0.5;  // Gravity
                    item.y += item.dropVy;
                }

                const bounce = Math.sin(game.animCounter * 0.05 + item.animOffset) * 3;
                let itemY = item.y + bounce;

                // Draw item shadow - very visible
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                ctx.beginPath();
                ctx.ellipse(item.x, item.y + 14, 10, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Scale effect for newly dropped items
                let scale = 1;
                if (item.dropAnim && item.dropAnim > 10) {
                    scale = 1 + (item.dropAnim - 10) / 20;
                }

                ctx.save();
                ctx.translate(item.x, itemY);
                ctx.scale(scale, scale);
                ctx.translate(-item.x, -itemY);

                ctx.shadowBlur = 0;

                const style = item.style || '';

                // Draw items matching inventory graphics
                if (item.type === 'weapon') {
                    if (style === 'flame' || style === 'fire_staff') {
                        // Fire weapon
                        ctx.shadowBlur = 6;
                        ctx.shadowColor = '#ff6600';
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(item.x - 2, itemY - 10, 4, 16);
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(item.x - 1, itemY - 8, 2, 10);
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 3, itemY + 6, 6, 4);
                    } else if (style === 'dagger' || style === 'poison_dagger') {
                        ctx.fillStyle = style === 'poison_dagger' ? '#22c55e' : '#c0c0c0';
                        ctx.fillRect(item.x - 1, itemY - 7, 3, 10);
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 2, itemY + 3, 5, 5);
                    } else if (style === 'axe' || style === 'battleaxe') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 9, 3, 16);
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(item.x - 5, itemY - 8, 8, 6);
                    } else if (style === 'hammer') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 6, 3, 14);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(item.x - 4, itemY - 8, 9, 7);
                    } else if (style === 'spear' || style === 'halberd') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(item.x - 1, itemY - 8, 2, 18);
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.moveTo(item.x, itemY - 12);
                        ctx.lineTo(item.x - 3, itemY - 6);
                        ctx.lineTo(item.x + 3, itemY - 6);
                        ctx.closePath();
                        ctx.fill();
                    } else if (style === 'staff') {
                        ctx.fillStyle = '#5c3d2e';
                        ctx.fillRect(item.x - 1, itemY - 8, 3, 18);
                        ctx.fillStyle = '#c084fc';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#c084fc';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY - 10, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (style === 'claw') {
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(item.x - 4, itemY, 8, 6);
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(item.x - 5, itemY - 8, 2, 10);
                        ctx.fillRect(item.x - 1, itemY - 10, 2, 12);
                        ctx.fillRect(item.x + 3, itemY - 8, 2, 10);
                    } else if (style === 'bone') {
                        ctx.fillStyle = '#e2e8f0';
                        ctx.fillRect(item.x - 2, itemY - 9, 4, 14);
                        ctx.fillRect(item.x - 4, itemY - 6, 2, 4);
                        ctx.fillRect(item.x + 2, itemY - 6, 2, 4);
                    } else if (style === 'rusty_sword') {
                        // Rusty sword on ground
                        // Rusty blade
                        ctx.fillStyle = '#8B7355';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        // Rust patches
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(item.x - 2, itemY - 10, 2, 3);
                        ctx.fillRect(item.x, itemY - 4, 2, 4);
                        ctx.fillRect(item.x - 2, itemY, 3, 2);
                        // Dark rust/pitting
                        ctx.fillStyle = '#6B4423';
                        ctx.fillRect(item.x - 1, itemY - 6, 1, 2);
                        ctx.fillRect(item.x + 1, itemY - 2, 1, 2);
                        // Dull edge
                        ctx.fillStyle = '#9B8B7B';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 10);
                        // Worn crossguard
                        ctx.fillStyle = '#5C4033';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Worn grip
                        ctx.fillStyle = '#3a2718';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#4a3020';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Dented pommel
                        ctx.fillStyle = '#5C4033';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (style === 'iron_sword') {
                        // Iron sword on ground
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#B8C0CC';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        ctx.fillStyle = '#6B7280';
                        ctx.fillRect(item.x - 1, itemY - 10, 1, 12);
                        // Iron crossguard
                        ctx.fillStyle = '#4B5563';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Leather grip
                        ctx.fillStyle = '#5C4033';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#6B5043';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Iron pommel
                        ctx.fillStyle = '#4B5563';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (style === 'steel_sword') {
                        // Steel sword on ground - bright and polished
                        ctx.fillStyle = '#E5E7EB';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#F3F4F6';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 1, itemY - 10, 1, 12);
                        // Steel crossguard
                        ctx.fillStyle = '#6B7280';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        ctx.fillStyle = '#9CA3AF';
                        ctx.fillRect(item.x - 4, itemY + 4, 8, 1);
                        // Blue leather grip
                        ctx.fillStyle = '#1E3A5F';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#2B4A6F';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Steel pommel with gem
                        ctx.fillStyle = '#6B7280';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3B82F6';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 1, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Realistic sword on ground
                        // Klinge
                        ctx.fillStyle = '#D8D8D8';
                        ctx.fillRect(item.x - 2, itemY - 12, 4, 16);
                        ctx.fillStyle = '#A8A8A8';
                        ctx.fillRect(item.x - 1, itemY - 11, 1, 14);
                        ctx.fillStyle = '#F0F0F0';
                        ctx.fillRect(item.x - 2, itemY - 10, 1, 12);
                        // Parierstange
                        ctx.fillStyle = '#B8860B';
                        ctx.fillRect(item.x - 5, itemY + 4, 10, 2);
                        // Griff
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(item.x - 2, itemY + 6, 4, 5);
                        ctx.fillStyle = '#5c4033';
                        ctx.fillRect(item.x - 2, itemY + 7, 4, 1);
                        ctx.fillRect(item.x - 2, itemY + 9, 4, 1);
                        // Knauf
                        ctx.fillStyle = '#B8860B';
                        ctx.beginPath();
                        ctx.arc(item.x, itemY + 12, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (item.type === 'armor') {
                    // Shield - matching inventory style
                    const armorStyle = item.style || 'leather';
                    const armorColors = { leather: '#8B4513', chain: '#808080', plate: '#c0c0c0', dragon: '#ef4444' };
                    ctx.fillStyle = armorColors[armorStyle] || '#4169E1';
                    ctx.beginPath();
                    ctx.moveTo(item.x, itemY - 10);
                    ctx.lineTo(item.x - 8, itemY - 6);
                    ctx.lineTo(item.x - 8, itemY + 4);
                    ctx.lineTo(item.x, itemY + 10);
                    ctx.lineTo(item.x + 8, itemY + 4);
                    ctx.lineTo(item.x + 8, itemY - 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(item.x - 3, itemY - 3, 6, 6);
                } else if (item.type === 'bomb') {
                    // Bomb - matching inventory style
                    const isBig = (item.damage || 40) >= 60;
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(item.x, itemY + 2, isBig ? 9 : 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(item.x - 2, itemY, isBig ? 4 : 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(item.x, itemY - 6);
                    ctx.quadraticCurveTo(item.x + 3, itemY - 10, item.x + 5, itemY - 8);
                    ctx.stroke();
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(item.x + 5, itemY - 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (item.type === 'potion') {
                    // Potion - matching inventory style
                    ctx.fillStyle = '#333';
                    ctx.fillRect(item.x - 2, itemY - 10, 4, 4);
                    const potionColor = (item.heal || 30) >= 100 ? '#ff0066' : (item.heal || 30) >= 50 ? '#ff1493' : '#ff69b4';
                    ctx.fillStyle = potionColor;
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = potionColor;
                    ctx.fillRect(item.x - 5, itemY - 6, 10, 12);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fillRect(item.x - 4, itemY - 5, 3, 8);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(item.x - 2, itemY - 10, 4, 3);
                }

                ctx.restore();
            }

            // Draw bombs
            for (const bomb of game.bombs) {
                // Shadow on ground
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(bomb.targetX, bomb.targetY + 5, 12, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bomb body
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, bomb.size, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.fillStyle = '#555555';
                ctx.beginPath();
                ctx.arc(bomb.x - 3, bomb.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();

                // Fuse
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bomb.x, bomb.y - bomb.size);
                ctx.lineTo(bomb.x + 4, bomb.y - bomb.size - 6);
                ctx.stroke();

                // Spark on fuse
                if (bomb.fuseTime % 10 < 5) {
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 4, bomb.y - bomb.size - 6, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw projectiles with trails
            for (const proj of game.projectiles) {
                // Draw shadow for falling projectiles (arrows, meteors)
                if (proj.vy > 2 && proj.fromMonster) {
                    const groundY = canvas.height - 20;
                    const heightAboveGround = groundY - proj.y;
                    const shadowAlpha = Math.max(0.1, 0.4 - heightAboveGround / 600);
                    const shadowSize = Math.max(5, 15 - heightAboveGround / 50);

                    ctx.save();
                    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
                    ctx.beginPath();
                    ctx.ellipse(proj.x, groundY, shadowSize, shadowSize * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Warning ring for impact zone
                    if (heightAboveGround < 150) {
                        const warningAlpha = (1 - heightAboveGround / 150) * 0.5;
                        ctx.strokeStyle = `rgba(255, 50, 50, ${warningAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(proj.x, groundY, shadowSize * 1.5, shadowSize * 0.6, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                // Draw trail
                for (let i = 0; i < proj.trail.length; i++) {
                    const t = proj.trail[i];
                    const alpha = (i / proj.trail.length) * 0.5;
                    const size = (i / proj.trail.length) * proj.size * 0.8;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Draw main projectile with glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = proj.color;
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Inner bright core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Draw monster shadows first (so they appear below monsters)
            for (const monster of game.monsters) {
                const s = monster.size;

                // Boss jump attack shadow - grows as boss descends
                if (monster.isBoss && monster.isJumping && monster.jumpTarget) {
                    const t = monster.jumpProgress;
                    const heightFactor = Math.sin(t * Math.PI); // 0 -> 1 -> 0
                    const shadowSize = s * (0.6 + t * 1.2); // Shadow grows as boss falls
                    const shadowAlphaJump = 0.4 + (1 - heightFactor) * 0.5; // Much more opaque

                    // Draw shadow at landing position - darker and bigger
                    ctx.save();
                    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlphaJump})`;
                    ctx.beginPath();
                    ctx.ellipse(monster.jumpTarget.x, monster.jumpTarget.y + s/2, shadowSize, shadowSize * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Pulsing warning ring
                    if (t > 0.5) {
                        const pulseAlpha = (t - 0.5) * 2 * 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 0, ${pulseAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(monster.jumpTarget.x, monster.jumpTarget.y + s/2, shadowSize * 1.5, shadowSize * 0.6, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else {
                    // Normal monster shadow - very visible
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(monster.x, monster.y + s/2 + 4, s * 0.8, s * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Draw monsters - unique designs per type
            for (const monster of game.monsters) {
                const bounce = Math.sin(monster.animFrame) * 2;
                const flash = monster.flashTimer > 0;
                const isBoss = monster.isBoss || false;
                const isAttacking = monster.isAttacking || false;
                const style = monster.style || 'goblin';
                let monsterY = monster.y + bounce;

                // Smooth attack animation with easing
                let attackScale = 1;
                if (isAttacking) {
                    const attackProgress = monster.attackFrame / 15;
                    attackScale = 1 + easing.easeOutQuad(Math.sin(attackProgress * Math.PI)) * 0.25;
                }

                ctx.shadowBlur = 0;
                const bodyColor = flash ? '#FFFFFF' : monster.color;
                const darkColor = flash ? '#CCCCCC' : (monster.colorDark || monster.color);

                ctx.save();
                ctx.translate(monster.x, monsterY);
                ctx.scale(attackScale, attackScale);
                ctx.translate(-monster.x, -monsterY);

                const s = monster.size;
                const x = monster.x;
                const y = monsterY;

                if (isBoss) {
                    // BOSS - Dungeon Lord
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Horns
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x - s/2 - 4, y - s/2 - 8, 6, 10);
                    ctx.fillRect(x + s/2 - 2, y - s/2 - 8, 6, 10);

                    // Crown
                    ctx.fillRect(x - 12, y - s/2 - 10, 24, 4);
                    ctx.fillRect(x - 10, y - s/2 - 14, 4, 4);
                    ctx.fillRect(x - 2, y - s/2 - 16, 4, 6);
                    ctx.fillRect(x + 6, y - s/2 - 14, 4, 4);

                    // Eyes - glowing
                    ctx.fillStyle = isAttacking ? '#FFFF00' : '#FF0000';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.fillRect(x - 10, y - 6, 6, 6);
                    ctx.fillRect(x + 4, y - 6, 6, 6);
                    ctx.shadowBlur = 0;

                    // Mouth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 8, y + 6, 16, isAttacking ? 8 : 4);

                } else if (style === 'goblin') {
                    // GOBLIN - Small, green, pointy ears, dagger
                    const footAnim = Math.sin(monster.animFrame * 2) * 2;

                    // Body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Pointy ears
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x - s/2 - 2, y - 2);
                    ctx.lineTo(x - s/2 - 6, y - 8);
                    ctx.lineTo(x - s/2, y - 4);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + s/2 + 2, y - 2);
                    ctx.lineTo(x + s/2 + 6, y - 8);
                    ctx.lineTo(x + s/2, y - 4);
                    ctx.fill();

                    // Eyes - beady
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(x - 4, y - 3, 3, 3);
                    ctx.fillRect(x + 1, y - 3, 3, 3);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 3, y - 2, 2, 2);
                    ctx.fillRect(x + 2, y - 2, 2, 2);

                    // Snout/nose
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - 2, y + 1, 4, 3);

                    // Draw equipped weapon
                    const gobWeapon = monster.equippedWeapon;
                    if (gobWeapon) {
                        const wStyle = gobWeapon.style;
                        const weaponSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 30 : 0;
                        ctx.save();
                        ctx.translate(x + s/2, y);
                        ctx.rotate((weaponSwing * Math.PI) / 180);
                        if (wStyle === 'dagger' || wStyle === 'poison_dagger') {
                            ctx.fillStyle = wStyle === 'poison_dagger' ? '#22c55e' : '#C0C0C0';
                            ctx.fillRect(2, -2, 8, 3);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -2, 3, 3);
                        } else if (wStyle === 'rusty_sword' || wStyle === 'sword') {
                            ctx.fillStyle = wStyle === 'rusty_sword' ? '#8B7355' : '#C0C0C0';
                            ctx.fillRect(2, -3, 12, 3);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -4, 3, 5);
                        }
                        ctx.restore();
                    }

                    // Feet
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 - 1 + footAnim, y + s/2, 4, 3);
                    ctx.fillRect(x + s/2 - 3 - footAnim, y + s/2, 4, 3);

                } else if (style === 'skeleton') {
                    // SKELETON - Boney, skull head, sword
                    const footAnim = Math.sin(monster.animFrame * 1.5) * 2;

                    // Ribcage body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2 + 2, s, s - 4);
                    // Ribs
                    ctx.fillStyle = darkColor;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(x - s/2 + 2, y - s/2 + 4 + i * 4, s - 4, 2);
                    }

                    // Skull
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2 - 1, y - s/2 - 6, s + 2, 8);

                    // Eye sockets
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 5, y - s/2 - 3, 4, 4);
                    ctx.fillRect(x + 1, y - s/2 - 3, 4, 4);

                    // Jaw
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - 4, y - s/2 + 1, 8, 2);

                    // Draw equipped weapon
                    const skelWeapon = monster.equippedWeapon;
                    const skelSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 40 : 0;
                    ctx.save();
                    ctx.translate(x + s/2 + 1, y);
                    ctx.rotate((skelSwing * Math.PI) / 180);
                    if (skelWeapon) {
                        const wStyle = skelWeapon.style;
                        if (wStyle === 'bone') {
                            ctx.fillStyle = '#e2e8f0';
                            ctx.fillRect(0, -8, 3, 16);
                            ctx.fillStyle = '#94a3b8';
                            ctx.fillRect(-2, -2, 7, 3);
                        } else if (wStyle === 'rusty_sword' || wStyle === 'sword') {
                            ctx.fillStyle = wStyle === 'rusty_sword' ? '#8B7355' : '#A0A0A0';
                            ctx.fillRect(0, -8, 3, 16);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-2, -2, 7, 3);
                        } else if (wStyle === 'spear') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -12, 2, 20);
                            ctx.fillStyle = '#A0A0A0';
                            ctx.beginPath();
                            ctx.moveTo(1, -16);
                            ctx.lineTo(-2, -10);
                            ctx.lineTo(4, -10);
                            ctx.fill();
                        }
                    } else {
                        // Default sword if no weapon
                        ctx.fillStyle = '#A0A0A0';
                        ctx.fillRect(0, -8, 3, 16);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(-2, -2, 7, 3);
                    }
                    ctx.restore();

                    // Boney legs
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - 4 + footAnim, y + s/2 - 2, 3, 8);
                    ctx.fillRect(x + 1 - footAnim, y + s/2 - 2, 3, 8);

                } else if (style === 'orc') {
                    // ORC - Big, muscular, green, axe
                    const footAnim = Math.sin(monster.animFrame * 1.2) * 3;

                    // Large body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Muscular shoulders
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 - 4, y - s/2 + 2, 5, 8);
                    ctx.fillRect(x + s/2 - 1, y - s/2 + 2, 5, 8);

                    // Head (smaller than body)
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - 6, y - s/2 - 8, 12, 10);

                    // Tusks
                    ctx.fillStyle = '#FFFACD';
                    ctx.fillRect(x - 6, y - s/2 - 2, 3, 6);
                    ctx.fillRect(x + 3, y - s/2 - 2, 3, 6);

                    // Angry eyes
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(x - 4, y - s/2 - 5, 3, 2);
                    ctx.fillRect(x + 1, y - s/2 - 5, 3, 2);

                    // Draw equipped weapon
                    const orcWeapon = monster.equippedWeapon;
                    const orcSwing = isAttacking ? Math.sin((monster.attackFrame / 15) * Math.PI) * 50 : 0;
                    ctx.save();
                    ctx.translate(x + s/2 + 3, y);
                    ctx.rotate((orcSwing * Math.PI) / 180);
                    if (orcWeapon) {
                        const wStyle = orcWeapon.style;
                        if (wStyle === 'axe' || wStyle === 'battleaxe') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -10, 4, 20);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-2, -12, 10, 6);
                            ctx.fillRect(-2, 6, 10, 6);
                        } else if (wStyle === 'hammer') {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(1, -8, 3, 18);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-3, -12, 11, 8);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-3, -12, 11, 2);
                        }
                    } else {
                        // Default axe
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(0, -10, 4, 20);
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-2, -12, 10, 6);
                        ctx.fillRect(-2, 6, 10, 6);
                    }
                    ctx.restore();

                    // Feet
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 + footAnim, y + s/2, 6, 4);
                    ctx.fillRect(x + s/2 - 6 - footAnim, y + s/2, 6, 4);

                } else if (style === 'mage') {
                    // DARK MAGE - Robed wizard with staff
                    const floatOffset = Math.sin(monster.animFrame * 0.8) * 2;

                    // Magical aura (when attacking)
                    if (isAttacking) {
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = monster.projectileColor || '#c084fc';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = monster.projectileColor || '#c084fc';
                        ctx.beginPath();
                        ctx.arc(x, y - floatOffset, s + 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }

                    // Robe body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2 + 2 - floatOffset, s, s + 4);

                    // Robe bottom (wider)
                    ctx.fillRect(x - s/2 - 2, y + s/2 - 2 - floatOffset, s + 4, 6);

                    // Robe trim
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x - s/2, y - floatOffset, s, 2);

                    // Hood/Head
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x - s/2 + 2, y - s/2 - 6 - floatOffset, s - 4, 10);

                    // Hood point
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y - s/2 - 6 - floatOffset);
                    ctx.lineTo(x, y - s/2 - 12 - floatOffset);
                    ctx.lineTo(x + 4, y - s/2 - 6 - floatOffset);
                    ctx.fill();

                    // Face shadow
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(x - 4, y - s/2 - 2 - floatOffset, 8, 6);

                    // Glowing eyes
                    ctx.fillStyle = '#00FFFF';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#00FFFF';
                    ctx.fillRect(x - 4, y - s/2 - floatOffset, 3, 2);
                    ctx.fillRect(x + 1, y - s/2 - floatOffset, 3, 2);
                    ctx.shadowBlur = 0;

                    // Arms
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2 - 3, y - 2 - floatOffset, 4, 8);
                    ctx.fillRect(x + s/2 - 1, y - 2 - floatOffset, 4, 8);

                    // Hands
                    ctx.fillStyle = '#2a2a4a';
                    ctx.fillRect(x - s/2 - 3, y + 5 - floatOffset, 4, 3);
                    ctx.fillRect(x + s/2 - 1, y + 5 - floatOffset, 4, 3);

                    // Staff
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(x + s/2 + 4, y - s/2 - 8 - floatOffset, 3, s + 20);

                    // Staff orb with glow
                    const orbPulse = Math.sin(monster.animFrame * 2) * 2;
                    ctx.fillStyle = monster.projectileColor || '#c084fc';
                    ctx.shadowBlur = 12 + orbPulse;
                    ctx.shadowColor = monster.projectileColor || '#c084fc';
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5, y - s/2 - 12 - floatOffset, 6 + orbPulse/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5, y - s/2 - 12 - floatOffset, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                } else if (style === 'demon') {
                    // DEMON - Red, wings, horns, claws
                    const wingFlap = Math.sin(monster.animFrame * 3) * 0.3;

                    // Wings
                    ctx.fillStyle = darkColor;
                    ctx.save();
                    ctx.translate(x - s/2 - 2, y);
                    ctx.rotate(-0.3 - wingFlap);
                    ctx.fillRect(-12, -8, 14, 16);
                    ctx.restore();
                    ctx.save();
                    ctx.translate(x + s/2 + 2, y);
                    ctx.rotate(0.3 + wingFlap);
                    ctx.fillRect(-2, -8, 14, 16);
                    ctx.restore();

                    // Body
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);

                    // Horns
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(x - s/2, y - s/2);
                    ctx.lineTo(x - s/2 - 4, y - s/2 - 10);
                    ctx.lineTo(x - s/2 + 4, y - s/2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y - s/2);
                    ctx.lineTo(x + s/2 + 4, y - s/2 - 10);
                    ctx.lineTo(x + s/2 - 4, y - s/2);
                    ctx.fill();

                    // Glowing eyes
                    ctx.fillStyle = '#FFFF00';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#FF6600';
                    ctx.fillRect(x - 6, y - 4, 5, 4);
                    ctx.fillRect(x + 1, y - 4, 5, 4);
                    ctx.shadowBlur = 0;

                    // Fanged mouth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 5, y + 3, 10, 4);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x - 4, y + 3, 2, 3);
                    ctx.fillRect(x + 2, y + 3, 2, 3);

                    // Claws
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x - s/2 - 4, y + s/2 - 2, 3, 6);
                    ctx.fillRect(x + s/2 + 1, y + s/2 - 2, 3, 6);
                }

                ctx.restore();

                // HP bar
                const barWidth = isBoss ? 60 : 35;
                const barHeight = isBoss ? 8 : 5;
                const barY = monster.y - monster.size - (isBoss ? 30 : 20);

                ctx.fillStyle = '#000000';
                ctx.fillRect(monster.x - barWidth/2 - 1, barY - 1, barWidth + 2, barHeight + 2);

                const hpPercent = monster.hp / monster.maxHp;
                const hpColor = hpPercent > 0.5 ? '#00D000' : hpPercent > 0.25 ? '#FFA500' : '#FF0000';
                ctx.fillStyle = hpColor;
                ctx.fillRect(monster.x - barWidth/2, barY, hpPercent * barWidth, barHeight);

                // HP Zahlen-Anzeige
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = isBoss ? 'bold 11px "Courier New"' : 'bold 9px "Courier New"';
                ctx.textAlign = 'center';
                const hpText = `${Math.ceil(monster.hp)}/${monster.maxHp}`;
                ctx.strokeText(hpText, monster.x, barY + barHeight + 10);
                ctx.fillText(hpText, monster.x, barY + barHeight + 10);

                if (isBoss) {
                    ctx.font = 'bold 12px "Courier New"';
                    ctx.lineWidth = 3;
                    ctx.strokeText(monster.name, monster.x, barY - 8);
                    ctx.fillText(monster.name, monster.x, barY - 8);
                }
            }

            // Draw dying monsters with smooth death animation
            for (const monster of game.dyingMonsters) {
                const rawProgress = monster.deathFrame / 45;
                const deathProgress = easing.easeOutQuad(Math.min(rawProgress, 1));

                // Smooth scale with slight bounce at start
                const scaleProgress = easing.easeInQuad(rawProgress);
                const scale = Math.max(0, 1.2 - scaleProgress * 1.2);

                // Smooth alpha fade
                const alpha = Math.max(0, 1 - easing.easeInQuad(rawProgress));

                // Smooth rotation with easing
                const rotation = easing.easeOutQuad(rawProgress) * Math.PI * 1.5;

                // Float upward as dying
                const floatY = monster.y - easing.easeOutQuad(rawProgress) * 20;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(monster.x, floatY);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Draw dying monster with flash effect
                const flashIntensity = Math.sin(monster.deathFrame * 0.5) * 0.3 + 0.7;
                ctx.fillStyle = monster.color;
                ctx.globalAlpha = alpha * flashIntensity;
                ctx.fillRect(-monster.size/2, -monster.size/2, monster.size, monster.size);

                ctx.restore();
            }

            // Draw player - generic adventurer with animations
            const playerY = game.player.y;
            const isMoving = game.player.isMoving;
            const walkFrame = game.player.walkFrame;
            const facingLeft = game.player.facingLeft;
            const isAttacking = game.player.isAttacking;
            const isDying = game.player.isDying;

            // Update attack animation with smoother timing
            if (isAttacking) {
                game.player.attackFrame++;
                if (game.player.attackFrame > 25) {
                    game.player.isAttacking = false;
                }
            }

            // Update player flash timer
            if (game.player.flashTimer > 0) {
                game.player.flashTimer--;
            }

            // Update level up animation
            if (game.player.levelUpAnim > 0) {
                game.player.levelUpAnim--;
            }

            // Draw player shadow - very visible
            if (!isDying) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.beginPath();
                ctx.ellipse(game.player.x, playerY + 24, 16, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.save();

            // Death animation with smooth easing
            if (isDying) {
                const rawProgress = game.player.deathFrame / 60;
                const deathProgress = easing.easeInQuad(rawProgress);
                const alphaProgress = easing.easeOutQuad(rawProgress);

                ctx.globalAlpha = Math.max(0, 1 - alphaProgress);
                ctx.translate(game.player.x, playerY);
                ctx.rotate(easing.easeInOutQuad(rawProgress) * Math.PI * 2);
                const scale = Math.max(0.1, 1 - deathProgress * 0.8);
                ctx.scale(scale, scale);
                ctx.translate(-game.player.x, -playerY);
            }

            // Smooth flash effect when taking damage (sine wave for smooth pulsing)
            if (game.player.flashTimer > 0) {
                const flashProgress = game.player.flashTimer / 15;
                const flashAlpha = 0.4 + Math.sin(game.player.flashTimer * 0.8) * 0.3;
                ctx.globalAlpha *= flashAlpha;
            }

            // Flip horizontally if facing left
            if (facingLeft) {
                ctx.translate(game.player.x, 0);
                ctx.scale(-1, 1);
                ctx.translate(-game.player.x, 0);
            }

            // Smooth walking bob using sine with easing
            const walkCycle = easing.easeInOutSine((Math.sin(walkFrame * 1.8) + 1) / 2);
            const walkBob = isMoving ? (walkCycle - 0.5) * 3 : 0;
            const adjustedY = playerY + walkBob;

            // Smooth leg animation using eased sine waves
            const legCycle = Math.sin(walkFrame * 1.5);
            const leftLegOffset = isMoving ? easing.easeInOutSine((legCycle + 1) / 2) * 5 - 2.5 : 0;
            const rightLegOffset = isMoving ? easing.easeInOutSine((-legCycle + 1) / 2) * 5 - 2.5 : 0;

            // Smooth attack arm swing with easing - TOP TO BOTTOM slash
            let attackSwing = 0;
            let attackArmRaise = 0;
            if (isAttacking) {
                const attackProgress = game.player.attackFrame / 25;
                // Wind-up (raise arm), then slash down
                if (attackProgress < 0.15) {
                    // Wind-up: raise arm
                    const windUp = easing.easeOutQuad(attackProgress / 0.15);
                    attackSwing = -30 * windUp;  // Rotate arm back/up
                    attackArmRaise = -8 * windUp;  // Raise arm position
                } else if (attackProgress < 0.4) {
                    // Slash down: fast swing from top to bottom
                    const slash = easing.easeOutQuad((attackProgress - 0.15) / 0.25);
                    attackSwing = -30 + 90 * slash;  // Swing from -30 to +60
                    attackArmRaise = -8 + 12 * slash;  // Move arm down
                } else {
                    // Recovery: return to neutral
                    const recovery = easing.easeInOutQuad((attackProgress - 0.4) / 0.6);
                    attackSwing = 60 * (1 - recovery);
                    attackArmRaise = 4 * (1 - recovery);
                }
            }

            // Head
            ctx.fillStyle = '#FFDBAC';
            ctx.fillRect(game.player.x - 5, adjustedY - 10, 10, 10);

            // Hair
            ctx.fillStyle = '#4a2c2a';
            ctx.fillRect(game.player.x - 6, adjustedY - 12, 12, 3);

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(game.player.x - 3, adjustedY - 6, 2, 2);
            ctx.fillRect(game.player.x + 1, adjustedY - 6, 2, 2);

            // Armor chest - silver/gray
            ctx.fillStyle = '#a8a8a8';
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 14, 10);

            // Armor highlight
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 14, 2);
            ctx.fillRect(game.player.x - 7, adjustedY + 1, 2, 10);

            // Belt
            ctx.fillStyle = '#654321';
            ctx.fillRect(game.player.x - 7, adjustedY + 10, 14, 3);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(game.player.x - 2, adjustedY + 10, 4, 3);

            // Get weapon info for animation decisions
            const weapon = game.player.equippedWeapon;
            const weaponStyle = weapon ? weapon.style : null;
            const isShooting = game.player.isShooting;
            const isStaffWeapon = weaponStyle === 'staff' || weaponStyle === 'fire_staff';

            // Back arm (behind body) - both arms raised when shooting
            ctx.fillStyle = '#7a7a7a';
            if (isShooting && isStaffWeapon) {
                // Back arm raised for casting
                ctx.save();
                ctx.translate(game.player.x - 8, adjustedY + 4);
                const castProgress = game.player.shootFrame / 30;
                const armRaise = Math.sin(castProgress * Math.PI) * 40;
                ctx.rotate((armRaise * Math.PI) / 180);
                ctx.fillRect(-1, -4, 3, 8);
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(-1, 4, 3, 3);
                ctx.restore();
            } else {
                ctx.fillRect(game.player.x - 10, adjustedY + 2, 3, 8);
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(game.player.x - 10, adjustedY + 10, 3, 3);
            }

            // Front arm with attack/shooting animation
            ctx.save();
            if (isShooting && isStaffWeapon) {
                // Shooting pose - arm extended forward
                const shootProgress = game.player.shootFrame / 30;
                const recoil = shootProgress < 0.2 ? easing.easeOutQuad(shootProgress / 0.2) * 15 :
                              easing.easeInQuad(1 - (shootProgress - 0.2) / 0.8) * 15;
                ctx.translate(game.player.x + 8 + recoil, adjustedY + 2);
                ctx.rotate((-70 * Math.PI) / 180);  // Arm pointing forward
            } else {
                // Top-to-bottom slash: arm raises up then swings down
                ctx.translate(game.player.x + 8, adjustedY + 6 + attackArmRaise);
                ctx.rotate((-attackSwing * Math.PI) / 180);
            }
            ctx.fillStyle = '#8a8a8a';
            ctx.fillRect(-1, -4, 3, 8);
            ctx.fillStyle = '#FFDBAC';
            ctx.fillRect(-1, 4, 3, 3);

            const showWeapon = isAttacking || isShooting || game.player.attackCooldown > 20 || weapon;

            if (showWeapon) {
                if (!weaponStyle) {
                    // REALISTIC BOXING ANIMATION - Jab/Cross with wind-up
                    const punchProgress = game.player.attackFrame / 25;

                    // Calculate punch direction toward enemy
                    const punchAngle = game.player.facingAngle || (facingLeft ? Math.PI : 0);
                    const localAngle = punchAngle - (facingLeft ? Math.PI : 0);

                    // Animation phases: wind-up (0-0.15), punch (0.15-0.4), hold (0.4-0.6), return (0.6-1.0)
                    let armExtend = 0;
                    let armAngleOffset = 0;
                    let fistRotation = 0;
                    let shoulderPull = 0;

                    // Max Extension = 8 Pixel (passend zur 28px Faust-Reichweite)
                    const maxExtend = 8;

                    if (isAttacking) {
                        if (punchProgress < 0.15) {
                            // Wind-up: Arm zieht zur√ºck, Schulter dreht
                            const windUp = easing.easeOutQuad(punchProgress / 0.15);
                            armExtend = -3 * windUp;
                            armAngleOffset = -0.3 * windUp;
                            shoulderPull = 2 * windUp;
                        } else if (punchProgress < 0.4) {
                            // Punch: Schnelle Streckung mit K√∂rperdrehung
                            const punch = easing.easeOutQuad((punchProgress - 0.15) / 0.25);
                            armExtend = -3 + (maxExtend + 3) * punch;
                            armAngleOffset = -0.3 + 0.4 * punch;
                            fistRotation = 0.2 * punch;
                            shoulderPull = 2 - 3 * punch;
                        } else if (punchProgress < 0.6) {
                            // Hold: Volle Streckung (nur bis Reichweitengrenze)
                            armExtend = maxExtend;
                            armAngleOffset = 0.1;
                            fistRotation = 0.2;
                            shoulderPull = -1;
                        } else {
                            // Return: Arm zur√ºck in Grundstellung
                            const ret = easing.easeInQuad((punchProgress - 0.6) / 0.4);
                            armExtend = maxExtend * (1 - ret);
                            armAngleOffset = 0.1 * (1 - ret);
                            fistRotation = 0.2 * (1 - ret);
                            shoulderPull = -1 * (1 - ret);
                        }
                    }

                    ctx.save();
                    // Schulter-Position mit Bewegung
                    ctx.translate(2 + shoulderPull, 4);
                    ctx.rotate(localAngle + armAngleOffset);

                    // Oberarm
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-2, 0, 4, 6);

                    // Ellbogen-Gelenk
                    ctx.fillStyle = '#E8C8A0';
                    ctx.beginPath();
                    ctx.arc(0, 6, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Unterarm (streckt sich)
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-2, 5, 4, 6 + armExtend);

                    // Faust am Ende mit Rotation
                    ctx.save();
                    ctx.translate(0, 10 + armExtend);
                    ctx.rotate(fistRotation);

                    // Faust-K√∂rper
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-4, 0, 8, 7);

                    // Kn√∂chel (oben)
                    ctx.fillStyle = '#E8C8A0';
                    ctx.fillRect(-4, 0, 8, 2);

                    // Finger-Linien
                    ctx.fillStyle = '#D4B090';
                    ctx.fillRect(-2, 2, 1, 4);
                    ctx.fillRect(0, 2, 1, 4);
                    ctx.fillRect(2, 2, 1, 4);

                    // Daumen (seitlich)
                    ctx.fillStyle = '#FFDBAC';
                    ctx.fillRect(-5, 2, 2, 4);

                    ctx.restore();

                    // Impact-Effekt beim Treffen
                    if (isAttacking && punchProgress > 0.2 && punchProgress < 0.5) {
                        const impactIntensity = 1 - Math.abs(punchProgress - 0.35) / 0.15;
                        ctx.globalAlpha = impactIntensity * 0.8;

                        // Schockwellen
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            const waveRadius = 8 + i * 6 + armExtend;
                            ctx.beginPath();
                            ctx.arc(0, 12 + armExtend, waveRadius * impactIntensity, -0.5, 0.5);
                            ctx.stroke();
                        }

                        // Bewegungsunsch√§rfe
                        ctx.fillStyle = 'rgba(255, 219, 172, 0.4)';
                        for (let i = 1; i <= 3; i++) {
                            ctx.globalAlpha = (0.3 / i) * impactIntensity;
                            ctx.fillRect(-3, 5 - i * 4, 6, 4);
                        }
                        ctx.globalAlpha = 1;
                    }

                    ctx.restore();
                } else if (weaponStyle === 'fire_staff') {
                    // Fire Staff - shoots fire projectiles
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(1, 3, 2, 22);

                    // Fire orb with shooting effect
                    const shootProgress = isShooting ? game.player.shootFrame / 30 : 0;
                    const orbPulse = isShooting ? 1 + Math.sin(shootProgress * Math.PI * 4) * 0.4 : 1;
                    const orbSize = 6 * orbPulse;

                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = isShooting ? 20 + shootProgress * 15 : 10;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner flame
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // Shooting burst effect
                    if (isShooting && shootProgress < 0.5) {
                        ctx.globalAlpha = 1 - shootProgress * 1.5;
                        // Fire rings expanding
                        for (let ring = 0; ring < 4; ring++) {
                            const ringProgress = shootProgress * 3 - ring * 0.08;
                            if (ringProgress > 0 && ringProgress < 1) {
                                const ringSize = 6 + ringProgress * 30;
                                ctx.strokeStyle = ring % 2 === 0 ? '#ff6600' : '#fbbf24';
                                ctx.lineWidth = 3 - ringProgress * 2;
                                ctx.beginPath();
                                ctx.arc(2, 26, ringSize, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        // Fire particles
                        for (let i = 0; i < 8; i++) {
                            const sparkAngle = (i / 8) * Math.PI * 2 + shootProgress * 8;
                            const sparkDist = 10 + shootProgress * 25;
                            ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ef4444';
                            ctx.beginPath();
                            ctx.arc(2 + Math.cos(sparkAngle) * sparkDist,
                                   26 + Math.sin(sparkAngle) * sparkDist,
                                   3 - shootProgress * 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    ctx.shadowBlur = 0;
                } else if (weaponStyle === 'flame') {
                    // Flame Sword
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff6600';
                    ctx.fillRect(0, 6, 3, 18);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(0, 8, 3, 12);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-2, 5, 7, 2);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 3, 3, 3);
                } else if (weaponStyle === 'dagger' || weaponStyle === 'poison_dagger') {
                    // Dagger
                    const color = weaponStyle === 'poison_dagger' ? '#22c55e' : '#C0C0C0';
                    ctx.fillStyle = color;
                    ctx.fillRect(1, 6, 2, 10);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 3, 4, 4);
                } else if (weaponStyle === 'axe' || weaponStyle === 'battleaxe') {
                    // Axe - Klinge am Ende des Schafts
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 18);  // Schaft
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(-3, 16, 8, 6);  // Axtkopf am Ende
                    ctx.fillRect(-4, 17, 2, 4);  // Axtklinge Erweiterung
                    // Glanzlicht
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(-3, 16, 8, 2);
                } else if (weaponStyle === 'hammer') {
                    // War Hammer - Kopf am Ende des Schafts
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 18);  // Schaft
                    ctx.fillStyle = '#606060';
                    ctx.fillRect(-3, 18, 10, 8);  // Hammerkopf am Ende
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(-3, 18, 10, 2);  // Glanzlicht
                } else if (weaponStyle === 'spear' || weaponStyle === 'halberd') {
                    // Spear / Halberd - tip at end
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(1, 4, 2, 24);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(2, 28);  // Tip at end of shaft
                    ctx.lineTo(-1, 22);
                    ctx.lineTo(5, 22);
                    ctx.closePath();
                    ctx.fill();
                    if (weaponStyle === 'halberd') {
                        ctx.fillRect(-3, 20, 8, 3);
                    }
                } else if (weaponStyle === 'staff') {
                    // Magic Staff - orb at end
                    ctx.fillStyle = '#5c3d2e';
                    ctx.fillRect(1, 3, 2, 22);

                    // Staff orb with shooting effect
                    const shootProgress = isShooting ? game.player.shootFrame / 30 : 0;
                    const orbPulse = isShooting ? 1 + Math.sin(shootProgress * Math.PI * 4) * 0.3 : 1;
                    const orbSize = 5 * orbPulse;

                    ctx.fillStyle = '#c084fc';
                    ctx.shadowBlur = isShooting ? 15 + shootProgress * 10 : 6;
                    ctx.shadowColor = '#c084fc';
                    ctx.beginPath();
                    ctx.arc(2, 26, orbSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Shooting burst effect
                    if (isShooting && shootProgress < 0.4) {
                        ctx.globalAlpha = 1 - shootProgress * 2;
                        // Magic rings expanding
                        for (let ring = 0; ring < 3; ring++) {
                            const ringProgress = shootProgress * 3 - ring * 0.1;
                            if (ringProgress > 0 && ringProgress < 1) {
                                const ringSize = 5 + ringProgress * 25;
                                ctx.strokeStyle = '#c084fc';
                                ctx.lineWidth = 2 - ringProgress;
                                ctx.beginPath();
                                ctx.arc(2, 26, ringSize, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        // Sparkles
                        for (let i = 0; i < 6; i++) {
                            const sparkAngle = (i / 6) * Math.PI * 2 + shootProgress * 5;
                            const sparkDist = 8 + shootProgress * 20;
                            ctx.fillStyle = '#e9d5ff';
                            ctx.beginPath();
                            ctx.arc(2 + Math.cos(sparkAngle) * sparkDist,
                                   26 + Math.sin(sparkAngle) * sparkDist,
                                   2 - shootProgress * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    ctx.shadowBlur = 0;
                } else if (weaponStyle === 'claw') {
                    // Demon Claw - claws extend outward
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-1, 5, 6, 5);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-2, 10, 2, 10);
                    ctx.fillRect(1, 10, 2, 12);
                    ctx.fillRect(4, 10, 2, 10);
                } else if (weaponStyle === 'bone') {
                    // Bone Sword
                    ctx.fillStyle = '#e2e8f0';
                    ctx.fillRect(0, 6, 3, 16);
                    ctx.fillRect(-2, 6, 2, 4);
                    ctx.fillRect(3, 6, 2, 4);
                    ctx.fillStyle = '#94a3b8';
                    ctx.fillRect(0, 3, 3, 4);
                } else if (weaponStyle === 'rusty_sword') {
                    // Rusty Sword - corroded and worn
                    // Blade with rust spots
                    ctx.fillStyle = '#8B7355';  // Rusty brown-gray
                    ctx.fillRect(-1, 6, 4, 20);
                    // Rust patches
                    ctx.fillStyle = '#A0522D';  // Sienna (rust color)
                    ctx.fillRect(-1, 8, 2, 3);
                    ctx.fillRect(1, 14, 2, 4);
                    ctx.fillRect(-1, 20, 3, 2);
                    // Dark rust/pitting
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(0, 10, 1, 2);
                    ctx.fillRect(2, 17, 1, 2);
                    ctx.fillRect(-1, 22, 1, 2);
                    // Worn tip
                    ctx.fillStyle = '#8B7355';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 28);  // Shorter, chipped tip
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Dull edge highlight
                    ctx.fillStyle = '#9B8B7B';
                    ctx.fillRect(-1, 8, 1, 12);
                    // Old worn crossguard
                    ctx.fillStyle = '#5C4033';  // Tarnished
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#6B5033';
                    ctx.fillRect(-3, 4, 8, 1);
                    // Worn leather grip
                    ctx.fillStyle = '#3a2718';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#4a3020';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Dented pommel
                    ctx.fillStyle = '#5C4033';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (weaponStyle === 'iron_sword') {
                    // Iron Sword - solid iron blade
                    // Blade with slight gray tone
                    ctx.fillStyle = '#9CA3AF';  // Iron gray
                    ctx.fillRect(-1, 6, 4, 20);
                    // Edge highlight
                    ctx.fillStyle = '#B8C0CC';
                    ctx.fillRect(-1, 8, 1, 16);
                    // Fuller (blood groove)
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(0, 8, 1, 14);
                    // Tip
                    ctx.fillStyle = '#9CA3AF';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 30);
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Simple iron crossguard
                    ctx.fillStyle = '#4B5563';
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(-3, 4, 8, 1);
                    // Leather wrapped grip
                    ctx.fillStyle = '#5C4033';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#6B5043';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Iron pommel
                    ctx.fillStyle = '#4B5563';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (weaponStyle === 'steel_sword') {
                    // Steel Sword - polished steel blade
                    // Bright polished blade
                    ctx.fillStyle = '#E5E7EB';  // Bright steel
                    ctx.fillRect(-1, 6, 4, 20);
                    // Bright edge highlight
                    ctx.fillStyle = '#F3F4F6';
                    ctx.fillRect(-1, 8, 1, 16);
                    // Fuller with shine
                    ctx.fillStyle = '#9CA3AF';
                    ctx.fillRect(0, 8, 1, 14);
                    // Sharp tip
                    ctx.fillStyle = '#E5E7EB';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 31);  // Longer tip
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Decorative steel crossguard
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(-5, 4, 12, 3);
                    ctx.fillStyle = '#9CA3AF';
                    ctx.fillRect(-4, 4, 10, 1);
                    // Blue leather grip
                    ctx.fillStyle = '#1E3A5F';
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#2B4A6F';
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);
                    // Steel pommel with gem
                    ctx.fillStyle = '#6B7280';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#3B82F6';  // Blue gem
                    ctx.beginPath();
                    ctx.arc(1, -1, 1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Realistic Sword Design
                    // Klinge (Blade) mit Hohlkehle
                    ctx.fillStyle = '#D8D8D8';  // Helle Klingenseite
                    ctx.fillRect(-1, 6, 4, 20);
                    ctx.fillStyle = '#A8A8A8';  // Dunkle Klingenseite (Tiefe)
                    ctx.fillRect(0, 7, 1, 18);
                    // Klingenspitze
                    ctx.fillStyle = '#D8D8D8';
                    ctx.beginPath();
                    ctx.moveTo(-1, 26);
                    ctx.lineTo(1, 30);
                    ctx.lineTo(3, 26);
                    ctx.fill();
                    // Schneide Glanz
                    ctx.fillStyle = '#F0F0F0';
                    ctx.fillRect(-1, 8, 1, 16);

                    // Parierstange (Crossguard)
                    ctx.fillStyle = '#B8860B';  // Dunkles Gold
                    ctx.fillRect(-4, 4, 10, 3);
                    ctx.fillStyle = '#DAA520';  // Glanz
                    ctx.fillRect(-3, 4, 8, 1);

                    // Griff (Handle) mit Wicklung
                    ctx.fillStyle = '#4a3728';  // Dunkles Leder
                    ctx.fillRect(0, 0, 3, 6);
                    ctx.fillStyle = '#5c4033';  // Leder Streifen
                    ctx.fillRect(0, 1, 3, 1);
                    ctx.fillRect(0, 3, 3, 1);

                    // Knauf (Pommel)
                    ctx.fillStyle = '#B8860B';
                    ctx.beginPath();
                    ctx.arc(1, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#DAA520';
                    ctx.beginPath();
                    ctx.arc(0.5, -1.5, 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // WEAPON SWING TRAIL EFFECT (for all weapons when attacking)
                if (isAttacking && weaponStyle) {
                    const swingProgress = game.player.attackFrame / 25;
                    if (swingProgress < 0.5) {
                        // Determine trail color based on weapon
                        let trailColor = 'rgba(200, 200, 200, ';  // Default silver
                        if (weaponStyle === 'flame' || weaponStyle === 'fire_staff') {
                            trailColor = 'rgba(255, 100, 0, ';
                        } else if (weaponStyle === 'poison_dagger') {
                            trailColor = 'rgba(34, 197, 94, ';
                        } else if (weaponStyle === 'staff') {
                            trailColor = 'rgba(192, 132, 252, ';
                        } else if (weaponStyle === 'claw') {
                            trailColor = 'rgba(239, 68, 68, ';
                        }

                        // Draw swing arc trail
                        ctx.globalAlpha = 0.6 - swingProgress;
                        for (let i = 0; i < 5; i++) {
                            const trailAlpha = (1 - i / 5) * (0.4 - swingProgress * 0.6);
                            ctx.fillStyle = trailColor + trailAlpha + ')';
                            const trailAngle = (swingProgress * 0.6 - i * 0.08) * Math.PI;
                            const trailDist = 15 + (weaponStyle === 'spear' || weaponStyle === 'halberd' ? 10 : 0);
                            ctx.beginPath();
                            ctx.arc(1, 10, trailDist + i * 2, -Math.PI/4, Math.PI/4);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            }
            ctx.restore();

            // Legs with walking animation
            ctx.fillStyle = '#2c2c2c';
            ctx.fillRect(game.player.x - 5, adjustedY + 13 + leftLegOffset, 4, 8);
            ctx.fillRect(game.player.x + 1, adjustedY + 13 + rightLegOffset, 4, 8);

            // Boots
            ctx.fillStyle = '#654321';
            ctx.fillRect(game.player.x - 6, adjustedY + 21 + leftLegOffset, 5, 4);
            ctx.fillRect(game.player.x + 1, adjustedY + 21 + rightLegOffset, 5, 4);

            ctx.restore();

            // Level-up aura effect with smooth easing
            if (game.player.levelUpAnim > 0) {
                const rawProgress = 1 - (game.player.levelUpAnim / 60);
                const auraProgress = easing.easeOutQuad(rawProgress);
                const auraRadius = 20 + easing.easeOutBack(Math.min(rawProgress * 1.2, 1)) * 50;
                const auraAlpha = easing.easeInQuad(1 - rawProgress);

                ctx.save();

                // Multiple expanding rings
                for (let ring = 0; ring < 3; ring++) {
                    const ringDelay = ring * 0.15;
                    const ringProgress = Math.max(0, auraProgress - ringDelay);
                    const ringRadius = 20 + easing.easeOutQuad(ringProgress) * (40 + ring * 15);
                    const ringAlpha = easing.easeInQuad(Math.max(0, 1 - ringProgress * 1.3));

                    ctx.globalAlpha = ringAlpha * 0.4;
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 4 - ring;
                    ctx.beginPath();
                    ctx.arc(game.player.x, playerY + 5, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Inner glow pulse
                ctx.globalAlpha = auraAlpha * 0.4;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, auraRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // Drinking animation
            if (game.player.isDrinking && !game.player.isDying) {
                const drinkProgress = game.player.drinkFrame / 45;
                const potionColor = game.player.drinkColor || '#ff1493';

                ctx.save();
                ctx.translate(game.player.x, playerY);

                // Animation Phasen: Flasche heben (0-0.3), trinken (0.3-0.7), absetzen (0.7-1.0)
                let bottleX = 12;
                let bottleY = 0;
                let bottleRotation = 0;
                let bottleScale = 1;
                let liquidLevel = 1;

                if (drinkProgress < 0.3) {
                    // Flasche zum Mund heben
                    const lift = easing.easeOutQuad(drinkProgress / 0.3);
                    bottleX = 12 - 8 * lift;
                    bottleY = -5 * lift;
                    bottleRotation = -0.3 * lift;
                } else if (drinkProgress < 0.7) {
                    // Trinken - Flasche kippen
                    const drink = (drinkProgress - 0.3) / 0.4;
                    bottleX = 4;
                    bottleY = -5 - 3 * Math.sin(drink * Math.PI);
                    bottleRotation = -0.3 - 0.8 * easing.easeInOutQuad(drink);
                    liquidLevel = 1 - drink;
                } else {
                    // Flasche absetzen und verschwinden
                    const put = easing.easeInQuad((drinkProgress - 0.7) / 0.3);
                    bottleX = 4 + 8 * put;
                    bottleY = -5 + 10 * put;
                    bottleRotation = -1.1 + 0.5 * put;
                    bottleScale = 1 - put * 0.8;
                    liquidLevel = 0;
                }

                // Flasche zeichnen
                ctx.save();
                ctx.translate(bottleX, bottleY);
                ctx.rotate(bottleRotation);
                ctx.scale(bottleScale, bottleScale);

                // Flaschenhals
                ctx.fillStyle = '#333';
                ctx.fillRect(-2, -12, 4, 5);

                // Flaschenk√∂rper
                ctx.fillStyle = '#222';
                ctx.fillRect(-5, -7, 10, 14);

                // Fl√ºssigkeit
                if (liquidLevel > 0) {
                    ctx.fillStyle = potionColor;
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = potionColor;
                    const liquidHeight = 10 * liquidLevel;
                    ctx.fillRect(-4, 7 - liquidHeight, 8, liquidHeight);
                    ctx.shadowBlur = 0;
                }

                // Glanzeffekt
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(-4, -6, 3, 10);

                ctx.restore();

                // Heilungs-Partikel w√§hrend des Trinkens
                if (drinkProgress > 0.3 && drinkProgress < 0.7 && Math.random() < 0.3) {
                    game.particles.push({
                        x: game.player.x + (Math.random() - 0.5) * 20,
                        y: playerY + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -1 - Math.random() * 2,
                        color: potionColor,
                        life: 25,
                        size: 3 + Math.random() * 2
                    });
                }

                // Heilungs-Aura
                if (drinkProgress > 0.3 && drinkProgress < 0.8) {
                    const auraIntensity = Math.sin((drinkProgress - 0.3) / 0.5 * Math.PI);
                    ctx.globalAlpha = auraIntensity * 0.3;
                    ctx.fillStyle = potionColor;
                    ctx.beginPath();
                    ctx.arc(0, 5, 25 + auraIntensity * 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // +HP Anzeige
                if (drinkProgress > 0.4 && drinkProgress < 0.9) {
                    const textAlpha = drinkProgress < 0.65 ? 1 : 1 - (drinkProgress - 0.65) / 0.25;
                    const textRise = (drinkProgress - 0.4) * 40;
                    ctx.globalAlpha = textAlpha;
                    ctx.fillStyle = '#22c55e';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 14px Courier New';
                    ctx.textAlign = 'center';
                    ctx.strokeText(`+${game.player.drinkHeal || 50}`, 0, -25 - textRise);
                    ctx.fillText(`+${game.player.drinkHeal || 50}`, 0, -25 - textRise);
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }

            // Player HP bar (√ºber dem Spieler)
            if (!game.player.isDying) {
                const playerBarWidth = 50;
                const playerBarHeight = 6;
                const playerBarY = playerY - 35;

                // Schwarzer Hintergrund
                ctx.fillStyle = '#000000';
                ctx.fillRect(game.player.x - playerBarWidth/2 - 1, playerBarY - 1, playerBarWidth + 2, playerBarHeight + 2);

                // HP Leiste
                const playerHpPercent = game.player.hp / game.player.maxHp;
                const playerHpColor = playerHpPercent > 0.5 ? '#22c55e' : playerHpPercent > 0.25 ? '#f59e0b' : '#ef4444';
                ctx.fillStyle = playerHpColor;
                ctx.fillRect(game.player.x - playerBarWidth/2, playerBarY, playerHpPercent * playerBarWidth, playerBarHeight);

                // HP Zahlen
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px "Courier New"';
                ctx.textAlign = 'center';
                const playerHpText = `${Math.ceil(game.player.hp)}/${game.player.maxHp}`;
                ctx.strokeText(playerHpText, game.player.x, playerBarY - 4);
                ctx.fillText(playerHpText, game.player.x, playerBarY - 4);
            }

            // Spawn protection shield effect
            if (game.player.spawnProtection > 0) {
                ctx.save();
                const shieldPulse = Math.sin(game.animCounter * 0.15) * 0.3 + 0.7;
                const shieldRadius = 30 + Math.sin(game.animCounter * 0.1) * 3;

                // Outer shield ring
                ctx.globalAlpha = shieldPulse * 0.6;
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner glow
                ctx.globalAlpha = shieldPulse * 0.2;
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath();
                ctx.arc(game.player.x, playerY + 5, shieldRadius - 5, 0, Math.PI * 2);
                ctx.fill();

                // Timer display (seconds remaining) - positioned above HP bar
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#60a5fa';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(game.player.spawnProtection / 60);
                ctx.fillText(`üõ°Ô∏è ${secondsLeft}s`, game.player.x, playerY - 52);

                ctx.restore();
            }

            // Attack range indicator (replaces spinning effect)
            if (game.player.attackCooldown > 0) {
                const weapon = game.player.equippedWeapon;
                const weaponSpeed = weapon ? (weapon.speed || 1) : 1;
                const maxCooldown = Math.floor(30 * weaponSpeed);
                const progress = Math.max(0, Math.min(1, 1 - (game.player.attackCooldown / maxCooldown)));
                const weaponRange = weapon ? (weapon.range || 80) : 28; // Faust = 28 (realistisch kurz)
                const weaponStyle = weapon ? weapon.style : 'fist';

                // Farbe basierend auf Waffentyp
                let rangeColor = '#fbbf24'; // Standard gold
                if (weaponStyle === 'flame' || weaponStyle === 'fire_staff') {
                    rangeColor = '#ff6b35';
                } else if (weaponStyle === 'staff') {
                    rangeColor = '#c084fc';
                } else if (weaponStyle === 'poison_dagger') {
                    rangeColor = '#22c55e';
                } else if (weaponStyle === 'dagger' || weaponStyle === 'claw') {
                    rangeColor = '#94a3b8';
                } else if (weaponStyle === 'spear' || weaponStyle === 'halberd') {
                    rangeColor = '#60a5fa';
                } else if (weaponStyle === 'hammer' || weaponStyle === 'axe' || weaponStyle === 'battleaxe') {
                    rangeColor = '#f97316';
                } else if (weaponStyle === 'fist') {
                    rangeColor = '#fcd34d';
                }

                ctx.save();
                ctx.translate(game.player.x, game.player.y);

                // Reichweiten-Kreis mit F√ºlleffekt
                const alpha = 0.3 - progress * 0.25;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = rangeColor;
                ctx.beginPath();
                ctx.arc(0, 0, weaponRange * progress, 0, Math.PI * 2);
                ctx.fill();

                // √Ñu√üerer Reichweiten-Ring
                ctx.globalAlpha = 0.6 - progress * 0.4;
                ctx.strokeStyle = rangeColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, weaponRange, 0, Math.PI * 2);
                ctx.stroke();

                // Angriffsrichtungs-Indikator (Bogen in Blickrichtung)
                const facingAngle = game.player.facingAngle || 0;
                ctx.globalAlpha = 0.5 - progress * 0.3;
                ctx.fillStyle = rangeColor;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, weaponRange * 0.8, facingAngle - Math.PI/4, facingAngle + Math.PI/4);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Draw particles with varied sizes
            for (const p of game.particles) {
                const alpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;

                const size = p.size || 3;
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
            }

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // End screen shake transform
            ctx.restore();

            // Room transition overlay with smooth easing
            if (game.roomTransition > 0) {
                const rawProgress = game.roomTransition / 30;
                const fadeAlpha = easing.easeInOutQuad(rawProgress);
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                game.roomTransition--;
            }

            // Draw in-game HUD (Minecraft style)
            drawHUD();
        }

        function drawHUD() {
            const padding = 10;
            const barWidth = 150;
            const barHeight = 16;

            ctx.save();

            // Semi-transparent background for top-left stats
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(padding - 5, padding - 5, 170, 95);

            // HP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(padding, padding, barWidth, barHeight);
            const hpPercent = game.player.hp / game.player.maxHp;
            const hpColor = hpPercent > 0.5 ? '#22c55e' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
            ctx.fillStyle = hpColor;
            ctx.fillRect(padding + 2, padding + 2, (barWidth - 4) * hpPercent, barHeight - 4);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(game.player.hp)}/${game.player.maxHp}`, padding + barWidth / 2, padding + 12);

            // XP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(padding, padding + barHeight + 4, barWidth, barHeight);
            const xpPercent = game.player.xp / game.player.xpToNext;
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(padding + 2, padding + barHeight + 6, (barWidth - 4) * xpPercent, barHeight - 4);
            ctx.fillStyle = '#fff';
            ctx.fillText(`LVL ${game.player.level}`, padding + barWidth / 2, padding + barHeight + 16);

            // Stats text
            ctx.font = '11px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`Gold: ${game.player.gold}`, padding, padding + barHeight * 2 + 16);
            ctx.fillStyle = '#ef4444';
            ctx.fillText(`ATK: ${game.player.attack}`, padding, padding + barHeight * 2 + 30);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText(`DEF: ${game.player.defense}`, padding + 70, padding + barHeight * 2 + 30);

            // Room indicator (top-right)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(canvas.width - padding - 95, padding - 5, 100, 50);
            ctx.font = 'bold 12px "Courier New"';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#fff';
            ctx.fillText(`Level ${game.currentRoom}`, canvas.width - padding, padding + 12);
            ctx.fillStyle = '#e94560';
            ctx.fillText(`Monster: ${game.monsters.length}`, canvas.width - padding, padding + 28);
            // Boss indicator
            if (game.currentRoom % 10 === 0 && game.monsters.length > 0) {
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('BOSS!', canvas.width - padding, padding + 44);
            }

            // Equipped items info (bottom-left)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(padding - 5, canvas.height - 65, 145, 60);
            ctx.font = 'bold 10px "Courier New"';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ff6b6b';
            ctx.fillText('Waffe:', padding, canvas.height - 48);
            ctx.fillStyle = '#fff';
            const weaponName = game.player.equippedWeapon ? game.player.equippedWeapon.name : 'F√§uste';
            ctx.fillText(weaponName, padding + 45, canvas.height - 48);
            ctx.fillStyle = '#4ecdc4';
            ctx.fillText('R√ºstung:', padding, canvas.height - 34);
            ctx.fillStyle = '#fff';
            const armorName = game.player.equippedArmor ? game.player.equippedArmor.name : 'Keine';
            ctx.fillText(armorName, padding + 55, canvas.height - 34);

            // Show inventory count
            ctx.fillStyle = '#95e1d3';
            ctx.fillText(`Inventar: ${game.player.inventory.length} Items`, padding, canvas.height - 18);
            if (game.player.inventory.length > 0) {
                ctx.fillStyle = '#888';
                ctx.font = '8px "Courier New"';
                ctx.fillText('(1-9 benutzen)', padding, canvas.height - 8);
            }

            // Inventory quick bar (bottom center) - improved design
            const slotSize = 32;
            const slotGap = 4;
            const numSlots = Math.max(5, Math.min(9, game.player.inventory.length || 5));
            const invBarWidth = numSlots * (slotSize + slotGap) + slotGap;
            const invBarX = canvas.width / 2 - invBarWidth / 2;
            const invBarY = canvas.height - 52;

            // Bar background with gradient effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(invBarX - 2, invBarY - 2, invBarWidth + 4, slotSize + 18);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(invBarX - 2, invBarY - 2, invBarWidth + 4, slotSize + 18);

            // Draw inventory slots
            for (let i = 0; i < numSlots; i++) {
                const slotX = invBarX + slotGap + i * (slotSize + slotGap);
                const slotY = invBarY + 2;
                const item = game.player.inventory[i];

                // Slot background with border
                const hasItem = item !== undefined;
                ctx.fillStyle = hasItem ? '#2a2a3a' : '#1a1a2a';
                ctx.fillRect(slotX, slotY, slotSize, slotSize);

                // Slot border (highlighted if has item)
                ctx.strokeStyle = hasItem ? '#555' : '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(slotX, slotY, slotSize, slotSize);

                // Inner highlight
                if (hasItem) {
                    ctx.strokeStyle = '#3a3a4a';
                    ctx.strokeRect(slotX + 1, slotY + 1, slotSize - 2, slotSize - 2);
                }

                if (item) {
                    const cx = slotX + slotSize / 2;
                    const cy = slotY + slotSize / 2;
                    const style = item.style || '';

                    // Draw detailed item icons based on type and style
                    if (item.type === 'weapon') {
                        ctx.save();
                        ctx.translate(cx, cy);

                        if (style === 'flame' || style === 'fire_staff') {
                            // Fire weapon - glowing sword
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#ff6600';
                            ctx.fillStyle = '#ef4444';
                            ctx.fillRect(-2, -10, 4, 16);
                            ctx.fillStyle = '#fbbf24';
                            ctx.fillRect(-1, -8, 2, 10);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-3, 6, 6, 4);
                        } else if (style === 'dagger' || style === 'poison_dagger') {
                            // Dagger
                            ctx.fillStyle = style === 'poison_dagger' ? '#22c55e' : '#c0c0c0';
                            ctx.fillRect(-1, -7, 3, 10);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-2, 3, 5, 5);
                        } else if (style === 'axe' || style === 'battleaxe') {
                            // Axe
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -9, 3, 16);
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(-5, -8, 8, 6);
                        } else if (style === 'hammer') {
                            // Hammer
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -6, 3, 14);
                            ctx.fillStyle = '#606060';
                            ctx.fillRect(-4, -8, 9, 7);
                        } else if (style === 'spear' || style === 'halberd') {
                            // Spear
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-1, -8, 2, 18);
                            ctx.fillStyle = '#c0c0c0';
                            ctx.beginPath();
                            ctx.moveTo(0, -12);
                            ctx.lineTo(-3, -6);
                            ctx.lineTo(3, -6);
                            ctx.closePath();
                            ctx.fill();
                        } else if (style === 'staff') {
                            // Magic staff
                            ctx.fillStyle = '#5c3d2e';
                            ctx.fillRect(-1, -8, 3, 18);
                            ctx.fillStyle = '#c084fc';
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = '#c084fc';
                            ctx.beginPath();
                            ctx.arc(0, -10, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        } else if (style === 'claw') {
                            // Demon claw
                            ctx.fillStyle = '#ef4444';
                            ctx.fillRect(-4, 0, 8, 6);
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(-5, -8, 2, 10);
                            ctx.fillRect(-1, -10, 2, 12);
                            ctx.fillRect(3, -8, 2, 10);
                        } else if (style === 'bone') {
                            // Bone sword
                            ctx.fillStyle = '#e2e8f0';
                            ctx.fillRect(-2, -9, 4, 14);
                            ctx.fillRect(-4, -6, 2, 4);
                            ctx.fillRect(2, -6, 2, 4);
                        } else if (style === 'rusty_sword') {
                            // Rusty sword in inventory
                            // Rusty blade
                            ctx.fillStyle = '#8B7355';
                            ctx.fillRect(-2, -12, 4, 16);
                            // Rust patches
                            ctx.fillStyle = '#A0522D';
                            ctx.fillRect(-2, -10, 2, 3);
                            ctx.fillRect(0, -4, 2, 4);
                            ctx.fillRect(-2, 0, 3, 2);
                            // Dark rust/pitting
                            ctx.fillStyle = '#6B4423';
                            ctx.fillRect(-1, -6, 1, 2);
                            ctx.fillRect(1, -2, 1, 2);
                            // Dull edge
                            ctx.fillStyle = '#9B8B7B';
                            ctx.fillRect(-2, -10, 1, 10);
                            // Worn crossguard
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Worn grip
                            ctx.fillStyle = '#3a2718';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#4a3020';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Dented pommel
                            ctx.fillStyle = '#5C4033';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'iron_sword') {
                            // Iron sword in inventory
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#B8C0CC';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#6B7280';
                            ctx.fillRect(-1, -10, 1, 12);
                            // Iron crossguard
                            ctx.fillStyle = '#4B5563';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Leather grip
                            ctx.fillStyle = '#5C4033';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#6B5043';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Iron pommel
                            ctx.fillStyle = '#4B5563';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (style === 'steel_sword') {
                            // Steel sword in inventory - polished
                            ctx.fillStyle = '#E5E7EB';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#F3F4F6';
                            ctx.fillRect(-2, -10, 1, 12);
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-1, -10, 1, 12);
                            // Steel crossguard
                            ctx.fillStyle = '#6B7280';
                            ctx.fillRect(-5, 4, 10, 2);
                            ctx.fillStyle = '#9CA3AF';
                            ctx.fillRect(-4, 4, 8, 1);
                            // Blue leather grip
                            ctx.fillStyle = '#1E3A5F';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#2B4A6F';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Steel pommel with gem
                            ctx.fillStyle = '#6B7280';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#3B82F6';
                            ctx.beginPath();
                            ctx.arc(0, 12, 1, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Realistic sword in inventory
                            // Klinge
                            ctx.fillStyle = '#D8D8D8';
                            ctx.fillRect(-2, -12, 4, 16);
                            ctx.fillStyle = '#A8A8A8';
                            ctx.fillRect(-1, -11, 1, 14);
                            ctx.fillStyle = '#F0F0F0';
                            ctx.fillRect(-2, -10, 1, 12);
                            // Parierstange
                            ctx.fillStyle = '#B8860B';
                            ctx.fillRect(-5, 4, 10, 2);
                            // Griff
                            ctx.fillStyle = '#4a3728';
                            ctx.fillRect(-2, 6, 4, 5);
                            ctx.fillStyle = '#5c4033';
                            ctx.fillRect(-2, 7, 4, 1);
                            ctx.fillRect(-2, 9, 4, 1);
                            // Knauf
                            ctx.fillStyle = '#B8860B';
                            ctx.beginPath();
                            ctx.arc(0, 12, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    } else if (item.type === 'armor') {
                        // Armor - shield icon
                        ctx.save();
                        ctx.translate(cx, cy);
                        const armorStyle = item.style || 'leather';
                        const armorColors = {
                            leather: '#8B4513',
                            chain: '#808080',
                            plate: '#c0c0c0',
                            dragon: '#ef4444'
                        };
                        ctx.fillStyle = armorColors[armorStyle] || '#4169E1';
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-8, -6);
                        ctx.lineTo(-8, 4);
                        ctx.lineTo(0, 10);
                        ctx.lineTo(8, 4);
                        ctx.lineTo(8, -6);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Emblem
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(-3, -3, 6, 6);
                        ctx.restore();
                    } else if (item.type === 'potion') {
                        // Potion bottle
                        ctx.save();
                        ctx.translate(cx, cy);
                        // Bottle
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-2, -10, 4, 4);
                        // Liquid color based on potion type
                        const potionColor = item.heal >= 100 ? '#ff0066' : item.heal >= 50 ? '#ff1493' : '#ff69b4';
                        ctx.fillStyle = potionColor;
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = potionColor;
                        ctx.fillRect(-5, -6, 10, 12);
                        ctx.shadowBlur = 0;
                        // Highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.fillRect(-4, -5, 3, 8);
                        // Cork
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-2, -10, 4, 3);
                        ctx.restore();
                    } else if (item.type === 'bomb') {
                        // Bomb
                        ctx.save();
                        ctx.translate(cx, cy);
                        const isBig = (item.damage || 40) >= 60;
                        // Main bomb body
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(0, 2, isBig ? 9 : 7, 0, Math.PI * 2);
                        ctx.fill();
                        // Highlight
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(-2, 0, isBig ? 4 : 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Fuse
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -6);
                        ctx.quadraticCurveTo(3, -10, 5, -8);
                        ctx.stroke();
                        // Spark
                        ctx.fillStyle = '#ff6600';
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(5, -8, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }

                    // Stack count (bottom right corner)
                    const count = item.count || 1;
                    if (count > 1) {
                        ctx.font = 'bold 10px "Courier New"';
                        ctx.textAlign = 'right';
                        ctx.fillStyle = '#000';
                        ctx.fillText(count, slotX + slotSize - 1, slotY + slotSize - 2);
                        ctx.fillStyle = '#fff';
                        ctx.fillText(count, slotX + slotSize - 2, slotY + slotSize - 3);
                    }
                }

                // Slot number (top left)
                ctx.font = 'bold 9px "Courier New"';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#666';
                ctx.fillText(i + 1, slotX + 2, slotY + 10);
            }

            // Instructions below inventory
            ctx.font = '8px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#666';
            ctx.fillText('1-9: Benutzen | X+1-9: Fallenlassen', canvas.width / 2, canvas.height - 6);

            ctx.restore();
        }

        function gameLoop() {
            game.animCounter++;
            game.player.animFrame += 0.1;

            movePlayer();
            updateMonsters();
            updateDyingMonsters();
            updatePlayerDeath();
            updateProjectiles();
            updateBombs();
            updateParticles();
            updateAbilitiesUI();

            if (game.keys.e && !game.player.isDying) {
                pickupItem();
                game.keys.e = false;
            }

            if (game.player.attackCooldown > 0) {
                game.player.attackCooldown--;
            }

            // Countdown spawn protection
            if (game.player.spawnProtection > 0) {
                game.player.spawnProtection--;
            }

            // Update shooting animation
            if (game.player.isShooting) {
                game.player.shootFrame++;
                if (game.player.shootFrame > 30) {
                    game.player.isShooting = false;
                }
            }

            // Update drinking animation
            if (game.player.isDrinking) {
                game.player.drinkFrame++;
                if (game.player.drinkFrame > 45) {
                    game.player.isDrinking = false;
                }
            }

            draw();
            updateUI();
            if (typeof updateFullHealButton === 'function') updateFullHealButton();

            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        document.addEventListener('keydown', e => {
            if (e.key in game.keys) {
                game.keys[e.key] = true;
                e.preventDefault();
            }

            // Space for attack (single press)
            if (e.key === ' ' && !game.spacePressed) {
                game.spacePressed = true;
                playerAttack();
                e.preventDefault();
            }

            // Number keys for items (X+Number = drop, Number = use)
            // Use keyCode/code for reliable detection
            const numKey = e.code ? e.code.match(/Digit(\d)/) : null;
            const keyNum = numKey ? parseInt(numKey[1]) : (e.key >= '1' && e.key <= '9' ? parseInt(e.key) : 0);

            if (keyNum >= 1 && keyNum <= 9) {
                const slot = keyNum - 1;
                if (game.keys.x) {
                    // X is held, drop item
                    dropItem(slot);
                } else {
                    useItem(slot);
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            if (e.key in game.keys) {
                game.keys[e.key] = false;
            }

            // Reset space press flag
            if (e.key === ' ') {
                game.spacePressed = false;
            }
        });

        document.getElementById('healButton').addEventListener('click', () => {
            if (game.player.gold >= 50) {
                game.player.gold -= 50;
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 50);
                // Start drinking animation
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = 50;
                game.player.drinkColor = '#ff1493';
                sfx.heal();  // Heal sound
                addLog('Heiltrank gekauft! +50 HP', 'loot');
            } else {
                addLog('Nicht genug Gold!', 'combat');
            }
        });

        // Voll-Heal Button - Preis basiert auf fehlenden HP (2 Gold pro fehlender HP, min 10)
        function getFullHealPrice() {
            const missingHp = game.player.maxHp - game.player.hp;
            return Math.max(10, Math.floor(missingHp * 2));
        }

        function updateFullHealButton() {
            const price = getFullHealPrice();
            const priceSpan = document.getElementById('fullHealPrice');
            if (priceSpan) priceSpan.textContent = `${price}G`;
        }

        document.getElementById('fullHealButton').addEventListener('click', () => {
            const price = getFullHealPrice();
            if (game.player.hp >= game.player.maxHp) {
                addLog('Du hast bereits volle HP!', 'info');
                return;
            }
            if (game.player.gold >= price) {
                game.player.gold -= price;
                const healAmount = game.player.maxHp - game.player.hp;
                game.player.hp = game.player.maxHp;
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = healAmount;
                game.player.drinkColor = '#ff69b4';
                sfx.heal();
                addLog(`Voll-Heal f√ºr ${price}G! +${healAmount} HP`, 'loot');
                updateFullHealButton();
            } else {
                addLog(`Nicht genug Gold! (${price} ben√∂tigt)`, 'combat');
            }
        });

        // St√§rke-Boost Button (75 Gold) - +50% Angriff f√ºr 30 Sekunden
        document.getElementById('attackBoostButton').addEventListener('click', () => {
            if (game.player.gold >= 75) {
                game.player.gold -= 75;
                const boostAmount = Math.floor(game.player.attack * 0.5);
                game.player.attackBoost = (game.player.attackBoost || 0) + boostAmount;
                game.player.isDrinking = true;
                game.player.drinkFrame = 0;
                game.player.drinkHeal = 0;
                game.player.drinkColor = '#ff4500';
                sfx.powerUp();
                addLog(`‚öîÔ∏è St√§rkungstrank! +${boostAmount} Angriff f√ºr 30s!`, 'loot');
                setTimeout(() => {
                    game.player.attackBoost = Math.max(0, (game.player.attackBoost || 0) - boostAmount);
                    addLog('‚öîÔ∏è St√§rkungseffekt ist abgelaufen.', 'info');
                }, 30000);
            } else {
                addLog('Nicht genug Gold! (75 ben√∂tigt)', 'combat');
            }
        });

        // Goldschild kaufen Button (75 Gold) - adds a gold shield to inventory
        document.getElementById('defenseBoostButton').addEventListener('click', () => {
            if (game.player.gold >= 75) {
                // Check for empty inventory slot
                let added = false;
                for (let i = 0; i < game.player.inventory.length; i++) {
                    if (!game.player.inventory[i]) {
                        const goldShield = {
                            name: 'Goldschild',
                            defense: 12,
                            type: 'armor',
                            style: 'plate',
                            tier: 'uncommon'
                        };
                        game.player.inventory[i] = goldShield;
                        added = true;
                        break;
                    }
                }
                if (!added && game.player.inventory.length < 9) {
                    const goldShield = {
                        name: 'Goldschild',
                        defense: 12,
                        type: 'armor',
                        style: 'plate',
                        tier: 'uncommon'
                    };
                    game.player.inventory.push(goldShield);
                    added = true;
                }
                if (added) {
                    game.player.gold -= 75;
                    sfx.pickup();
                    addLog('üõ°Ô∏è Goldschild gekauft! (+12 Verteidigung)', 'loot');
                } else {
                    addLog('Inventar voll!', 'combat');
                }
            } else {
                addLog('Nicht genug Gold! (75 ben√∂tigt)', 'combat');
            }
        });

        // Bombe kaufen Button (40 Gold)
        document.getElementById('buyBombButton').addEventListener('click', () => {
            if (game.player.gold >= 40) {
                game.player.gold -= 40;
                // Find empty slot or add to existing bombs
                let added = false;
                for (let i = 0; i < game.player.inventory.length; i++) {
                    if (!game.player.inventory[i]) {
                        const bomb = { ...selectByRarity(itemTypes.bombs) };
                        game.player.inventory[i] = bomb;
                        added = true;
                        break;
                    }
                }
                if (added) {
                    sfx.pickup();
                    addLog('üí£ Bombe gekauft!', 'loot');
                } else {
                    game.player.gold += 40; // Refund
                    addLog('Inventar voll!', 'combat');
                }
            } else {
                addLog('Nicht genug Gold! (40 ben√∂tigt)', 'combat');
            }
        });

        // ==================== SPEICHER SYSTEM ====================
        function saveGame() {
            const saveData = {
                version: 1,
                timestamp: Date.now(),
                player: {
                    x: game.player.x,
                    y: game.player.y,
                    hp: game.player.hp,
                    maxHp: game.player.maxHp,
                    attack: game.player.attack,
                    baseAttack: game.player.baseAttack,
                    defense: game.player.defense,
                    baseDefense: game.player.baseDefense,
                    gold: game.player.gold,
                    xp: game.player.xp,
                    xpToNext: game.player.xpToNext,
                    level: game.player.level,
                    inventory: game.player.inventory,
                    equipment: game.player.equipment
                },
                currentRoom: game.currentRoom,
                roomsCleared: game.roomsCleared,
                monstersKilled: game.monstersKilled
            };

            try {
                localStorage.setItem('dungeonCrawlerSave', JSON.stringify(saveData));
                addLog('üíæ Spiel gespeichert!', 'info');
                sfx.pickup();
            } catch (e) {
                addLog('Fehler beim Speichern!', 'combat');
            }
        }

        function loadGame() {
            try {
                const saveStr = localStorage.getItem('dungeonCrawlerSave');
                if (!saveStr) {
                    addLog('Kein Spielstand gefunden!', 'combat');
                    return false;
                }

                const saveData = JSON.parse(saveStr);

                // Restore player data
                game.player.x = saveData.player.x;
                game.player.y = saveData.player.y;
                game.player.hp = saveData.player.hp;
                game.player.maxHp = saveData.player.maxHp;
                game.player.attack = saveData.player.attack;
                game.player.baseAttack = saveData.player.baseAttack;
                game.player.defense = saveData.player.defense;
                game.player.baseDefense = saveData.player.baseDefense;
                game.player.gold = saveData.player.gold;
                game.player.xp = saveData.player.xp;
                game.player.xpToNext = saveData.player.xpToNext;
                game.player.level = saveData.player.level;
                game.player.inventory = saveData.player.inventory || [];
                game.player.equipment = saveData.player.equipment || {};

                game.currentRoom = saveData.currentRoom;
                game.roomsCleared = saveData.roomsCleared;
                game.monstersKilled = saveData.monstersKilled;

                // Regenerate room with correct level
                generateWalls();
                spawnMonsters();
                spawnItems();

                updateInventory();
                updateUI();

                const saveDate = new Date(saveData.timestamp).toLocaleString('de-DE');
                addLog(`üìÇ Spielstand geladen! (${saveDate})`, 'loot');
                addLog(`Level ${game.player.level}, Raum ${game.currentRoom}`, 'info');
                sfx.levelUp();

                return true;
            } catch (e) {
                addLog('Fehler beim Laden!', 'combat');
                return false;
            }
        }

        document.getElementById('saveButton').addEventListener('click', saveGame);
        document.getElementById('loadButton').addEventListener('click', loadGame);
        document.getElementById('highscoreButton').addEventListener('click', showHighscoreMenu);

        // ==================== MUSIK SYSTEM ====================
        const music = {
            context: null,
            isPlaying: false,
            masterGain: null,
            oscillators: [],
            intervalIds: [],

            // Dungeon-Melodie Noten (Moll-Tonleiter f√ºr d√ºstere Stimmung)
            notes: {
                // A-Moll Tonleiter
                A2: 110, B2: 123.47, C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196,
                A3: 220, B3: 246.94, C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392,
                A4: 440
            },

            init() {
                if (this.context) return;
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.context.destination);
            },

            createOscillator(freq, type = 'sine', gainValue = 0.1) {
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = gainValue;
                osc.connect(gain);
                gain.connect(this.masterGain);
                return { osc, gain };
            },

            playNote(freq, duration, type = 'sine', gainValue = 0.1, delay = 0) {
                const startTime = this.context.currentTime + delay;
                const { osc, gain } = this.createOscillator(freq, type, 0);

                // Envelope
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(gainValue, startTime + 0.05);
                gain.gain.linearRampToValueAtTime(gainValue * 0.7, startTime + duration * 0.5);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration + 0.1);
            },

            // Bass-Linie
            playBassLine() {
                const bassNotes = [this.notes.A2, this.notes.E3, this.notes.A2, this.notes.D3];
                let noteIndex = 0;

                const playBass = () => {
                    if (!this.isPlaying) return;
                    this.playNote(bassNotes[noteIndex], 0.8, 'triangle', 0.15);
                    noteIndex = (noteIndex + 1) % bassNotes.length;
                };

                playBass();
                const id = setInterval(playBass, 800);
                this.intervalIds.push(id);
            },

            // Melodie
            playMelody() {
                const melodyPatterns = [
                    [this.notes.A3, this.notes.C4, this.notes.E4, this.notes.A4],
                    [this.notes.A3, this.notes.D4, this.notes.F4, this.notes.A4],
                    [this.notes.G3, this.notes.B3, this.notes.D4, this.notes.G4],
                    [this.notes.A3, this.notes.C4, this.notes.E4, this.notes.C4]
                ];
                let patternIndex = 0;
                let noteIndex = 0;

                const playMelodyNote = () => {
                    if (!this.isPlaying) return;
                    const pattern = melodyPatterns[patternIndex];
                    this.playNote(pattern[noteIndex], 0.3, 'sine', 0.08);

                    noteIndex++;
                    if (noteIndex >= pattern.length) {
                        noteIndex = 0;
                        patternIndex = (patternIndex + 1) % melodyPatterns.length;
                    }
                };

                const id = setInterval(playMelodyNote, 400);
                this.intervalIds.push(id);
            },

            // Atmosph√§rischer Hintergrund
            playAmbient() {
                const ambientNotes = [this.notes.A2, this.notes.E3];
                let noteIndex = 0;

                const playAmbientNote = () => {
                    if (!this.isPlaying) return;
                    // Leiser, langer Ton f√ºr Atmosph√§re
                    this.playNote(ambientNotes[noteIndex], 3, 'sine', 0.03);
                    this.playNote(ambientNotes[noteIndex] * 1.5, 3, 'sine', 0.02); // Quinte
                    noteIndex = (noteIndex + 1) % ambientNotes.length;
                };

                playAmbientNote();
                const id = setInterval(playAmbientNote, 3200);
                this.intervalIds.push(id);
            },

            // Percussion/Drums
            playDrums() {
                let beat = 0;

                const playBeat = () => {
                    if (!this.isPlaying) return;

                    // Kick auf 1 und 3
                    if (beat % 4 === 0 || beat % 4 === 2) {
                        this.playNote(60, 0.15, 'sine', 0.2);
                    }
                    // Hi-Hat auf jede Z√§hlzeit
                    this.playNote(800 + Math.random() * 200, 0.05, 'square', 0.02);

                    beat++;
                };

                const id = setInterval(playBeat, 200);
                this.intervalIds.push(id);
            },

            start() {
                this.init();
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                this.isPlaying = true;

                this.playBassLine();
                this.playMelody();
                this.playAmbient();
                this.playDrums();
            },

            stop() {
                this.isPlaying = false;
                this.intervalIds.forEach(id => clearInterval(id));
                this.intervalIds = [];
            },

            toggle() {
                if (this.isPlaying) {
                    this.stop();
                    return false;
                } else {
                    this.start();
                    return true;
                }
            }
        };

        // Music button handler
        document.getElementById('musicButton').addEventListener('click', () => {
            const isPlaying = music.toggle();
            document.getElementById('musicButton').textContent = isPlaying ? 'üéµ' : 'üîá';
        });

        // ==================== END MUSIK SYSTEM ====================

        // ==================== SOUND EFFECTS SYSTEM (REALISTIC) ====================
        const sfx = {
            context: null,
            enabled: true,
            volume: 0.5,

            init() {
                if (!this.context) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
            },

            // Erstellt einen Reverb-Effekt
            createReverb(duration = 1) {
                const sampleRate = this.context.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.context.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }

                const convolver = this.context.createConvolver();
                convolver.buffer = impulse;
                return convolver;
            },

            // Realistisches Rauschen mit H√ºllkurve
            createNoise(duration, filterFreq = 1000, filterType = 'lowpass', attack = 0.01, decay = 0.1) {
                const bufferSize = this.context.sampleRate * (duration + 0.1);
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.context.createBufferSource();
                const filter = this.context.createBiquadFilter();
                const gain = this.context.createGain();

                noise.buffer = buffer;
                filter.type = filterType;
                filter.frequency.value = filterFreq;
                filter.Q.value = 1;

                const now = this.context.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume, now + attack);
                gain.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);

                noise.connect(filter);
                filter.connect(gain);

                return { noise, gain, filter };
            },

            // Komplexer Ton mit Obert√∂nen
            createComplexTone(freq, harmonics = [1, 0.5, 0.25], types = ['sine']) {
                const oscillators = [];
                const gainNode = this.context.createGain();

                harmonics.forEach((amp, i) => {
                    const osc = this.context.createOscillator();
                    const oscGain = this.context.createGain();
                    osc.type = types[i % types.length];
                    osc.frequency.value = freq * (i + 1);
                    oscGain.gain.value = amp * this.volume;
                    osc.connect(oscGain);
                    oscGain.connect(gainNode);
                    oscillators.push({ osc, gain: oscGain });
                });

                return { oscillators, masterGain: gainNode };
            },

            // === SCHWERT & WAFFEN ===

            swordSwing() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Metallisches Schwingen
                const { noise, gain } = this.createNoise(0.2, 3000, 'highpass', 0.01, 0.15);
                gain.connect(this.context.destination);
                noise.start(now);

                // Luft-Whoosh
                const { noise: whoosh, gain: whooshGain, filter } = this.createNoise(0.25, 800, 'bandpass', 0.02, 0.2);
                filter.Q.value = 2;
                filter.frequency.setValueAtTime(400, now);
                filter.frequency.linearRampToValueAtTime(1200, now + 0.1);
                filter.frequency.linearRampToValueAtTime(600, now + 0.2);
                whooshGain.gain.value *= 0.6;
                whooshGain.connect(this.context.destination);
                whoosh.start(now);
            },

            punch() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Dumpfer Aufprall
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);

                filter.type = 'lowpass';
                filter.frequency.value = 200;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.8, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.2);

                // Fleisch-Aufprall
                const { noise, gain: nGain } = this.createNoise(0.08, 400, 'lowpass', 0.005, 0.06);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            // === SPIELER ===

            playerHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Schmerz-Grunt
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(180, now);
                osc.frequency.linearRampToValueAtTime(120, now + 0.15);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.linearRampToValueAtTime(300, now + 0.15);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.25);

                // Impact
                const { noise, gain: nGain } = this.createNoise(0.1, 600, 'lowpass', 0.005, 0.08);
                nGain.gain.value *= 0.4;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            playerDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Todes-St√∂hnen
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'sawtooth';
                    const startFreq = 200 - i * 40;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.2);
                    osc.frequency.linearRampToValueAtTime(startFreq * 0.5, now + i * 0.2 + 0.4);

                    filter.type = 'lowpass';
                    filter.frequency.value = 600 - i * 100;

                    gain.gain.setValueAtTime(0, now + i * 0.2);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + i * 0.2 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.5);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.2);
                    osc.stop(now + i * 0.2 + 0.6);
                }
            },

            // === MAGIE ===

            magicShoot() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Summen mit Shimmer
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const baseFreq = 400 + i * 200;
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(baseFreq * 1.5, now + 0.15);

                    // LFO f√ºr Shimmer
                    const lfo = this.context.createOscillator();
                    const lfoGain = this.context.createGain();
                    lfo.frequency.value = 20 + i * 5;
                    lfoGain.gain.value = 30;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(this.volume * (0.2 - i * 0.05), now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.35);
                    lfo.stop(now + 0.35);
                }
            },

            fireShoot() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Feuer-Rauschen
                const { noise, gain, filter } = this.createNoise(0.4, 2000, 'bandpass', 0.02, 0.35);
                filter.Q.value = 0.5;
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.value *= 0.7;
                gain.connect(this.context.destination);
                noise.start(now);

                // Tiefes Wumm
                const osc = this.context.createOscillator();
                const oscGain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                oscGain.gain.setValueAtTime(this.volume * 0.3, now);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                osc.connect(oscGain);
                oscGain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.3);
            },

            // === SKELETT ===

            skeletonHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Realistische Knochen-Klicks
                for (let i = 0; i < 5; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'triangle';
                    const freq = 1200 + Math.random() * 800;
                    osc.frequency.setValueAtTime(freq, now + i * 0.025);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + i * 0.025 + 0.04);

                    filter.type = 'highpass';
                    filter.frequency.value = 800;
                    filter.Q.value = 5;

                    gain.gain.setValueAtTime(0, now + i * 0.025);
                    gain.gain.linearRampToValueAtTime(this.volume * (0.3 - i * 0.04), now + i * 0.025 + 0.002);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.025 + 0.05);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.025);
                    osc.stop(now + i * 0.025 + 0.08);
                }
            },

            skeletonDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Viele Knochen fallen
                for (let i = 0; i < 12; i++) {
                    const delay = i * 0.04 + Math.random() * 0.02;
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    osc.type = 'triangle';
                    const freq = 800 + Math.random() * 1200;
                    osc.frequency.setValueAtTime(freq, now + delay);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.2, now + delay + 0.08);

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    gain.gain.setValueAtTime(0, now + delay);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + delay + 0.003);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.1);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.15);
                }

                // Zusammenbruch-Rauschen
                const { noise, gain } = this.createNoise(0.4, 3000, 'highpass', 0.05, 0.35);
                gain.gain.value *= 0.3;
                gain.connect(this.context.destination);
                noise.start(now + 0.1);
            },

            // === GOBLIN ===

            goblinHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Hohes Quieken
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(900, now + 0.03);
                osc.frequency.linearRampToValueAtTime(500, now + 0.12);

                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.35, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            goblinDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Langer Todesschrei
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(700, now);
                osc.frequency.linearRampToValueAtTime(400, now + 0.3);
                osc.frequency.linearRampToValueAtTime(200, now + 0.5);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2500, now);
                filter.frequency.linearRampToValueAtTime(500, now + 0.4);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.02);
                gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            // === ORK ===

            orcHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Tiefes Grunzen
                const osc = this.context.createOscillator();
                const osc2 = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc2.frequency.setValueAtTime(102, now); // Leichte Verstimmung
                osc.frequency.linearRampToValueAtTime(80, now + 0.15);
                osc2.frequency.linearRampToValueAtTime(78, now + 0.15);

                filter.type = 'lowpass';
                filter.frequency.value = 400;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.25);
                osc2.stop(now + 0.25);
            },

            orcDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Langes tiefes St√∂hnen
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.linearRampToValueAtTime(60, now + 0.6);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, now);
                filter.frequency.linearRampToValueAtTime(150, now + 0.5);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.03);
                gain.gain.linearRampToValueAtTime(this.volume * 0.4, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.8);

                // Aufprall
                const { noise, gain: nGain } = this.createNoise(0.2, 200, 'lowpass', 0.01, 0.15);
                nGain.gain.value *= 0.4;
                nGain.connect(this.context.destination);
                noise.start(now + 0.4);
            },

            // === MAGIER ===

            mageHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Flackern
                for (let i = 0; i < 4; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const freq = 800 + i * 300 + Math.random() * 100;
                    osc.frequency.setValueAtTime(freq, now + i * 0.02);

                    gain.gain.setValueAtTime(0, now + i * 0.02);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + i * 0.02 + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.02 + 0.08);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.02);
                    osc.stop(now + i * 0.02 + 0.1);
                }
            },

            mageDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magie entweicht
                for (let i = 0; i < 8; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    const startFreq = 1500 - i * 100;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.06);
                    osc.frequency.exponentialRampToValueAtTime(200, now + i * 0.06 + 0.3);

                    gain.gain.setValueAtTime(0, now + i * 0.06);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + i * 0.06 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.35);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.06);
                    osc.stop(now + i * 0.06 + 0.4);
                }
            },

            // === D√ÑMON ===

            demonHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Dunkles Knurren
                const osc = this.context.createOscillator();
                const osc2 = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();
                const distortion = this.context.createWaveShaper();

                // Distortion curve
                const curve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i - 128) / 128;
                    curve[i] = Math.tanh(x * 2);
                }
                distortion.curve = curve;

                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(70, now);
                osc2.frequency.setValueAtTime(71, now);

                filter.type = 'lowpass';
                filter.frequency.value = 300;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

                osc.connect(distortion);
                osc2.connect(distortion);
                distortion.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.3);
                osc2.stop(now + 0.3);
            },

            demonDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // H√∂llisches Br√ºllen
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.8);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, now);
                filter.frequency.linearRampToValueAtTime(100, now + 0.7);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.6, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 1.1);

                // Explosives Rauschen
                const { noise, gain: nGain } = this.createNoise(0.5, 400, 'lowpass', 0.1, 0.4);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now + 0.2);
            },

            // === BOSS ===

            bossHit() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Massiver Impact
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.6, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.35);

                const { noise, gain: nGain } = this.createNoise(0.15, 500, 'lowpass', 0.01, 0.12);
                nGain.gain.value *= 0.5;
                nGain.connect(this.context.destination);
                noise.start(now);
            },

            bossDeath() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Epischer Todesschrei
                for (let i = 0; i < 5; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sawtooth';
                    const startFreq = 150 - i * 20;
                    osc.frequency.setValueAtTime(startFreq, now + i * 0.15);
                    osc.frequency.linearRampToValueAtTime(startFreq * 0.3, now + i * 0.15 + 0.4);

                    gain.gain.setValueAtTime(0, now + i * 0.15);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.5, now + i * 0.15 + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.5);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.15);
                    osc.stop(now + i * 0.15 + 0.6);
                }

                // Massive Explosion
                const { noise, gain } = this.createNoise(1, 600, 'lowpass', 0.1, 0.8);
                gain.gain.value *= 0.6;
                gain.connect(this.context.destination);
                noise.start(now + 0.3);
            },

            // Monster-Dispatcher
            monsterHit(style, isBoss = false) {
                if (isBoss) this.bossHit();
                else if (style === 'skeleton') this.skeletonHit();
                else if (style === 'goblin') this.goblinHit();
                else if (style === 'orc') this.orcHit();
                else if (style === 'mage') this.mageHit();
                else if (style === 'demon') this.demonHit();
                else this.punch();
            },

            monsterDeath(style, isBoss = false) {
                if (isBoss) this.bossDeath();
                else if (style === 'skeleton') this.skeletonDeath();
                else if (style === 'goblin') this.goblinDeath();
                else if (style === 'orc') this.orcDeath();
                else if (style === 'mage') this.mageDeath();
                else if (style === 'demon') this.demonDeath();
                else this.goblinDeath();
            },

            // === ITEMS & UI ===

            itemPickup() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const notes = [523, 659, 784]; // C5, E5, G5
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.25, now + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.2);
                });
            },

            heal() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Magisches Gluckern
                for (let i = 0; i < 6; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400 + i * 80, now + i * 0.08);
                    osc.frequency.linearRampToValueAtTime(600 + i * 80, now + i * 0.08 + 0.1);

                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.2, now + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.2);
                }
            },

            levelUp() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                const notes = [523, 587, 659, 784, 880, 1047]; // C-Dur aufsteigend
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const osc2 = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc2.type = 'triangle';
                    osc.frequency.value = freq;
                    osc2.frequency.value = freq * 2;

                    gain.gain.setValueAtTime(0, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.3, now + i * 0.1 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.25);

                    osc.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.1);
                    osc2.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.3);
                    osc2.stop(now + i * 0.1 + 0.3);
                });
            },

            doorOpen() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Knarren
                const { noise, gain, filter } = this.createNoise(0.4, 400, 'bandpass', 0.05, 0.35);
                filter.Q.value = 5;
                filter.frequency.setValueAtTime(200, now);
                filter.frequency.linearRampToValueAtTime(500, now + 0.2);
                filter.frequency.linearRampToValueAtTime(300, now + 0.4);
                gain.gain.value *= 0.4;
                gain.connect(this.context.destination);
                noise.start(now);

                // Metallisches Klicken
                const osc = this.context.createOscillator();
                const oscGain = this.context.createGain();
                osc.type = 'square';
                osc.frequency.value = 1200;
                oscGain.gain.setValueAtTime(this.volume * 0.15, now + 0.3);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                osc.connect(oscGain);
                oscGain.connect(this.context.destination);
                osc.start(now + 0.3);
                osc.stop(now + 0.4);
            },

            newRoom() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Atmosph√§rischer Ton
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = 220;

                filter.type = 'lowpass';
                filter.frequency.value = 500;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            bombThrow() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Wurf-Whoosh
                const { noise, gain, filter } = this.createNoise(0.2, 1500, 'bandpass', 0.02, 0.15);
                filter.Q.value = 1;
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.linearRampToValueAtTime(2000, now + 0.1);
                gain.connect(this.context.destination);
                noise.start(now);
            },

            bombExplode() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // Tiefe Explosion
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.volume * 0.8, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start(now);
                osc.stop(now + 0.6);

                // Explosions-Rauschen
                const { noise, gain: nGain, filter } = this.createNoise(0.6, 2000, 'lowpass', 0.01, 0.5);
                filter.frequency.setValueAtTime(4000, now);
                filter.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                nGain.gain.value *= 0.7;
                nGain.connect(this.context.destination);
                noise.start(now);

                // Nachhall
                const { noise: echo, gain: echoGain } = this.createNoise(0.8, 500, 'lowpass', 0.2, 0.6);
                echoGain.gain.value *= 0.3;
                echoGain.connect(this.context.destination);
                echo.start(now + 0.2);
            },

            goldPickup() {
                if (!this.enabled) return;
                this.init();
                const now = this.context.currentTime;

                // M√ºnzen-Klingeln
                for (let i = 0; i < 3; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = 2000 + i * 500 + Math.random() * 200;

                    gain.gain.setValueAtTime(0, now + i * 0.05);
                    gain.gain.linearRampToValueAtTime(this.volume * 0.15, now + i * 0.05 + 0.005);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.1);

                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.start(now + i * 0.05);
                    osc.stop(now + i * 0.05 + 0.15);
                }
            }
        };
        // ==================== END SOUND EFFECTS ====================

        // Sound Effects toggle button
        document.getElementById('sfxButton').addEventListener('click', () => {
            sfx.enabled = !sfx.enabled;
            document.getElementById('sfxButton').textContent = sfx.enabled ? 'üîä' : 'üîà';
        });

        // Fullscreen toggle
        document.getElementById('fullscreenButton').addEventListener('click', () => {
            const container = document.getElementById('gameContainer');
            if (!document.fullscreenElement) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                document.getElementById('fullscreenButton').textContent = 'üñ•Ô∏è Vollbild beenden';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                document.getElementById('fullscreenButton').textContent = 'üñ•Ô∏è Vollbild';
            }
        });

        // ==================== SECRET MENU SYSTEM ====================
        const SECRET_CODE = 'Uu09876';

        // Get all available weapons for the give command
        function getAllWeapons() {
            const weapons = [...itemTypes.weapons];
            // Add monster drops
            for (const drop of Object.values(itemTypes.monsterDrops)) {
                weapons.push(...drop.items.filter(i => i.type === 'weapon'));
            }
            return weapons;
        }

        function getAllItems() {
            return {
                weapons: getAllWeapons(),
                armor: itemTypes.armor,
                potions: itemTypes.potions,
                bombs: itemTypes.bombs
            };
        }

        function openSecretMenu() {
            game.secretMenuOpen = true;
            document.getElementById('secretMenu').style.display = 'block';
            document.getElementById('commandInput').focus();
            addCommandOutput('üîì Entwickler-Men√º aktiviert!', 'success');
        }

        function closeSecretMenu() {
            game.secretMenuOpen = false;
            document.getElementById('secretMenu').style.display = 'none';
            document.getElementById('commandOutput').innerHTML = '';
        }

        function addCommandOutput(text, type = 'info') {
            const output = document.getElementById('commandOutput');
            const line = document.createElement('div');
            line.className = `cmd-line cmd-${type}`;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function executeCommand(cmd) {
            const parts = cmd.trim().toLowerCase().split(/\s+/);
            const command = parts[0];

            if (command === '/help' || command === '/h' || command === '/?') {
                addCommandOutput('=== BEFEHLE ===', 'info');
                addCommandOutput('/give *name* - Item suchen & geben', 'info');
                addCommandOutput('/list weapons|armor|monsters', 'info');
                addCommandOutput('/spawn goblin|skeleton|orc|mage|demon|boss [el1|el2|el3]', 'info');
                addCommandOutput('/skip [anzahl] - Level √ºberspringen', 'info');
                addCommandOutput('/heal - Voll heilen', 'info');
                addCommandOutput('/god - Unverwundbar', 'info');
                addCommandOutput('/kill - Alle Monster t√∂ten', 'info');
                addCommandOutput('/xp [menge] - XP geben', 'info');
                addCommandOutput('/stats - Spieler-Stats', 'info');
                addCommandOutput('/tp [x] [y] - Teleportieren', 'info');
                addCommandOutput('/clear - Items l√∂schen', 'info');
                addCommandOutput('/speed [wert] - Spieler-Speed', 'info');
                return;
            }

            if (command === '/list') {
                const listType = parts[1];
                if (listType === 'weapons' || listType === 'w') {
                    addCommandOutput('=== WAFFEN ===', 'info');
                    getAllWeapons().forEach(w => addCommandOutput(`${w.name} (${w.attack} ATK)`, 'info'));
                } else if (listType === 'armor' || listType === 'a') {
                    addCommandOutput('=== R√úSTUNGEN ===', 'info');
                    itemTypes.armor.forEach(a => addCommandOutput(`${a.name} (${a.defense} DEF)`, 'info'));
                } else if (listType === 'monsters' || listType === 'm') {
                    addCommandOutput('=== MONSTER ===', 'info');
                    monsterTypes.forEach(m => addCommandOutput(`${m.name} (${m.style})`, 'info'));
                } else {
                    addCommandOutput('Nutzung: /list weapons|armor|monsters', 'error');
                }
                return;
            }

            if (command === '/spawn' || command === '/s') {
                const type = parts[1];
                const eliteLevel = parts[2];  // el1, el2, el3
                const monsterMap = {
                    'goblin': 0, 'g': 0,
                    'skeleton': 1, 'skel': 1, 'sk': 1,
                    'orc': 2, 'o': 2,
                    'mage': 3, 'dark': 3, 'm': 3,
                    'demon': 4, 'd': 4,
                    'boss': 'boss', 'b': 'boss'
                };

                if (type in monsterMap) {
                    let template, isBoss = false, isElite = false;

                    // Check for elite modifier (el1, el2, el3)
                    const eliteMatch = eliteLevel ? eliteLevel.match(/^el(\d)$/i) : null;
                    const eliteTier = eliteMatch ? parseInt(eliteMatch[1]) : 0;

                    if (monsterMap[type] === 'boss') {
                        template = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                        isBoss = true;
                    } else if (eliteTier > 0) {
                        // Spawn elite version
                        template = eliteMonsterTypes[monsterMap[type]];
                        isElite = true;
                    } else {
                        template = monsterTypes[monsterMap[type]];
                    }

                    // Elite monsters get better weapons
                    const weaponPool = isElite
                        ? (eliteMonsterWeapons[template.style] || monsterWeapons[template.style] || [null])
                        : (monsterWeapons[template.style] || [null]);
                    const armorPool = isElite
                        ? (eliteMonsterArmors[template.style] || monsterArmors[template.style] || [null])
                        : (monsterArmors[template.style] || [null]);
                    const equippedWeapon = weaponPool[Math.floor(Math.random() * weaponPool.length)];
                    const equippedArmor = armorPool[Math.floor(Math.random() * armorPool.length)];
                    const baseAtk = template.baseAttack || template.attack || 10;
                    const baseDef = template.baseDefense || template.defense || 2;

                    // Elite tier multiplier (el1=1.0x, el2=1.5x, el3=2.0x bonus stats)
                    const eliteMultiplier = eliteTier > 0 ? 1 + (eliteTier - 1) * 0.5 : 1;

                    const monster = {
                        ...template,
                        x: game.player.x + (Math.random() - 0.5) * 200,
                        y: game.player.y + (Math.random() - 0.5) * 200,
                        size: isBoss ? 35 : (isElite ? 24 : (template.style === 'orc' ? 22 : 18)),
                        hp: Math.floor(template.hp * eliteMultiplier),
                        maxHp: Math.floor(template.hp * eliteMultiplier),
                        attack: Math.floor((baseAtk + (equippedWeapon ? equippedWeapon.attack : 0)) * eliteMultiplier),
                        defense: Math.floor((baseDef + (equippedArmor ? equippedArmor.defense : 0)) * eliteMultiplier),
                        equippedWeapon, equippedArmor,
                        weaponRange: equippedWeapon ? equippedWeapon.range : 40,
                        targetX: game.player.x, targetY: game.player.y,
                        aiTimer: 0, animFrame: 0, attackFrame: 0, flashTimer: 0, rangedCooldown: 0, meleeCooldown: 0,
                        isBoss, isElite
                    };
                    game.monsters.push(monster);
                    const eliteText = isElite ? ` (Elite Stufe ${eliteTier})` : '';
                    addCommandOutput(`‚úÖ ${monster.name}${eliteText} gespawnt!`, 'success');
                } else {
                    addCommandOutput('Nutzung: /spawn goblin|skeleton|orc|mage|demon|boss [el1|el2|el3]', 'error');
                }
                return;
            }

            if (command === '/stats') {
                addCommandOutput('=== SPIELER-STATS ===', 'info');
                addCommandOutput(`HP: ${game.player.hp}/${game.player.maxHp}`, 'info');
                addCommandOutput(`ATK: ${game.player.attack} (Basis: ${game.player.baseAttack})`, 'info');
                addCommandOutput(`DEF: ${game.player.defense} (Basis: ${game.player.baseDefense})`, 'info');
                addCommandOutput(`Level: ${game.player.level} | XP: ${game.player.xp}/${game.player.xpToNext}`, 'info');
                addCommandOutput(`Gold: ${game.player.gold}`, 'info');
                addCommandOutput(`Waffe: ${game.player.equippedWeapon ? game.player.equippedWeapon.name : 'Keine'}`, 'info');
                addCommandOutput(`R√ºstung: ${game.player.equippedArmor ? game.player.equippedArmor.name : 'Keine'}`, 'info');
                return;
            }

            if (command === '/tp') {
                const tx = parseInt(parts[1]) || game.player.x;
                const ty = parseInt(parts[2]) || game.player.y;
                game.player.x = Math.max(30, Math.min(canvas.width - 30, tx));
                game.player.y = Math.max(30, Math.min(canvas.height - 30, ty));
                addCommandOutput(`‚úÖ Teleportiert zu (${Math.floor(game.player.x)}, ${Math.floor(game.player.y)})`, 'success');
                return;
            }

            if (command === '/clear') {
                const count = game.items.length;
                game.items = [];
                addCommandOutput(`‚úÖ ${count} Items gel√∂scht!`, 'success');
                return;
            }

            if (command === '/speed') {
                const spd = parseFloat(parts[1]) || 4;
                game.player.speed = Math.max(1, Math.min(20, spd));
                addCommandOutput(`‚úÖ Speed: ${game.player.speed}`, 'success');
                return;
            }

            if (command === '/give' || command === '/g') {
                const itemName = parts.slice(1).join(' ').toLowerCase();

                if (!itemName) {
                    addCommandOutput('/give *name* oder /give gold *menge*', 'error');
                    return;
                }

                // Check for gold
                if (itemName === 'gold' || itemName.startsWith('gold ')) {
                    const amount = parseInt(parts[2]) || 1000;
                    game.player.gold += amount;
                    addCommandOutput(`‚úÖ +${amount} Gold!`, 'success');
                    return;
                }

                // Search weapons
                const weapons = getAllWeapons();
                const weapon = weapons.find(w => w.name.toLowerCase().includes(itemName));
                if (weapon) {
                    game.player.equippedWeapon = { ...weapon };
                    game.player.attack = game.player.baseAttack + weapon.attack;
                    addCommandOutput(`‚úÖ ${weapon.name} ausger√ºstet!`, 'success');
                    return;
                }

                // Search armor
                const armor = itemTypes.armor.find(a => a.name.toLowerCase().includes(itemName));
                if (armor) {
                    game.player.equippedArmor = { ...armor };
                    game.player.defense = game.player.baseDefense + armor.defense;
                    addCommandOutput(`‚úÖ ${armor.name} ausger√ºstet!`, 'success');
                    return;
                }

                // Search potions
                const potion = itemTypes.potions.find(p => p.name.toLowerCase().includes(itemName));
                if (potion) {
                    game.player.inventory.push({ ...potion });
                    addCommandOutput(`‚úÖ ${potion.name} erhalten!`, 'success');
                    return;
                }

                // Search bombs
                const bomb = itemTypes.bombs.find(b => b.name.toLowerCase().includes(itemName));
                if (bomb) {
                    game.player.inventory.push({ ...bomb });
                    addCommandOutput(`‚úÖ ${bomb.name} erhalten!`, 'success');
                    return;
                }

                addCommandOutput(`‚ùå "${itemName}" nicht gefunden`, 'error');
                return;
            }

            if (command === '/skip') {
                const count = Math.max(1, parseInt(parts[1]) || 1);
                for (let i = 0; i < count; i++) {
                    game.currentRoom++;
                }
                game.dyingMonsters = [];
                generateRoom();
                game.player.x = canvas.width / 2;
                game.player.y = canvas.height - 50;
                game.player.spawnProtection = 180;
                spawnMonsters();
                spawnItems();
                document.getElementById('currentRoom').textContent = game.currentRoom;
                addCommandOutput(`‚úÖ ${count} Level √ºbersprungen! Jetzt in Level ${game.currentRoom}`, 'success');
                addLog(`‚è≠Ô∏è Zu Level ${game.currentRoom} gesprungen!`, 'info');
                return;
            }

            if (command === '/heal') {
                game.player.hp = game.player.maxHp;
                addCommandOutput('‚úÖ Vollst√§ndig geheilt!', 'success');
                addLog('üíö Vollst√§ndig geheilt!', 'loot');
                return;
            }

            if (command === '/god') {
                game.player.defense = game.player.defense >= 9999 ? game.player.baseDefense : 9999;
                const isGod = game.player.defense >= 9999;
                addCommandOutput(isGod ? '‚úÖ Gott-Modus AKTIVIERT!' : '‚ùå Gott-Modus DEAKTIVIERT!', isGod ? 'success' : 'info');
                addLog(isGod ? '‚ö° GOTT-MODUS!' : '‚ö° Gott-Modus beendet', 'level');
                return;
            }

            if (command === '/kill') {
                const count = game.monsters.length;
                game.monsters.forEach(m => {
                    game.player.xp += m.xp;
                    game.player.gold += m.gold;
                    game.monstersKilled++;
                    createParticles(m.x, m.y, m.color);
                });
                game.monsters = [];
                checkRoomCleared();
                addCommandOutput(`‚úÖ ${count} Monster get√∂tet!`, 'success');
                addLog(`üíÄ ${count} Monster eliminiert!`, 'combat');
                return;
            }

            if (command === '/xp') {
                const amount = parseInt(parts[1]) || 100;
                game.player.xp += amount;
                checkLevelUp();
                addCommandOutput(`‚úÖ ${amount} XP erhalten!`, 'success');
                addLog(`‚ú® ${amount} XP erhalten!`, 'loot');
                return;
            }

            addCommandOutput(`‚ùå Unbekannter Befehl: ${command}. Tippe /help`, 'error');
        }

        // Secret code detection
        document.addEventListener('keydown', (e) => {
            // Don't track when in input field
            if (document.activeElement.tagName === 'INPUT') return;

            // ESC to close secret menu
            if (e.key === 'Escape' && game.secretMenuOpen) {
                closeSecretMenu();
                return;
            }

            // Track secret code input
            if (!game.secretMenuOpen) {
                game.secretCodeBuffer += e.key;
                // Keep only the last N characters where N is the length of the secret code
                if (game.secretCodeBuffer.length > SECRET_CODE.length) {
                    game.secretCodeBuffer = game.secretCodeBuffer.slice(-SECRET_CODE.length);
                }

                // Check if secret code was entered
                if (game.secretCodeBuffer === SECRET_CODE) {
                    game.secretCodeBuffer = '';
                    game.secretCodeUnlocked = true;
                    openSecretMenu();
                }
            }
        });

        // Command input handler
        document.getElementById('commandInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target;
                const cmd = input.value.trim();
                if (cmd) {
                    addCommandOutput(`> ${cmd}`, 'info');
                    executeCommand(cmd);
                    input.value = '';
                }
                e.preventDefault();
            } else if (e.key === 'Escape') {
                closeSecretMenu();
            }
            e.stopPropagation();
        });

        // Prevent game keys while in secret menu input
        document.getElementById('commandInput').addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        // ==================== END SECRET MENU ====================

        // Initialize
        generateRoom();
        spawnMonsters();
        spawnItems();
        addLog('Willkommen im Dungeon! Besiege alle Monster!', 'info');
        gameLoop();
    </script>
</body>
</html>